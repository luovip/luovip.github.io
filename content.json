{"posts":[{"title":"Linux基本使用","text":"1 访问命令行 1.1 登录Linux系统12345678910111213141516图形化​ 系统菜单-注销-或切换用户字符界面​ Ctrl+alt+F2-F6 在本机上切换用户给su - root 切换用户ctrl+d 退出登录(ctrl+d or exit or logout)网络登录​ ssh ip 或 主机名[kiosk@foundation0 ~]$ ssh servera​ ssh 用户名@ip/主机名[kiosk@foundation0 ~]$ ssh root@servera[kiosk@foundation0 ~]$ ssh student@servera 1.2 终端切换12CLI Ctrl+alt+Fx xin （2，6）GUI Ctrl+alt+F1 1.3 Shell简介​ 是一个解释器，可以帮助用户将指令信息传递内核 ​ 红帽企业Linux中为用户提供默认shell是bash，bash是与UNIX类似的系统上使用的其中一个最成功的shell改进版本 1.4 基本组成12345678[kiosk@foundation0 ~]$ #$普通用户[kiosk@foundation0 ~]$ su - root #切换用户：su - 用户名Password: #输入用户登录密码Last login: Sat Feb 22 15:11:13 CST 2020 on tty3[root@foundation0 ~]# #超级用户ctrl+d or exit 退出登录 注：bash shell在概念上与微软的cmd相似，但bash具有更加复杂的脚本语言 ​ 与win系统powershell类似、mac的管理终端使用工具也是使用的bash shell 1.5 GNOME Shell123456789ALT+F2 输入 gnome-terminal # 启动终端# 锁定 win+l# 关闭和重启 init 0 init 6 poweroff reboot systemctl poweroff systemctl reboot shutdown -h 20：00 shutdown -r 0# 工作区切换 ctrl+alt 上\\|下 箭头 1.6 Shell的特性linux命令语法完成具体功能的命令、扩展该命令功能的选项、命令要操作的对象 cmd 【-option】 【arg1】 【arg2】 1234567891011121314简单的命令示例：whoamidatetouch file1；mkdir dir1完成某些工作的指令扩展命令功能的选项参数lsls -a ls -a ~/.bashrcls -a -l ~/.bashrcls -al ~/.bashrc 回显式命令12date +%Y%m%ddate +%Y-%m-%d 交互式命令1passwd tab补全123按一下是补全按两下列出可用命令tab键 输入单词或命令前面几个首字母后，保证唯一可补全，不唯一可列出能选择的命令 历史命令-history123env--能容纳1000条[root@servera ~]# env | grep SIZEHISTSIZE=1000 1234567891011121314151617181920212223[root@servera ~]# history -w [root@servera ~]# vim ~/.bash_history 记录历史命令文件，vim是一个文本工具，可以打开后面的文件，进入后:q退出[root@servera ~]# history -c 清除[root@servera ~]# history history的其他方法：！！！23 历史命令的编号！h 命令首字母当前历史命令支持的最大条数[root@foundation0 /]# grep ^HISTSIZE /etc/profileHISTSIZE=1000历史命令存放文件路径[root@foundation0 /]# set | grep HISTFILEHISTFILE=/root/.bash_historyvim /etc/profileexport HISTFILE=/root/.newfilesource /etc/profilehistory -wcat /root/.newfilectrl+R 搜索历史命令 1.7 命令行快捷键12345ctrl+shift+t #当前画面添加一个标签ctrl+shift+n #打开一个新的标签alt+1，alt+2 #切换标签ctrl+shift+ =，ctrl+ - #扩大终端字体，缩小字体ctrl+shift+w #关闭标签 1.8 Bash Shell常用的快捷键123456789ctrl+a #光标跳至行首ctrl+e #光标跳至行尾ctrl+u #从光标所在位置清空至行首ctrl+k #从光标所在位置清空至行末ctrl+左箭头 #光标向左跳一个单词ctrl+右箭头 #光标向右跳一个单词ctrl+w #回删一个单词alt+d #删除光标后一个单词esc + . 或 alt + . #调用之前使用过的路径，alt+.一直点可以向上翻阅路径 2 从命令行管理文件2.1 Linux系统目录结构1234567891011121314151617181920/目录下每个目录的作用:bin 用户可执行目录(命令 root 和 普通)sbin 系统可执行目录(命令 root)lib 库文件目录(32位)lib64 库文件目录(64位)dev 设备文件目录dev 设备文件目usr 应用程序目录var 服务器数据目录(数据 日志)srv 服务器数据目录etc 配置文件目录tmp 临时文件目录boot 服务器启动目录(内核和启动文件)media 媒介目录(u盘,cdrom)mnt 其他挂载点opt 第三方应用程序目录proc 伪文件系统(内核参数,进程信息,硬件信息)sys 伪文件系统(c 配置文件目录 内核参数,进程信息,硬件信息)run 进程锁目录root root管理员家目录home 普通用户家目录 2.2 文件类型12345678文件类型:(7种)- 普通文件 filed 目录文件 directoryc 字符设备文件 characterb 块设备文件 blocks 套接字文件 socketp 管道文件 pipel 符号链接文件(软链接) symbolic 2.3 通过文件名定位文件12[root@foundation0 home]# cd /[root@foundation0 /]# cd /etc/ 2.4 路径的表示绝对路径 ,通常以/开头 例子： 根开头 cd /etc/sysconfig 相对路径 非根开头 cd .. 2.5 导航路径123# pwd[root@foundation0 yum.repos.d]# pwd/etc/yum.repos.d 12345# cdcd - 返回之前的目录cd or cd ~ 家目录cd . 当前目录cd .. 上一级目录 12345678910111213141516171819# lslsls -a ls -a /home ls -a -l ls -al[root@foundation0 ~]# ls -a .viminfo.viminfo[root@foundation0 ~]# ls -a -l .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 ~]# ls -al .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 /]# ls -l -d /homedrwxr-xr-x. 4 root root 30 Mar 13 11:38 /homels -ld /optll -d /optalias 2.6 查看文件内容12345678cat cat /etc/passwd 将文件内容打印到屏幕上tail tail /var/log/message 默认查看文件后10行。-F （追踪）指定文件不存在时再创建相同名称文件 tail -n 5 或 tail -5 /var/log/message head head /var/log/message 默认查看文件头10行 head -5 /var/log/message less less /var/log/message more more /var/log/message vim vim /etc/passwd 文本编辑器 2.7 使用命令行管理文件/目录123456 创建 touch mkdir -p 改名 mv mv 移动 mv mv 拷贝 cp cp -r 删除 rm rm -rtouch、mkdir、rm、cp、mv 123456789101112131415161718192021touch：[root@servera ~]# cd /opt/[root@servera opt]# pwd/opt[root@servera opt]# ls[root@servera opt]# man touch[root@servera opt]# touch file1[root@servera opt]# lsfile1[root@servera opt]# touch file2 file3[root@servera opt]# lsfile1 file2 file3[root@servera opt]# touch /file4 /tmp/file5[root@servera opt]# ls /file4;ls /tmp/file5/file4/tmp/file5[root@servera opt]# touch file{10..20}[root@servera opt]# lsfile1 file11 file13 file15 file17 file19 file20file10 file12 file14 file16 file18 file2 file3a1.txt a2.txt a3.txt b1.txt.....c3.txt 123456789101112131415161718192021222324252627282930313233343536373839mkdir选项：-p：递归创建-v：显示过程[root@servera opt]# rm -f file* [root@servera opt]# ls[root@servera opt]# man mkdir[root@servera opt]# mkdir dir1[root@servera opt]# lsdir1[root@servera opt]# mkdir dir2 /dir3[root@servera opt]# lsdir1 dir2[root@servera opt]# ls /bin dir3 home media proc sbin tmpboot etc lib mnt root srv usrdev file4 lib64 opt run sys var[root@servera opt]# lsdir1 dir2[root@servera opt]# mkdir dir3/dir4mkdir: cannot create directory ‘dir3/dir4’: No such file or directory[root@servera opt]# mkdir -pv dir3/dir4mkdir: created directory 'dir3'mkdir: created directory 'dir3/dir4'[root@servera opt]# ls -R dir3 #-R递归查看，可以查看多级目录内容dir3:dir4dir3/dir4:[root@servera opt]# ll -R dir3/dir4dir3/dir4:total 0[root@servera opt]# ll dir3total 0drwxr-xr-x. 2 root root 6 Mar 13 22:23 dir4[root@servera opt]# ll dir3/dir4/total 0[root@servera opt]# ll dir3/dir4/ -ddrwxr-xr-x. 2 root root 6 Mar 13 22:23 dir3/dir4/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566rm[root@servera opt]# man rm[root@servera opt]# lsdir1 dir2 dir3 file1 file2 file3[root@servera opt]# rm file1rm: remove regular empty file 'file1'? y 询问是否删除y删除n不删除[root@servera opt]# lsdir1 dir2 dir3 file2 file3[root@servera opt]# rm file2rm: remove regular empty file 'file2'? n[root@servera opt]# rm -f file2 强制删除不询问[root@servera opt]# lsdir1 dir2 dir3 file3[root@servera opt]# rm -f file* *代表一个或多个字符[root@servera opt]# lsdir1 dir2 dir3[root@servera opt]# rm dir1 rm: cannot remove 'dir1': Is a directory[root@servera opt]# rm -r dir1 删除目录需要-r表示递归rm: remove directory 'dir1'? y[root@servera opt]# rm -rf dir2[root@servera opt]# lsdir3copy[root@servera opt]# lsdir1 dir2 file1 file2 file3[root@servera opt]# cp file1 /tmp/[root@servera opt]# ls /tmp/file1/tmp/file1[root@servera opt]# cp file1 /tmp/file10[root@servera opt]# ls /tmp/file10/tmp/file10[root@servera opt]# cp /etc/man_db.conf .[root@servera opt]# lsdir1 dir2 file1 file2 file3 man_db.conf[root@servera opt]# cp file2 file3 /tmp/[root@servera opt]# ls /tmp/file*/tmp/file1 /tmp/file2 /tmp/file5/tmp/file10 /tmp/file3[root@servera opt]# cp -r dir1 /tmp/[root@servera opt]# cp -r dir1 /tmp/di10[root@servera opt]# cp /home/student/.bashrc /opt/[root@servera opt]# ll -a [root@servera opt]# cp -p /home/student/.bashrc ./.bashrc1[root@servera opt]# ll -amv[root@servera opt]# lsdir1 dir2 file1 file2 file3 man_db.conf[root@servera opt]# mv file1 /[root@servera opt]# lsdir1 dir2 file2 file3 man_db.conf[root@servera opt]# mv file2 /file20[root@servera opt]# lsdir1 dir2 file3 man_db.conf[root@servera opt]# mv file3 file30[root@servera opt]# lsdir1 dir2 file30 man_db.conf[root@servera opt]# mv dir1 /[root@servera opt]# lsdir2 file30 man_db.conf[root@servera opt]# mv dir2 dir20[root@servera opt]# lsdir20 file30 man_db.conf 2.8 通配符通配符 1234567# 通配符规则* 匹配0个或多个任意字符？ 匹配1个任意字符[ ] 匹配中括号内一个字符[ - ] 匹配中括号内连续范围的一个字符[ ^ ] 取反。匹配非中括号内的字符，表示一定有一个字符，但不是中括号内出现的。【^ab】{a,b}或{a..c} 匹配号中的字符，或连续的字符 123456789101112131415161718192021222324252627282930313233[root@servera opt]# rm -rf *[root@servera opt]# touch {a..c}{1..3}.txt[root@servera opt]# lsa1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls *.txta1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls a*a1.txt a2.txt a3.txt[root@servera opt]# ls a?.txta1.txt a2.txt a3.txt[root@servera opt]# ls ?2*a2.txt b2.txt c2.txt[root@servera opt]# ls ?[23]*a2.txt a3.txt b2.txt b3.txt c2.txt c3.txt[root@servera opt]# ls ?[^23]*a1.txt b1.txt c1.txt[root@servera opt]# ls ?[!23]*a1.txt b1.txt c1.txt[root@servera opt]# ls {a1,b1}*a1.txt b1.txt[root@servera opt]# ls {a..c}*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [[:alpha:]]*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [a-z]*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [A-Z]*b1.txt b2.txt b3.txt c1.txt c2.txt c3.txt 3 在线获取帮助3.1 MAN帮助手册12345678man 1 用户命令 *man 2 系统调用man 3 库调用man 4 特殊文件man 5 配置文件 *man 6 游戏man 7 杂项man 8 系统命令 * 3.2 –help1234567891011121314man passwdman -k passwd mandbman -k passwdman 1 passwdman 5 passwd ls --helpman tarman setfacl | grep lisaman setfacl | grep -B 1 lisasetfacl --help | grep \\\\-asetfacl --help | grep -w \\\\-a 3.3 Pinfo123infopinfo 回车 upinfo ls 3.4 rpm包中提供帮助1234567891011121314yum install -y httpdrpm -qa | grep httpdrpm -ql 软件包名称rpm -qchttp tools install serveraclassroom和bastionyum install -y httpd-manualsystemctl start servera允许http，或关闭防火墙found：http：//172.25.250.10/manual 3.5 在线帮助https://access.redhat.com/ 4 创建、查看编辑文本4.1 VIM文本编辑器1234# 模式 功能 命令模式 光标移动、复制删除 cmd 输入模式 输入文本内容 a 末行模式 保存退出、设置环境 4.2 命令模式12345678910111213# 命令 解释 h j k l 左下上右 方向键 上下左右 1G、nG n代表一个数字，去第1行或n行 gg 将光标定位到文章的顶端 G 将光标定位到文章的底端 （\\$定位光标到行尾，0和\\^定位光标到行首） x，X 向后删除，向前删除一个字符 dd ， ndd 删除1行，n是一个数字，n行 。 例子：dgg dG d\\$ d0 D yy，nyy 复制1行，n行 p，P 粘贴到下一行，粘贴到上一行 u 撤销 ZZ 保存退出 按键ZZ 4.3 插入模式12345678a 字符后进入插入模式i 当前字符位置进入插入模式o 在下一行新创建一行进入插入模式A 在行尾进入插入模式I 在行首进入插入模式O 在上一行新创建一行进入插入模式s 删除光标位置字符并进入插入模式S 删除光标所在行并进入插入模式 4.4 末行模式1234567891011w 保存q 退出wq 退出并保存q！ 强制退出x 保存退出set nu 设置行号set nonu 取消行号：w /newfile 另存为其他文件 例子：&quot;:w /man.txt&quot;：r /newfile 读取/newfile到本文件中 例子： &quot;:r /etc/passwd&quot;：！ command vim编辑过程中，查询linux &quot;:! ls /&quot;: e！ 重新读取文件 4.5 其他模式1234v、V或Ctrl+V 可视模式R 替换模式/word，？word /向下查找，？向上查找n，N 定位到下一个匹配字符，定位到上一个匹配字符 4.6 视图模式12视图模式修改方法：ctrl+v ， jjj，I， 写入#号，esc 4.7 缩进+永久保存12345678910111213：set all 查看末行模式的帮助：set autoindent 保存上下缩进：set tabstop=2 调整tab键缩进：set nu 设置行号[root@foundation0 ~]# vim ~/.vimrc 仅对当前用户生效set nuset tabstop=2[root@foundation0 ~]# vim /etc/vimrc 全局设置，每个用户使用vim工具都有行号set nu 4.8 替换12345678910:s/// @@@ AAA ; ;;:s/old/new/:s/old/new/g:#,#s/old/new/g #井号代表一个数字比如：1,5s/old/new/g:%s/old/new/g:#,$s/old/new/g #井号代表数字，比如1，$s ，$代表末行，该命令为1行至末行修改某一段ip地址: %s/192.168.1/172.25.250/g取消文本中某个字段：:%s/10.10.10.10//g 4.9 重定向1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511=stand，2=error，&amp;=1+2pwdlsecho helloecho $SHELLecho 12345echo 123456 &gt; file1cat file1grep root /etc/passwdgrep root /etc/passwd &gt; /opt/a.txtcat /opt/a.txtgrep apache /etc/passwdgrep apache /etc/passwd &gt; /opt/a.txtcat a.txtecho 123456echo 123456 &gt;&gt; a.txtcat a.txtecho abcd 1&gt;&gt; a.txtcat a.txtlscd dir1cd dir1 2&gt; errcat errcd dir1 2&gt; /dev/nullfind / -user studnetfind / -user studentfind / -user student 2&gt; errvim errfind / -user student 2&gt; err &gt; stavim stafind / -user student &amp;&gt; sharevim sharegrep na /etc/resolv.confvim /etc/resolv.confgrep ^$ /etc/resolv.confcat -n /etc/resolv.confcat -n /etc/resolv.conf | grep ^$cat -n /etc/resolv.confvim ~/.vimrccat -n /etc/resolv.confcat /etc/resolv.confgrep -n ^$ /etc/resolv.confgrep na /etc/resolv.confls /root/lsgrep na /etc/resolv.confgrep na /etc/resolv.conf &gt; /root/lines.txtcat /root/lines.txthistory -wtc/resolv.conf &gt; /root/lines.txtcat /root/lines.txt 5 管理本地用户和组5.1 USER-用户基本概念：用户用于访问计算机资源 12340 超级用户 1000以下 系统用户1000以上 普通用户 组与用户ID对应(自然创建) useradd-添加用户1234567891011121314语法:useradd 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录(通常不更改，如果设置，需要是未存在的目录)例：useradd user1 创建user1passwd user1 为user1设置密码id user1 查询用户信息 用户配置文件12345678910111213141516171819202122232425262728293031323334用户配置文件路径:/etc/passwd[kiosk@foundation0 ~]$ vim /etc/passwdroot:x:0:0:root:/root:/bin/bash用户名：密码占位符：UID：GID：描述：家目录：shell环境练习1： [root@servera /]# useradd -u 2000 user1[root@servera /]# id user1[root@servera /]# groupadd group1[root@servera /]# tail -1 /etc/group[root@servera /]# useradd -g group1 user2[root@servera /]# tail -1 /etc/passwd[root@servera /]# useradd -G wheel user3[root@servera /]# useradd -c student -d /user4dir -s /sbin/nologin user4[root@servera /]# tail -1 /etc/passwd[root@servera /]# su - user1[user1@servera /]# ctrl+d[root@servera /]# su - user1[root@servera /]# su - user2 需要密码[root@servera /]# ctrl+d 退出用户[root@servera /]# passwd user2 超级用户设置密码123456123456[root@servera /]# su - user1[root@servera /]# su - user2 输入密码[root@servera /]# useradd -G root,tom user5 #将user5同时加入到组root和tom组中练习2：tom10，uid 3000 ，gid devops，shell环境为/bin/false,描述 student，家目录/tom10dir,附加组 root。答案：useradd -u 3000 -g devops -s /bin/false -c student -d /tom10dir -G root tom10 usermod-修改用户123456789101112131415161718192021222324252627282930语法：usermod 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录（通常不更改，且如设置需要是未存在的目录）-a：额外指定附加组练习1:[root@servera /]# usermod -u 3000 user1[root@servera /]# usermod -g group1 user1[root@servera /]# usermod -G root user1[root@servera /]# grep user1 /etc/group[root@servera /]# usermod -G root,wheel user1[root@servera /]# grep user1 /etc/group[root@servera /]# groupadd group2[root@servera /]# usermod -a -G group2 user1[root@servera /]# grep user1 /etc/group[root@servera /]# usermod -s /bin/false user1 #shell环境为/bin/false的用户和系统无任何交互[root@servera /]# su - user1[root@servera /]# usermod -c heihei user1练习2：tom11的附加组，root。想额外添加一个附加组为devops。答案：[root@servera opt]# usermod -a -G root tom11[root@servera opt]# usermod -G root,devops tom11 userdel-删除用户12345678910语法：userdel 选项 选项参数 用户名option：-r：删除用户同时删除邮箱和家目录练习:[root@servera /]# useradd user5[root@servera /]# find / -user user5[root@servera /]# userdel -r user5[root@servera /]# find / -user user5 5.2 PASSWORD-密码passwd12345678语法:passwd 用户名方法1：[root@foundation0 /]# useradd zhangsan #创建用户[root@foundation0 /]# echo 123456 | passwd --stdin zhangsan 非交互式Changing password for user zhangsan.passwd: all authentication tokens updated successfully.方法2：[root@foundation0 /]# passwd zhangsan 交互式 密码配置文件12345678910111213141516171819202122232425路径:/etc/shadowuser2:$6$9R47OYVVaxga34EJ$Y3pGf5EnHpn6vfiBk5ZU1U89d7UiySOsnAs/fkFMuPRyhCZAvv0a6UXRVLGXqRUKwP34Sg0W/CYb1VQp7H08L0:20015:0:99999:7:::说明:第一列: 用户名第二列: 密码(有密码状态,无密码状态,!!帐号锁定,* 该帐号永久不能登陆系统)第三列: 密码的最后一次修改时间（从1970年1月1日至今的天数）18834=今天第四列: 密码的最小时间(和第三列比较，密码修改相隔时间，或理解为密码自最后一次修改后多少天内不能再重复修改)第五列: 密码的最大时间(密码有效期) 99999表示永久不过期(和第3列比，相当于自最后一次修改多久后必须变更密码，否则过期)第六列: 密码过期前警告时间（和第5列比，在过n天你的密码就过期了，需要重设密码。）第七列: 密码过期后帐号（宽限时间，第五列密码的最大时间到期后，还可以使用系统的宽限时间，该期间中可以继续使用系统，但是再次登入系统时强制修改密码，否则无法进入）第八列: 帐号有效期（账号失效后，无论密码是否过期都不能使用。）第九列: 保留列练习:设置密码：1.交互式语法：passwd 用户名[root@servera /]# passwd user12.非交互式语法：echo xxx | passwd --stdin username [root@servera /]# echo 123456 | passwd --stdin user1Changing password for user user1.passwd: all authentication tokens updated successfully. 5.3 GROUP-用户组groupadd123456语法：groupadd 选项 选项参数 组名-g：指定组ID例：[root@servera /]# groupadd group10[root@servera /]# groupadd -g 3000 group11 groupmod123456语法：groupmod 选项 选项参数 组名-n：更改组名 groupmod -n 新组名 旧组名例：[root@servera /]# groupmod -n group100 group10[root@servera /]# groupdel1234# 删除组信息groupdel groupname[root@foundation0 ~]# groupdel haha1[root@foundation0 ~]# grep haha1 /etc/group gpasswd加入群组与清除群组成员 12345678910gpasswd-a：添加用户到群组-d：从组中清除用户[root@foundation0 ~]# useradd -G upup user5 添加用户时指定附加组（次要群组）[root@foundation0 ~]# usermod -G upup user1 修改用户时指定附加组（次要群组） [root@foundation0 ~]# gpasswd -a user2 rootAdding user user2 to group root[root@foundation0 ~]# gpasswd -d user2 rootRemoving user user2 from group root 用户组配置文件1234567路径:/etc/group[root@localhost ~]# vim /etc/groupupup:x:2006:第一段: 组名第二段: 组密码占位符号第三段: gid第四段: 用户列表 su-切换用户123su -su - rootsu - user1 su - user2 需要密码 模拟练习1234567891011121314151617181920groupadd sysmgrsuseradd -G sysmgrs natashauseradd -G sysmgrs harryuseradd -s /bin/false sarahecho flectrag | passwd --stdin natahsaecho flectrag | passwd --stdin harryecho flectrag | passwd --stdin sarah验证方式：通过切换用户，id username，vim /etc/passwd修改密码重设默认天数：[root@servera ~]# useradd user10[root@servera ~]# chage -l user10Maximum number of days between password change : 99999[root@servera ~]# vim /etc/login.defs PASS_MAX_DAYS 20[root@servera ~]# useradd user20[root@servera ~]# chage -l user20Maximum number of days between password change : 20 5.4 重点总结12345678910useradd usermod userdel ，id 用户名，cat /etc/passwd，groupadd groupmod groupdel gpasswd -a , -d passwd 用户名 echo xxx | passwd --stdin username 用户 /etc/passwd, 用户组，/etc/group 密码 /etc/shadow创建用户时的一些默认设置，/etc/default/useradd /etc/login.defs 6 控制对文件的访问6.1 关于系统安全的技术点对比12345Linux操作系统涉及的安全部分: 防火墙 semanage port ， selinux semanage ... 软件app semanage boolean 文件系统权限 特殊权限 facl 隐藏权限 semanage fcontext 6.2 Linux文件权限1234权限分类： r read(读) w write(写) x execute(执行) 6.3 Linux系统的权限表示12345# ls -l test-rw-r--r--. 1 stu1 class1 35 May 21 14:09 testrw-r--r-- #中间9位是权限，逻辑分三组，所有者 所属组 其他人权限stu1 所有者class1 所属组 6.4 Linux系统权限的作用1234权限 对文件的影响 对目录的影响 r cat ls w vim touch，rm，mkdir x ./script cd 6.5 使用符号方式修改文件权限123456对象 设置方式 权限u(user) \\+ (添加) rg(group) \\- (减去） wo(other) = (设置） xa(all) s(SUID、SGID) t(Sbit) 6.6 使用数字方式修改文件权限12345rwx 8进制表示 数字表示----- ----------- ----------r-- 100 4-w- 010 2--x 001 1 6.7 文件权限设置-chmod123456789101112语法：chmod 权限 文件名u g o a + - = r w x s t例：[root@node1 /]# cd /opt/[root@node1 opt]# ls[root@node1 opt]# touch test[root@node1 opt]# ll test -rw-r--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# chmod u+x test [root@node1 opt]# ll test -rwxr--r--. 1 root root 0 Nov 24 04:55 test 练习1：文件权限修改12345678910111213141516文件权限修改[root@node1 opt]# touch aa.txt[root@node1 opt]# ll aa.txt #每次修改权限去自己检验查询[root@node1 opt]# chmod u+x aa.txt[root@node1 opt]# chmod u-rw aa.txt[root@node1 opt]# chmod u+r,g+w,o+x aa.txt[root@node1 opt]# chmod ug+rw aa.txt[root@node1 opt]# chmod ugo+rwx aa.txt # chmod a+rwx , chmod a=rwx, ugo+rwx[root@node1 opt]# chmod a-rwx aa.txt[root@node1 opt]# chmod o=--- aa.txt # o=-[root@node1 opt]# chmod u=r aa.txt[root@node1 opt]# chmod u=rw aa.txt[root@node1 opt]# chmod u=r,g=rw,o=x aa.txt[root@node1 opt]# chmod ugo=rwx aa.txt[root@node1 opt]# chmod a=r aa.txt 练习2：数字修改方法12345678910r 4w 2x 1[root@node1 opt]# mkdir dir1[root@node1 opt]# ll -d dir1drwx r-x r-x. 2 root root 6 Nov 24 05:04 dir1[root@node1 opt]# chmod 775 dir1[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 root root 6 Nov 24 05:04 dir1 6.8 设置文件属主和属组-chown123456789101112131415161718192021222324252627282930313233343536373839语法：chown 所有者:所属组 文件名 chown 该命令可以作用于文件、目录，修改时保证所有者的用户及组都是存在的。例:chown user2:user2 newfile# 练习:[root@node1 opt]# ll test-rwxr--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# id studentuid=1000(student) gid=1000(student) groups=1000(student),10(wheel)[root@node1 opt]# useradd harry[root@node1 opt]# chown student test;ll test-rwxr--r--. 1 student root 0 Nov 24 04:55 test[root@node1 opt]# chown :harry test;ll test-rwxr--r--. 1 student harry 0 Nov 24 04:55 test[root@node1 opt]# useradd sally[root@node1 opt]# chown sally:sally test;ll test-rwxr--r--. 1 sally sally 0 Nov 24 04:55 test-R[root@node1 opt]# lsdir1 test[root@node1 opt]# touch dir1/test2[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 root root 19 Nov 24 05:15 dir1[root@node1 opt]# ll dir1total 0-rw-r--r--. 1 root root 0 Nov 24 05:15 test2[root@node1 opt]# chown -R sally:sally dir1[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 sally sally 19 Nov 24 05:15 dir1[root@node1 opt]# ll dir1/test2 -rw-r--r--. 1 sally sally 0 Nov 24 05:16 dir1/test2 6.9 文件默认权限-umask12345678910111213系统默认定义权限对于文件是666、对于目录是777查看umask值方法[root@servera /]# umask0022修改方法umask[root@servera /]# umask 0002修改完后，可以去文件和目录查看权限，看是否和之前不一样，看完改回来永久生效[root@servera /]# echo 'umask 0002' &gt;&gt; ~/.bash_profile[root@servera /]# source ~/.bash_profile #source 将后面文件中的值加载到当前shell中。系统登录会读取~/.bash_profile文件自动加载 umask的练习12345678910111213141516171819202122232425262728293031323334#示例1：文件默认权限666umask后三位022快捷方法：变成权限后相减rw-rw-rw- = 666 文件系统默认权限----w--w- = 022 umask值------------------------------rw-r--r-- = 644 创建文件时的默认权限目录默认权限777rwxrwxrwx = 777 目录系统默认权限----w--w- = 022 umask值------------------------------rwxr-xr-x = 755 创建目录时的默认权限故系统中应设置为:0022#示例2:文件权限是r-- --- ---， 400 文件夹是dr-x --- --- 500umask?目录rwxrwxrwx = 777r-x------ = 500--------------------w-rwxrwx = 277文件rw-rw-rw- = 666-w-rwxrwx = umask ------------------r------- = 400参考umask计算方法：https://www.cnblogs.com/wyllearning/p/16482006.html如果减法时目录和文件权限不一致时，以目录的为准计算umask值 6.10 特殊权限​ 文件系统权限可以完成一些基本权限功能设置，但有些特殊要求是达不到的，可能需要特殊权限来完成 ​ Linux系统中特殊权限有三个：SUID 4 、SGID 2 、SBIT 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SUID 4 通常设置在二进制可执行文件（命令）上，并具有执行权限的情况下 作用：设置了该权限的命令，被其他用户执行时，会临时获取文件所有者权限[student@clear ~]$ su - studnet[student@clear ~]$ cat /etc/shadow #普通用户无法查看/etc/shadow[student@clear ~]$ su - root #切换root身份[root@clear ~]# chmod u+s /usr/bin/cat #数字修改方式：chmod 4755 /usr/bin/cart[root@clear ~]# ll /usr/bin/cat-rwsr-xr-x. 1 root root 34512 Aug 13 2018 /usr/bin/cat[student@clear ~]$ su - studnet[student@clear ~]$ cat /etc/shadow #能够看见内容，临时获取拥有者权限chmod 4755 /usr/bin/catSGID 2该权限通常设置在`目录`上，设置了该权限的目录，在该目录中创建`子文件及目录`时会`继承`父目录所属组。[root@clear ~]# cd /opt/[root@clear opt]# ls[root@clear opt]# mkdir dir1[root@clear opt]# chown student:student dir1[root@clear opt]# ll -d dir1drwxr-xr-x. 2 student student 6 Nov 19 04:50 dir1[root@clear opt]# touch dir1/root.txt[root@clear opt]# ll dir1/root.txt-rw-r--r--. 1 root root 0 Nov 19 04:51 dir1/root.txt[root@clear opt]# [root@clear opt]# chmod g+s dir1[root@clear opt]# ll -d dir1drwxr-sr-x. 2 student student 22 Nov 19 04:51 dir1[root@clear opt]# touch dir1/root1.txt[root@clear opt]# ll dir1/root1.txt-rw-r--r--. 1 root student 0 Nov 19 04:52 dir1/root1.txt数字修改法： chmod 2755 dir1SBIT（粘滞位） 1该权限通常设置在目录上，设置了该权限的目录，其他用户在该目录中只能删除所有者是自己的文件。[root@clear opt]# rm -rf *[root@clear opt]# ls[root@clear opt]# mkdir share[root@clear opt]# chmod 777 share/[root@clear opt]# id studentuid=1000(student) gid=1000(student) groups=1000(student),10(wheel)[root@clear opt]# useradd tom[root@clear opt]# id tomuid=1005(tom) gid=1005(tom) groups=1005(tom)[root@clear opt]# su - studentLast login: Sat Nov 19 04:46:47 EST 2022 on pts/0[student@clear ~]$ touch /opt/share/student.txt[student@clear ~]$ logout[root@clear opt]# su - tom[tom@clear ~]$ rm -f /opt/share/student.txt[tom@clear ~]$ logout[root@clear opt]# chmod 1777 /opt/share/[root@clear opt]# ll -d /opt/share/drwxrwxrwt. 2 root root 6 Nov 19 04:56 /opt/share/[root@clear opt]# su - studentLast login: Sat Nov 19 04:55:24 EST 2022 on pts/0[student@clear ~]$ touch /opt/share/student.txt.haha[student@clear ~]$ logout[root@clear opt]# su - tomLast login: Sat Nov 19 04:55:38 EST 2022 on pts/0[tom@clear ~]$ rm -f /opt/share/student.txt.haharm: cannot remove '/opt/share/student.txt.haha': Operation not permittedcheck：创建两个不同用户登录操作系统，进入dirt目录分别创建文件，尝试互相删除对方文件，结果应不能互相删除文件。大S和小s区别，执行权限位大S是，没有x执行权限位小s是该位，有x 7 进程监控及管理1234yum install -y psmiscpstree -p一程序被开启会产生一个或多个进程，他们都有对应父进程与子进程，每个进程都有进程号PIDsystemd 1 不能被杀死，除非重启，关机。 7.1 ps12345678910111213141516171819以静态的方式查看系统进程ps -lps aux ps aux | grep http[root@servera ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 27392 27367 0 80 0 - 85532 - pts/0 00:00:00 su4 S 0 27396 27392 0 80 0 - 59008 - pts/0 00:00:00 bash4 T 0 27822 27396 1 80 0 - 63962 - pts/0 00:00:00 vim0 R 0 27823 27396 0 80 0 - 63625 - pts/0 00:00:00 ps# 练习：查看httpd进程1、【node1】：yum install -y httpd2、systemctl start httpd3、ps aux |grep httpd4、【foundation】firefox 172.25.250.10 7.2 top1234567以同态的形式查看进程topMPhk pid 9/15 q 退出 7.3 终止进程kill命令12345678910111213141516171819202122232425262728293031语法：kill -s 信号名称 或-n 信号编号Options:-s sig SIG is a signal name-n sig SIG is a signal number例子:kill -s SIGKILL httpdkill -n 9 httpd # 或 kill -9 httpd练习：[root@node1 /]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1[root@node1 /]# vim 1 &amp;[1] 1372[root@node1 /]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 0 1313 1312 0 80 0 - 59084 - pts/1 00:00:00 bash0 T 0 1372 1313 4 80 0 - 60816 - pts/1 00:00:00 vim0 R 0 1373 1313 0 80 0 - 63799 - pts/1 00:00:00 ps[1]+ Stopped vim 1[root@node1 /]# kill -n 9 1372[root@node1 /]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 0 1313 1312 0 80 0 - 59084 - pts/1 00:00:00 bash0 R 0 1374 1313 0 80 0 - 63799 - pts/1 00:00:00 ps[1]+ Killed vim 1 killall命令1234567891011语法：killall 守护进程名称#yum install -y httpdsystemctl start httpdps aux | grep httpdkillall httpdyum provides killallyum install -y psmisc-23.1-3.el8.x86_64killall httpdps aux | grep httpd 7.4 作业控制jobs1234567891011121314151617181920212223242526272829[root@servera ~]# vim file2 （ctrl+z）[1]- Stopped vim file1[2]+ Stopped vim file2[root@servera ~]# jobs[1]- Stopped vim file1[2]+ Stopped vim file2[root@servera ~]# dd if=/dev/zero of=./bigfile bs=1M count=1000ctrl + z [root@servera ~]# jobs[1]+ Stopped dd if=/dev/zero of=./bigfile bs=1M count=1000[root@servera ~]# bg ％1[1]+ dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# jobs[1]+ Running dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# fg %1[root@servera ~]# 1000+0 records in1000+0 records out1048576000 bytes (1.0 GB, 1000 MiB) copied, 65.0049 s, 16.1 MB/s[root@servera ~]# kill -9 %2[2]- Stopped vim file2[root@servera ~]# jobs[2]- Killed vim file2[3]+ Stopped nice -n -10 vim file4 7.5 进程优先级调整1234567891011121314151617nice值超级用户root 可以修改nice值范围 -20~19普通用户user 可以修改nice值范围 0-19进程优先级数字越小，优先级越高。优先级不能直接改，可以通过nice值来影响优先级。旧优先级 + nice值 = 新优先级80 -10 = 70两种方法：一、产生新进程时，设置nice值nice -n -5 vim file2 &amp;二、修改现有进程nice值renice -n 10 PIDps -l 查看需要更改的进程号renice -n 10 28183 8 控制服务与守护进程8.1 服务状态关键字段123456# 字段 描述---------- -------------------------------- Loaded 服务单元是否加载到内存 Active 服务单元是否在运行，运行了多久 Main PID 服务的主进程ID，包括命令名称 Status 有关该服务的其他信息 8.2 systemctl管理服务123456789101112131415161718192021222324252627282930313233343536373839systemctl -t help列入.service扩展名，代表服务，如web服务systemctl list-units --type service 列出当前服务器加载的服务单元systemctl status httpd.service 查看某个服务# yum install -y httpd 安装apache服务服务运行状态[root@servera system]# systemctl status httpd● httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor pr&gt; Active: inactive (dead) Docs: man:httpd.service(8) [root@servera system]# systemctl start httpd [root@servera system]# systemctl status httpd● httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor pr&gt; Active: active (running) since Sat 2020-02-29 04:34:47 CST; 1s ago查看服务是否启动[root@servera system]# systemctl is-active httpdactive查看服务是否开机启动[root@servera system]# systemctl enable httpd[root@servera system]# systemctl is-enabled httpdenabled[root@servera system]# systemctl disable httpdRemoved /etc/systemd/system/multi-user.target.wants/httpd.service.[root@servera system]# systemctl is-enabled httpddisabled常见特征（了解）：1、安装 yum install -y httpd2、启动 systemctl start httpd.service （单元文件）/usr/lib/systemd/system/3、查进程 ps aux | grep httpd , 每个服务有自己的守护进程/usr/sbin/httpd4、查端口 netstat -ntlp ，找到80端口，对应Listen监听状态 对应httpd服务vim /etc/service 改文件记录了系统服务的端口和协议的对应关系 8.3 服务状态分类12345678910# 关键字 描述------------------- ------------------------------------------ loaded 单元配置文件已处理 active（running） 正在通过一个或多个持续进程与运行 active（exited） 已成功完成一次性配置 active（waiting） 运行中，但正在等待事件 inactive 不在运行 enabled 在系统引导时启动 disabled 未设为在系统引导时启动 static 无法启动，但可以由某一启动的单元自动启动 8.4 管理系统服务​ 语法：systemctl 管理命令 unitname 12345678910111213管理命令 描述status 查看状态start 开启stop 关闭restart 重启reload 加载配置文件enable 开机启动disable 关闭开机启动is-active 查看服务状态是否启动is-enabled 查看服务是否开机自启动list-dependencies 【unitname】 查看单元依赖mask 禁止服务，无法启动或开机 启动unmask 解除ma 12345678910111213141516171819202122232425262728293031323334353637383940练习时，重启服务前，先关闭以下两个应用setenforce 0 关闭seliunxsystemctl stop firewalld 关闭防火墙 yum install -y httpdsystemctl start httpd.servicesystemctl status httpdps aux |grep httpdnetstat -ntlpsystemctl is-active httpdsystemctl is-enabled httpdsystemctl status httpdsystemctl --helpsystemctl --help | grep \\\\--systemsystemctl start httpdsystemctl --system start httpdsystemctl --help| grep \\\\--usersystemctl enable httpdsystemctl status httpdsystemctl disable httpdsystemctl status httpdsystemctl mask httpd 注销服务systemctl unmask httpd 取消注销systemctl enable --now httpd 开启服务并且开机自启动 可以用做练习的服务httpd，sshd，autofs，samba。ftp服务器服务开机自启1、安装 vsftpd2、启动 vsftpd.service3、设置开机自启 寻找service文件的方法：[root@servera ~]# rpm -qa | grep autofslibsss_autofs-2.4.0-9.el8.x86_64autofs-5.1.4-48.el8.x86_64[root@servera ~]# rpm -ql autofs | grep service[root@servera ~]# rpm -ql autofs | grep service/usr/lib/systemd/system/autofs.service 9 OPENSSH服务9.1 ssh的常用功能12345678910111213141516[root@servera ~]# ssh serverbroot@serverb's password: [root@servera ~]# vim /etc/hosts 或者系统是否做了dns,ip和域名及主机名的映射[root@servera ~]# ssh 172.25.250.11[root@servera ~]# ssh root@172.25.250.11[root@servera opt]# scp rhcetext root@172.25.250.11:/root@172.25.250.11's password: rhcetext 100% 0 0.0KB/s 00:00[root@serverb /]# scp root@172.25.250.10:/opt/newfile .root@172.25.250.10's password: newfile 100% 0 0.0KB/s 00:00 [root@servera opt]# ssh root@172.25.250.11 'yum install -y httpd'ssh root@172.25.250.11 'yum install -y httpd' 9.2 ssh免密登录12345678910111213【servera】[root@servera ssh]# ssh-keygen 后面三个回车[root@servera ssh]# ssh-copy-id root@serverb【serverb】[root@serverb /]# cd /root/.ssh/[root@serverb .ssh]# lsauthorized_keys known_hosts【servera】[root@servera ssh]# ssh root@serverba免密远程b，如果想b远程a免密，需要相同的配置课上练习：b远程免密登录a 9.3 ssh服务控制123456# 拒绝root登录[root@serverb ~]# vim /etc/ssh/sshd_configPermitRootLogin no[root@serverb ~]# systemctl reload sshd（或restart）[root@servera ~]# ssh root@serverb 9.4 sudo命令1234567891011121314151617181920212223242526272829一、将用户设置为特权用户1、[student@servera ~]$ yum remove -y httpdError: This command has to be run under the root user.2、[root@servera /]# vim /etc/sudoers 或者 visudo## Allow root to run any commands anywhere root ALL=(ALL) ALLstudent ALL=(ALL) ALL3、[student@servera ~]$ sudo yum remove -y httpd[sudo] password for student: student二、将账号添加到特权用户组中，培训环境默认特权用户组是wheel组，在/etc/sudoers文件中用%wheel来表示usermod -G wheel tom三、练习：添加一个特权组admin，而且组内有一个成员是harry。最终harry账号应当为特权账号。[root@serverb ~]# groupadd admin[root@serverb ~]# visudo[root@serverb ~]# useradd -G admin harry[root@serverb ~]# su - harry[harry@serverb ~]$ sudo -i[sudo] password for harry: 四、设置特权组中用户切换时不需要密码%admin ALL=(ALL) NOPASSWD: ALL 10 日志分析与存储10.1 系统中的日志文件1234567# 日志文件 存储的消息类型------------------- ---------------------------------------- /var/log/messages 大多数系统日志消息处存放处 /var/log/secure 与安全性和身份验证时间相关的syslog消息 /var/log/maillog 与邮件服务器相关的syslog消息 /var/log/cron 与计划任务执行相关的syslog消息 /var/log/boot.log 与系统启动相关的消息。 rsyslog服务管理的日志配置文件123456[root@haha log]# yum provides /etc/rsyslog.conf #查看文件是哪个软件包提供的[root@clear log]# rpm -qc rsyslog-8.1911.0-3.el8.x86_64 /etc/logrotate.d/syslog/etc/rsyslog.conf #一般服务文件以.conf结尾，改文件是日志服务的配置文件/etc/sysconfig/rsyslog[root@clear log]# vim /etc/rsyslog.conf 记录日志的规则12345678日志文件配置格式:mail.info /var/log/vsftpd.log #.点代表包含后面级别及以上级别AAAA.BBBB CCCCAAAA 产生日志的设备（类别） #如何产生的日志BBBB 日志的级别 #日志有不同安全级别，类似轻重缓急的严重程度，发出警告CCCC 保存日志的位置 #在系统中保存日志文件的路径 rsyslog配置文件类别(产生日志的设备)1234567891011类别(facility) ---------------- --------------------- Kern 内核 authpriv 授权和安全 cron 计划任务 mail 邮件 daemon 系统守护进程 user 普通用户级别的 syslog 由rsyslog生成的信息 local0\\~local7 自定义本地策略 \\* 所有类别 日志级别1234567891011121314151617181920man 3 syslog# 等级 解释----------------- ---------------------------- EMERG（紧急） 会导致主机系统不可用的情况 ALERT（警告） 必须马上采取措施解决的问题 CRIT（严重） 比较严重的情况 ERR（错误） 运行出现错误 WARNING（提醒） 可能会影响系统功能的事件 NOTICE（注意） 不会影响系统但值得注意 INFO（信息） 一般信息 DEBUG（调试） 程序或系统调试信息等 \\* 所有等级 none 不记录日志 解释：*.info;mail.none;authpriv.none;cron.none /var/log/messages*.info *所有设别 .点代表后面的等级及以上等级，也就是info以上的等级全记录；分号是不同设备等级的分隔符号mail.* -/var/log/maillog- 代表先记录缓存，再记录硬盘，减轻硬盘i/o读写压力。 使用logger发送测试日志信息1234567891011121314151617181920211 查看rsyslog服务是否开启 (默认系统已开启)[root@servera ~]# systemctl status rsyslog2 编辑rsyslog配置文件[root@servera ~]# vim /etc/rsyslog.conf# Save boot messages also to boot.loglocal7.* /var/log/boot.log..*.debug /var/log/messages.debug3 重启rsyslog日志服务让配置生效[root@servera ~]# systemctl restart rsyslog4 开另一个窗口 ctrl+shift+t[root@servera ~]# tail -n 0 -f /var/log/messages.debug 5 使用logger命令生成一个user类别，debug级别的日志内容为“Debug test messages” #（考点）[root@servera ~]# logger -p user.debug &quot;Debug test messages&quot; 6 在第4步的窗口中查看新生成日志信息[root@servera ~]# tail -n 0 -f /var/log/messages.debugJun 18 14:45:31 servera root[29174]: messages haha 10.2 journalctl12345678910111213141516传统的日志服务是rsyslog新添加的日志服务是systemd-journal，它也是一个日志管理服务，可以收集来自内核、系统早期启动阶段的日志，以及系统进程在启动和运行中的一些标准输出与错误输出。此日志一旦重启既消失，因为保存在了/run/log/journal/*/*.journal结尾，该文件是一个二进制日志文件，需要用journalctl命令查看。tail -n 5journalctl 查看系统日志journalctl -n 通过q或ctrl接触观看 ，此命令显示方式类似与tail -njournalctl -n 5 journalctl -p err 日志等级journalctl -f journalctl -p err journalctl -p info （deubg、info、notice、warning、err、crit、alert、emerg）journalctl --since &quot;2020-02-28 22:53:35&quot; --until &quot;2020-02-28 22:53:40&quot; journalctl常用字段1234567891011常用字段 含义--------------- ------------------------- \\_COMM 命令名称 \\_EXE 进程的可执行文件的路径 \\_PID 进程的PID \\_UID UID \\_SYSTEM_UNIT 启动该进程的systemd单元 journalctl -o verbose journalctl _HOSTNAME=localhostjournalctl _HOSTNAME=localhost _PID=1 永久保存journal服务文件的方式12345678910111213mandbman -k journalman 5 journald.conf ， Storage=[root@clear journal]# ll -d /run/log/journal[root@clear journal]# cp -a /run/log/journal/ /var/log/journal[root@clear journal]# ll -d /var/log/journaldrwxr-sr-x. 4 root systemd-journal 86 Nov 19 04:30 /var/log/journal[root@clear journal]# systemctl restart systemd-journald[root@clear journal]# ll /var/log/journal/3a2b4da8dabb4729935c193e58ad052d/ #字符串目录名字每个人的可能不一样。不要复制我的笔记。total 8192-rw-r-----. 1 root root 8388608 Nov 19 04:30 system.journal[root@clear journal]# journalctl 10.3 保持准确的系统时间1234567891011121314RHEL6 ntp服务RHEL8 chrony服务还是使用同样的协议标准ntp（network time protocol）UTC：通用协调时 （UTC时间0点是北京时间8点,因为中国、新加坡、马来西亚、菲律宾等国的时间与UTC的时差均为+8,也就是UTC+8,所以当UTC时间0点,北京时间即为0+8=8点）GMT：格林威治标准时间CST：中国标准时间 (China Standard Time） （中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为＋8，也就是UTC+8。）RTC：(Real-Time Clock)也称为硬件时间：RTC是芯片内置的硬件时钟，只要芯片不断电，即使操作系统关机的时候，RTC时钟也是正常在走的，所以当操作系统关机重启后，可通过读取RTC时间来更新系统时间。 （可通过hwclock命令来获取具体的时间 -r 查看硬件时间 -s 硬件时间设置到系统 -w 系统设置到硬件 ） timedatectl命令1234567891011121314151617181920212223242526[root@servera log]# timedatectl Local time: Sat 2020-02-29 08:51:49 CST Universal time: Sat 2020-02-29 00:51:49 UTC RTC time: Sat 2020-02-29 08:11:07 Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no [root@servera log]# timedatectl list-timezones [root@servera log]# timedatectl set-timezone Asia/Hong_Kong [root@servera log]# timedatectl Local time: Sat 2020-02-29 08:55:48 HKT Universal time: Sat 2020-02-29 00:55:48 UTC RTC time: Sat 2020-02-29 08:15:06 Time zone: Asia/Hong_Kong (HKT, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no修改时间方法timedatectl set-time &quot;2020-02-30 10:00:00&quot;Failed to set time: NTP unit is activetimedatectl set-ntp false timedatectl set-time &quot;2020-02-30 10:00:00&quot;timedatectl set-ntp true chrony命令server ===server选项格式=== server host [ key n ] [ version n ] [ prefer ] [ mode n ] [ minpoll n ] [ maxpoll n ] [ iburst ] 其中host是上层NTP服务器的IP地址或域名，随后所跟的参数解释如下所示： ◆ key： 表示所有发往服务器的报文包含有秘钥加密的认证信息，n是32位的整数，表示秘钥号。 ◆ version： 表示发往上层服务器的报文使用的版本号，n默认是3，可以是1或者2。 ◆ prefer： 如果有多个server选项，具有该参数的服务器有限使用。 ◆ mode： 指定数据报文mode字段的值。 ◆ minpoll： 指定与查询该服务器的最小时间间隔为2的n次方秒，n默认为6，范围为4-14。 ◆ maxpoll： 指定与查询该服务器的最大时间间隔为2的n次方秒，n默认为10，范围为4-14。 ◆ iburst： 当初始同步请求时，采用突发方式接连发送8个报文，时间间隔为2秒。 1234567891011121314151617181920212223242526272829[root@servera ~]# systemctl enable --now chronyd #--now启动服务 enable 开机自动[root@servera ~]# systemctl status chronyd[root@servera ~]# vim /etc/chrony.conf #大概第7行 server 后面添加服务器'地址'或'域名'。server classroom.exmaple.com iburst[root@servera ~]# systemctl restart chronyd.service[root@servera ~]# chronyc sources -v210 Number of sources = 1 .-- Source mode '^' = server, '=' = peer, '#' = local clock. / .- Source state '*' = current synced, '+' = combined , '-' = not combined,| / '?' = unreachable, 'x' = time may be in error, '~' = time too variable.|| .- xxxx [ yyyy ] +/- zzzz|| Reachability register (octal) -. | xxxx = adjusted offset,|| Log2(Polling interval) --. | | yyyy = measured offset,|| \\ | | zzzz = estimated error.|| | | \\MS Name/IP address Stratum Poll Reach LastRx Last sample ===============================================================================^* classroom.example.com 8 6 377 25 -3837ns[ +21us] +/- 627us[root@node1 ~]# timedatectl Local time: Sat 2022-11-19 05:03:30 EST Universal time: Sat 2022-11-19 10:03:30 UTC RTC time: Sat 2022-11-26 06:07:04 Time zone: America/New_York (EST, -0500)System clock synchronized: yes #表示时间服务同步 NTP service: active RTC in local TZ: no 11 RHEL网络管理11.1 认识IPv4地址1234567891011121314IP/(NETMASK\\|PREFIX) 172.25.0.9/255.255.0.0 \\| 172.25.0.9/16--- ---------------------- --------------------------------------------GATEWAY 172.25.x.xDNS 正向解析 \\# host servera， 反向解析 \\# host私有地址：A １－１２７B １２８－１９１C １９２－２２３IP地址分类默认对应的子网掩码掩码：Ａ：２５５．０．０．０ 11111111.00000000.00000000.00000000 /8Ｂ：２５５．２５５．０．０ 11111111.11111111.00000000.00000000 /16Ｃ：２５５．２５５．２５５．０ 11111111.11111111.11111111.00000000 /24 网段:IP与掩码二进制与运算123网络地址 172.25.0.0 主机位全0---------- ---------------- -----------广播地址 172.25.255.255 主机位全1 查看ip4与ip61234567查看ip地址方法1：[root@servera ~]#ifconfig [root@servera ~]#ifconfig eth0查看ip地址方法2：[root@servera ~]# ip addr show eth0[root@servera ~]# ip a s eth0[root@servera ~]# ip -s link show enp1s0 ipv4 ipv6 mac12345ipv4 ipv6 mac二进制（位） 32 128 48符号（分） . : :进制 十进制 十六进制 十六进制组 4 8 6 端口与服务123456789101112131415查看服务端口是否被占用lsof -i:80或netstat-n：显示接口和端口编号-t：tcp信息-u：udp信息-l：监听状态信息-a：显示所有信息-p：显示协议名称而不是端口netstat -ntlp | grep 22netstat -ntlp | grep 80参考ss和netstat区别：https://blog.csdn.net/qq_37863891/article/details/107283415 标准服务端口1/etc/services 11.2 网络管理工具nmcli概念123456789101112使用nmcli管理网络服务NetworkManagernmcli工具功能：查看网络设备、创建网络连接、修改网络配置特点及概念：nmcli工具可以对网卡或网卡配置文件操作device ---- 网卡设备connection --- 连接 指的就是网卡配置文件一个device可以拥有多个connection，同一时间只能启用一个connection，且一个connection只能属于一个device举例：device-----eth0connection1 ---- dhcp 自动获取IP connection2 ---- static 静态IP 使用nmcli管理网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mandbman -k nmclinmcli (1) nmcli-examples (7)man nmcli | grep -A 2 'nmcli connection add'-basic[root@servera ~]# nmcli connection show [root@servera ~]# nmcli connection show --active [root@servera ~]# nmcli device status -add---添加 dhcp方式: #创建一个名为default的手动链接，绑定至eth0网卡[root@servera ~]# nmcli connection add con-name 'default' type ethernet ifname eth0 autoconnect yes [root@servera ~]# nmcli con show static方式：#创建一个名为static的静态链接，绑定至eth1网卡[root@servera ~]# nmcli connection add con-name static type ethernet ifname eth0 autoconnect yes ipv4.addresses 192.168.0.1/24 ipv4.gateway 192.168.0.254 ipv4.dns 8.8.8.8 ipv4.method manual [root@servera ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 1f5ad5ae-e926-3f54-9805-33174e63af47 ethernet eth0 static 980f6712-86b7-4d92-bc84-62e677ccabfc ethernet eth1 #此处dhcp 82c4a93f-1ca2-432b-94da-59a6c4f5aaca ethernet -- Wired connection 2 e801f880-78a6-3344-857f-588f7495bb26 ethernet -- [root@servera /]# nmcli connection up static 启动static网卡[root@servera /]# ip a s eth1 | grep -w inet-modify---修改#将链接static网络信息更改： IP：192.168.0.2 mask：/24 gw：192.168.0.200 dns：114.114.114.114[root@servera ~]# nmcli connection modify static ipv4.addresses 192.168.0.2/24 ipv4.gateway 192.168.0.200 ipv4.dns 114.114.114.114 autoconnect yes ipv4.method manual[root@servera ~]# nmcli connection up static[root@servera ~]# ip a s eth0 inet 192.168.0.2/24 brd 192.168.0.255 scope global noprefixroute eth1 [root@servera ~]# route -nDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 100 0 0 eth00.0.0.0 192.168.0.200 0.0.0.0 UG 101 0 0 eth1[root@servera ~]# cat /etc/resolv.conf # Generated by NetworkManagersearch lab.example.com example.comnameserver 172.25.250.254nameserver 114.114.114.114 [root@serverb ~]# nmcli connection delete static #删除一个链接Connection 'static' (b85e6a57-b8f7-421f-8d15-9ff5e27cbb85) successfully deleted.-up_down---启动与关闭网卡[root@servera /]# nmcli connection down static 关闭static网卡-off---关闭网络服务[root@servera /]# nmcli networking off 关闭网络服务，慎重使 图形化管理工具nmtui12345nmtui-edit图形化管理配置通过点击设置--network--网卡设置，ipv4address netmask dns gatewaynmtui-edit[root@servera /]# nmcli connection up static 网卡配置文件12345678910111213141516171819202122-RHEL8 版本# grep -r IPADDR /usr/share/ #找到下面手册的指令vim /usr/share/doc/initscripts/sysconfig.txt 帮助手册修改配置文件方式修改IP[root@servera ~]# vim /etc/sysconfig/network-scripts/ifcfg-Wired_connection_1BOOTPROTO=none #获取IP的方式 static--静态 none--不设置 dhcp--自动获取 ，手动配IP选前两个中任意一个ONBOOT=yes #开机自动连接IPADDR=172.25.250.100 #ip地址PREFIX=24 #子网掩码 PREFIX=24(等效于255.255.255.0)，mask=255.255.255.0 netmask=255.255.255.0GATEWAY=172.25.250.254 #网关DNS1=xxxx #dns，dns可以有三个 DNS1= DNS2= DNS3=加载网卡配置文件方法一：[root@serverb network-scripts]# nmcli connection reload ifcfg-Wired_connection_1 或 nmcli connection reload[root@serverb network-scripts]# nmcli connection up staticsystemctl restart NetworkManager-RHEL9版本 网卡配置文件位置[root@node1 system-connections]# vim /etc/NetworkManager/system-connections/System\\ eth0.nmconnection 11.3 更改网络信息主机名12345[root@servera ~]# hostnameservera.lab.example.com[root@servera ~]# hostnmae www.example.com 临时[root@servera ~]# vim /etc/hostname 永久（重启系统:reboot、init 6)[root@servera ~]# hostnamectl set-hostname hostname 永久 配置网关(gateway)12345678一、使用nmclinmcli con add con-name xxx ipv4.gateway xxx.xxx.xxx.xxx 配置网关nmcli con mod xxx ipv4.gateway xxx.xxx.xxx.xxx 修改网关以上两种改完之后，需要nmcli con up xxx二、修改配置文件vim /etc/sysconfig/network-scripts/ifcfg-xxxxGATEWAY=xxx.xxx.xxx.xxx 修改完后要nmcli con reload ，再nmcli con up xxxx 查看路由及网关信息123456789101112131415161718[root@servera ~]# ip route default via 172.25.250.254 dev enp1s0 proto static metric 100 172.25.250.0/24 dev enp1s0 proto kernel scope link src 172.25.250.10 metric 100[root@servera ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 100 0 0 enp1s0172.25.250.0 0.0.0.0 255.255.255.0 U 100 0 0 enp1s0[root@servera ~]# nmcli connection show Wired\\ connection\\ 1 | grep ipv4.gaipv4.gateway: 172.25.250.254[root@servera ~]# netstat -nrKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 0 0 0 enp1s0172.25.250.0 0.0.0.0 255.255.255.0 U 0 0 0 enp1s0 指定DNS12vim /etc/resolv.conf #该文件指定dns和域名的 /etc/sysconfig/network-scripts/ifcfg-xxx中的DNS字段会同步到/etc/resolv.conf，后者优先。nameserver 172.25.250.254 测DNS域名解析是否正常12345678910[root@servera ~]# host classroom.example.com （至少掌握1个）classroom.example.com has address 172.25.254.254[root@servera ~]# nslookup classroom.example.comServer: 172.25.250.254Address: 172.25.250.254#53Name: classroom.example.comAddress: 172.25.254.254[root@servera ~]# dig classroom.example.com 12 归档与系统间复制文件12.1 归档及压缩123456789101112语法：tar 选项 归档文件名 源文件 源文件2 源文件N-c 创建-t 查看-f 指定文件名-v 显示详细信息-x 解包-C 指定解包路径例：man tartar -cvf /root/etc.tar /etc/ 文件及目录打包、解包1234567891011121314151617181920212223242526272829303132333435363738将文件打包归档[root@servera opt]# touch file{1..3}[root@servera opt]#etc.tar file1 file2 file3[root@servera opt]# tar -cvf file.tar file1 file2 file3file1file2file3[root@servera opt]# tar -tf file.tarfile1file2file3[root@servera opt]# lsetc.tar file1 file2 file3 file.tar为文件解包[root@servera opt]# tar -xvf file.tar -C /tmp/file1file2file3[root@servera opt]# ls /tmp/file1 rclocal.logfile2 rht-bastionfile3 rht-defaultNIC1 rht-vm-hostsNIC2 systemd-private-ef2feb022cd2465c9dd920878a1d962b-chronyd.service-kRKFp0[root@servera opt]# 将目录打包归档[root@servera opt]# tar -cvf etc.tar /etc[root@servera opt]# lsetc.tar file1 file2 file3 file.tar[root@servera opt]# cp etc.tar /home[root@servera opt]# cd /home 为目录解包[root@servera opt]# tar -xvf etc.tar 文件压缩1234567891011121314只压缩文件：[root@servera opt]# gzip file1[root@servera opt]# lsetc.tar file1.gz file2 file3 file.tar[root@servera opt]# file file1.gz file1.gz: gzip compressed data, was &quot;file1&quot;, last modified: Sun Mar 1 05:54:06 2020, from Unix, original size 0[root@servera opt]# bzip2 file2[root@servera opt]# lsetc.tar file1.gz file2.bz2 file3 file.tar[root@servera opt]# file file2.bz2 file2.bz2: bzip2 compressed data, block size = 900k[root@servera opt]# xz file.tar [root@servera opt]# lsetc.tar file1.gz file2.bz2 file3 file.tar.xz tar打包并压缩123456789101112131415161718tar的压缩选项man tar | grep gzip-z gzip-j bzip2-J xz打包并压缩 tar -zcvf /root/etc.tar.gz /etc/ 47 cd /root/ 48 ls 49 file etc.tar.gz 50 tar -jcvf /opt.tar.bz2 /opt/ 51 ls / tar -Jcvf /root/etc.tar.gz /etc/解包解压缩并指定路径tar -zxvf etc.tar.g tar -zxvf etc.tar.gz -C /opt/tar xf etc.tar.gz -C /opt/ 12.2 远程传输scp实现远程文件传输1234# scp servra.txt root@bastion:/opt/# ls# scp root@bastion:/opt/bastion.txt .# ls sftp实现远程文件传输1234567891011121314151617181920212223242526272829303132ID app roles---- ------- ----------------1 ftp client2 sftp ssh SubService3 vsftp servicesftp instructor@classroom.example.cominstructor@classroom.example.com's password: Asimovsftp&gt; cd /tmpsftp&gt; lsNIC1 NIC1.old NIC2 NIC2.old sftp&gt; get testfile.txt Fetching /tmp/testfile.txt to testfile.txtsftp&gt; exit[root@servera opt]# [root@servera opt]# lsetc testfile.txt[root@servera opt]# touch put.txt[root@servera opt]# sftp instructor@classroom.example.cominstructor@classroom.example.com's password: Connected to instructor@classroom.example.com.sftp&gt; cd /tmp/sftp&gt; put /opt/put.txt Uploading /opt/put.txt to /tmp/put.txt/opt/put.txt 100% 0 0.0KB/s 00:00 sftp&gt; lsNIC1 NIC1.old NIC2NIC2.oldput.txt rsync实现同步文件内容123456789101112-v 显示详细信息-a 相当于存档模式 本地同步[root@servera tmp]# rsync -av /var/log/* /tmp远程同步[root@servera tmp]# rsync -av /var/log/* serverb:/tmp[root@servera tmp]# ssh root@serverb ls /tmp问题：将serverb上的/var/log/同步到，servera当前目录下[root@servera tmp]# rsync -av serverb:/var/log/ . 13 安装和升级软件包13.1 RPM包管理rpm包语法12345678910111213141516171819软件的获取方式：1、互联网(下载光盘镜像.iso)、直接使用网络yum源2、光盘rpm包语法:rpm 选项 包名选项：-i 安装-v 显示过程-h 以易读方式显示进度条-e 卸载例:rpm -ivh xxx.rpm练习:1. 在f0中进入软件包的存储位置[root@foundation0 /]# cd /content/rhel8.0/x86_64/dvd/AppStream/Packages/[root@foundation0 Packages]# pwd/content/rhel8.0/x86_64/dvd/AppStream/Packages2.安装软件[root@foundation0 Packages]# rpm -ivh lftp-4.8.4-1.el8.x86_64.rpm rpm包查询命令12345678910111213141516171819202122232425262728293031323334353637383940语法:rpm -q 软件包名称选项：-q: query 查询，和其他参数配合-l：list 列出软件包安装后给系统带来的所有文件-a：all 查看所有已安装的软件包-c: configure 查看软件包提供的配置文件练习:【f0】[root@foundation0 dvd]# pwd/content/rhel8.4/x86_64/dvd【servera】[root@servera yum.repos.d]# vim /etc/yum.repos.d/rhel_dvd.repo http://content.example.com/rhel8.4/x86_64/dvd/BaseOS http://content.example.com/rhel8.4/x86_64/dvd/AppStream通过浏览器打开以上地址，可以查询到lftp或telnet相关软件，网页中ctrl+f搜索，输入lftp找到对应的软件，右键copy Link location，再到命令行中粘贴即可rpm -ivh http://foundation0.ilt.example.com/dvd/AppStream/Packages/telnet-0.17-73.el8.x86_64.rpmerpm -q telnetrpm -q sshrpm -q opensshrpm -qarpm -qa | grep telnetrpm -qa | grep sshrpm -ql telnetrpm -qc telnetrpm -qc opensshrpm -qc openssh-serverrpm -qa | grep sshrpm -qc openssh-server-8.0p1-4.el8_1.x86_64vim /etc/ssh/sshd_configrpm -qf /etc/ssh/sshd_configrpm -qi openssh-server-8.0p1-4.el8_1.x86_64卸载RPM包[root@node1 /]# rpm -q telnettelnet-0.17-73.el8.x86_64[root@node1 /]# rpm -e telnet-0.17-73.el8.x86_64[root@node1 /]# rpm -q telnetpackage telnet is not installed 13.2 YUM工具管理yum源文件12345678910111213141516171819202122yum源软件配置方式:[root@servera /]# cd /etc/yum.repos.d/[root@servera yum.repos.d]# mkdir old[root@servera yum.repos.d]# mv * old #将系统默认的yum源文件移动到old中，可以在该文件中查看原来的yum源路径[root@servera yum.repos.d]# man 5 yum.conf[root@servera yum.repos.d]# vim rhel.repo[AppStream] #id名称自定义name=AppStream #描述自定义，和id不必一样baseurl=http://content.example.com/rhel8.4/x86_64/dvd/AppStream #file:///中://是url格式，第三个/是根目录gpgcheck=0 #gpgchek=1 要进行公钥验证，需要再添加选项gpgkey=http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-releaseenabled=1[BaseOS]name=BaseOSbaseurl=http://content.example.com/rhel8.4/x86_64/dvd/BaseOSgpgcheck=0enabled=1[root@servera yum.repos.d]# yum clean all #清除缓存，避免沿用之前缓存的软件[root@servera yum.repos.d]# yum makecache #和当前yum源建立缓存关联[root@servera yum.repos.d]# yum repolist all #查看当前yum源状态[root@servera yum.repos.d]# yum install -y telnet #测试安装软件telnet[root@servera yum.repos.d]# rpm -q telnet #使用rpm方式查询测试 yum源的命令配置方法123456789101112131415161718192021222324252627282930313233343536371 找到提供yum-config-manager命令的软件包名称[foundation0][kiosk@foundation0 ~]$ yum provides yum-config-managerdnf-utils-4.0.2.2-3.el8.noarch #发现提供yum-config-manager命令的包叫dnf-utils(8.0版本里的名字)，如果8.4版本名称为yum-utils2 安装yum-utils软件打开浏览器输入yum源仓库地址，找到yum-utils的软件包，并且通过rpm命令安装网络上的yum-utils软件包，来提通yum-config-manager命令[root@servera ]# rpm -ivh http://content.example.com/rhel8.4/x86_64/dvd/BaseOS/Packages/yum-utils-4.0.18-4.el8.noarch.rpm3 通过yum-config-manager命令部署yum源[root@servera ]# yum-config-manager --help[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/AppStream[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/BaseOS4 命令制作的yum源中没有gpgcheck选项，如何配置？可以通过以下三种方法： 1、此处可以在/etc/yum.repos.d/xx.repo文件里添加 gpgcheck=0 （推荐方案） 2、或者配置/etc/yum.conf,配置gpgcheck=1，改为0 （只在练习考试时使用） 3、或者rpm --import ‘公钥地址’ 导入公钥` （推荐方案）[root@servera yum.repos.d]# rpm --import http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG- KEY-redhat-release 培训环境里/etc/pki/rpm-gpg/保存了公钥[root@servera ]# find / -name *KEY*[root@servera ]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release[root@servera ]# yum clean all[root@servera ]# yum repolist all对称非对称加密公钥（解密） 私钥（加密）红帽发布软件包到互联网开启或关闭[root@servera /]# yum-config-manager --disable rhel-8.0-for-x86_64-appstream-rpms（yum 池ID）[root@servera /]# yum repolist all[root@servera /]# yum-config-manager --enable rhel-8.0-for-x86_64-appstream-rpms[root@servera /]# yum repolist all YUM命令的练习12345678910111213141516171819202122232425yum常见命令yum list httpdyum list http*yum search httpdyum search sshyum info httpd-manual[root@servera /]# yum provides /var/www/htmlyum updateyum install 包名yum remove 包名yum install -y httpd[root@servera /]# yum install -y autofs[root@servera /]# yum remove -y autofs[root@servera /]# yum historyyum clean all 清除缓存yum listyum repolist yum repolist allservera:yum group listyum groupinfo 'Server with GUI'yum groupinstall -y 'Server with GUI'startx 切图形 13.3 第三方YUM源12345678910【基础环境foundation】1.虚拟机联网虚拟机设置里面NAT选择已连接nmcli connection up ens1922.百度搜索（阿里源、华为源...），将.repo文件下载到系统curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo3.验证cd /etc/yum.repos.d/;lsyum repolist allyum install -y vsftpd 14 访问Linux文件系统14.1 存储管理概念文件系统、存储和块设备123456块设备命名-------------------------------- --------------------------------- --/dev/sda、/dev/sdb STAT/SAS（新SCSI技术）/USB 附加存储 /dev/vda、/dev/vdb virtio-blk 超虚拟化存储（部分虚拟机） /dev/nvme0，/dev/nvme1 附加存储 （SSD） /dev/mmcblk0、/dev/mmcblk1 SD卡 磁盘分区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121分区（可选）--格式化--挂载--使用mount命令挂载是临时的，意味着重启系统后将取消挂载。需要手动重新挂载。永久挂载需要将挂载项记入/etc/fstab中（下次基本存储课讲）1 分区，gpt方案 ，分2个区，每个1G[root@servera ~]# fdisk /dev/vdbCommand (m for help): m d delete a partition #删除分区 n add a new partition #创建分区 p print the partition table #打印分区表 w write table to disk and exit #保存并退出 Create a new label g create a new empty GPT partition table #指定分区方案gpt，分区前指定一次即可 o create a new empty DOS partition table #指定分区方位mbrCommand (m for help): g #指定分区方案gptCreated a new GPT disklabel (GUID: D29B3E19-BA51-1042-BFE6-0FD975D1B7DB).Command (m for help): nPartition number (1-128, default 1): #回车First sector (2048-10485726, default 2048): #回车Last sector, +sectors or +size{K,M,G,T,P} (2048-10485726, default 10485726): +1G #指定分区大小1GCreated a new partition 1 of type 'Linux filesystem' and of size 1 GiB.Command (m for help): pDisklabel type: gpt #查看分区方案Device Start End Sectors Size Type #分区表/dev/vdb1 2048 2099199 2097152 1G Linux filesystem #/dev/vdb 分区为1GCommand (m for help): n #创建第二个分区Partition number (2-128, default 2): First sector (2099200-10485726, default 2099200): Last sector, +sectors or +size{K,M,G,T,P} (2099200-10485726, default 10485726): +1GCommand (m for help): pDevice Start End Sectors Size Type/dev/vdb1 2048 2099199 2097152 1G Linux filesystem/dev/vdb2 2099200 4196351 2097152 1G Linux filesystemCommand (m for help): w #保存退出[root@servera ~]# fdisk -l /dev/vdb #查看/dev/vdb分区表Device Start End Sectors Size Type/dev/vdb1 2048 2099199 2097152 1G Linux filesystem/dev/vdb2 2099200 4196351 2097152 1G Linux filesystem[root@servera ~]# lsblk /dev/vdb #lsblk查看块设备NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvdb 252:16 0 5G 0 disk ├─vdb1 252:17 0 1G 0 part └─vdb2 252:18 0 1G 0 part [root@servera ~]# 2 格式化，将两个分区分别格式化为ext4和xfs文件系统语法：mkfs 选项 设备名-t 指定文件系统类型例子：mkfs -t ext4 /dev/vdb1 #方法1mkfs.ext4 /dev/vdb1 #方法2[root@servera /]# mkfs -t ext4 /dev/vdb1 #mkfs格式化 ext4是文件系统类型 /dev/vdb1是要格式化的磁盘分区[root@servera /]# echo $? # $?是看上一条命令返回值，0为正确，非0为错误0[root@servera /]# mkfs.xfs /dev/vdb2[root@servera /]# echo $?0[root@servera ~]# lsblk -f[root@servera ~]# lsblk -f /dev/vdb #查看文件系统类型，NAME FSTYPE LABEL UUID MOUNTPOINTvdb ├─vdb1 ext4 ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs b538bf38-2b33-4d53-a785-372627587c52 3 挂载创建挂载点mkdir /mnt/disk1文件系统：格式化后的设备或分区挂载点：linux中的空目录语法：挂载mount 文件系统 挂载点mount /dev/vdb1 /mnt/disk1卸载umount 文件系统/挂载点umount /dev/vdb1 or umount /mnt/disk1#挂载[root@servera ~]# lsblk -f /dev/vdbNAME FSTYPE LABEL UUID MOUNTPOINTvdb ├─vdb1 ext4 ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs b538bf38-2b33-4d53-a785-372627587c52 [root@servera ~]# mkdir /mnt/{disk1,disk2} # 创建挂载点[root@servera ~]# ls /mntdisk1 disk2[root@servera ~]# mount /dev/vdb1 /mnt/disk1 #将/dev/vdb1 挂载到/mnt/disk1目录上[root@servera ~]# df [root@servera ~]# df -Th #-T 显示文件系统，-h以易读单位显示Filesystem Type Size Used Avail Use% Mounted on/dev/vdb1 ext4 976M 2.6M 907M 1% /mnt/disk1/dev/vdb2 xfs 1014M 40M 975M 4% /mnt/disk2[root@servera ~]# tree /mnt//mnt/├── disk1│ ├── haha.txt│ └── lost+found└── disk2 └── heihei.txt 卸载 [root@servera ~]# cd /mnt/disk2[root@servera disk2]# umount /dev/vdb2 #使用时不能卸载umount: /mnt/disk2: target is busy.[root@servera disk2]# cd / #需要退出挂载点[root@servera /]# umount /dev/vdb2 #卸载[root@servera /]# df -h | tail -2tmpfs 183M 0 183M 0% /run/user/0/dev/vdb1 976M 2.6M 907M 1% /mnt/disk1 检查文件系统12345678910111213141516df 查看系统挂载状态-T 查看文件系统类型-h 以易读方式列出容量单位du 查看文件大小[root@servera /]# du /etc/[root@servera /]# du -h /etc/[root@servera /]# du -sh /etc/24M /etc/[root@servera /]# du /etc/man_db.conf 8 /etc/man_db.conf[root@servera /]# du /etc/man_db.conf -h #占用了的块大小，linux默认一个块4k8.0K /etc/man_db.conf[root@servera /]# ll /etc/man_db.conf -rw-r--r--. 1 root root 5165 Nov 7 2018 /etc/man_db.conf 14.2 文件查找-locate和findlocate12345locateupdatedb #收集所有文件元数据locate passwdlocate -i imagelocate -n 5 image #显示前5行 find12345678910111213141516语法：find 查找范围 查找条件 动作(可选)例：find / -name passwd选项：-name： 以文件名的形式查找-size： 根据文件大小 -size 1k ：大小为1k的文件，+1k大于1k的文件，-1k小于1k的文件-user / -uid： 文件所有者 -user studnet ：student是用户名，查找student拥有的文件-group / -gid-perm： 权限查找 -perm 700 ：搜索权限为700的文件-type： 按文件类型 -type f ： f表示文件，d表示目录动作：-exec： 选项后接Linux指令，操作查找到的文件 command {} ; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152find / -name sshd_configfind /etc -name sshd_configfind /etc -name '*pass*'find / -iname '*pass*' -iname 不区分大小写find / -user studentfind / -group studentfind /home -uid 1000find /home/ -gid 1000find / -user student | xargs ls -lfind / -perm 700 | xargs ls -lll -d /usr/share/selinux/targeted/default/active/modules/disabledfind / -perm 700 -type fll /boot/efi/EFI/redhat/shimx64.efifind / -perm 700 -type d -user studentfind / -perm 700 -type d -user student | xargs ls -ldfind / -type f -size +10kcd /homefind /home/ -perm 700find /etc/ -size 10Mfind /etc/ -size +10Mfind /etc/ -size -10M查找一个‘文件’，大于3k小于10kfind /etc -type f -size +3k -and -size -10kll -acd /etc/ll -hfind ./ -size +1k 如果是小于1k 用-1kdu -sh man_db.conf find /etc -size +1k -and -size -10k &gt; /root/test2.txtfind / -size +1k -and -size -100k -type f | xargs du -shfind / -perm -g=s | xargs ls -ld find / -perm -4000 | xargs ls -ldSUID 4 SGID 2SBIT 1chmod 2700 dirrwxr-sr-- 2754将系统中student用户的文件复制到/root/studentdir目录中，并且保留权限[root@servera ~]# find / -user student -exec cp -a {} /root/studentdir/ \\;将系统中student用户的文件列表保存到/root/studentdir文件中find / -user student &gt; /root/studentdir 14.3 ln 软链接与硬链接123456789软链接：使用范围广，方便访问源文件硬链接：节省系统空间文件链接创建方式：软链接（符号链接）ln -s 源文件 链接文件硬链接：ln 源文件 链接文件 软链接123456ln -s 源文件 链接文件cd /opttouch file1mkdir dirln -s file1 linkfile1ln -s dir1 linkdir1 硬链接1234567891011cd /[root@servera opt]# echo 123 &gt; /opt/sou_file.txt[root@servera opt]# cat /opt/sou_file.txt ln /opt/sou_file.txt /opt/link_file.txt取消链接[root@servera opt]# unlink /opt/link_file.txt[root@servera opt]# lssou_file.txt 软链接和硬链接区别12345678910111.命令相同 参数不同2.硬链接的权限和源文件完全一致 软链接的链接文件权限永远是777 和源文件权限不同3.硬链接可以删除，移动源文件软链接不可以删除，移动源文件4.软链接inode和源文件不同硬链接的inode的源文件相同5.软链接可以对目录及文件生效硬链接只可以对文件操作6.软链接可以跨文件系统硬链接不可以跨文件系统 15 分析服务器获取支持15.1 cockpit123456789101112131415161718192021222324252627282930313233343536[root@servera /]# yum install -y cockpit[root@servera /]# systemctl start cockpit[root@servera /]# systemctl status cockpit添加开机自启动方式：vim /usr/lib/systemd/system/cockpit.service[Install]WantedBy=multi-user.targetsystemctl enable cockpit[root@serveraaa /]# firewall-cmd --permanent --add-service=cockpitsuccess[root@serveraaa /]# firewall-cmd --reloadsuccess[root@serveraaa /]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: enp1s0 sources: services: cockpit dhcpv6-client ssh ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: netstat -ntlp | grep 9090连接cockpitfoundation 连接servera浏览器 http：//172.25.250.10:9090添加信任输入用户名密码 root redhat","link":"/2025/04/15/Linux%E5%9F%BA%E7%A1%80/"},{"title":"podman容器","text":"1 容器概念 容器技术介绍​ 软件应用通常依赖于运行时环境(runtimeenvironment)提供的系统库、配置文件或服务。传统上，软件应用的运行时环境安装在物理主机或虚拟机上运行的操作系统中。然后，管理员在操作系统上安装应用依赖项 ​ 在红帽企业Linux中，诸如RPM等打包系统可协助管理员管理应用依赖项。安装httpd软件包时，RPM系统会确保同时安装该软件包的正确库和其他依赖项 ​ 传统方式部署软件应用的主要弊端是这些依赖项会受到运行时环境的束缚，应用需要的支持软件的版本可能比操作系统提供的软件更旧或更新。同一系统上的两个应用可能需要同一软件互不兼容的不同版本 ​ 解决这些冲突的方式之一是将应用打包并作为容器进行部署​ 容器是由一个或多个与系统其余部分隔离的进程组成的集合，软件容器是打包应用以简化其部署和管理的一种方式​ 以实体集装箱为例。集装箱是打包和装运货物的标准方式。它作为一个箱子进行标记、装载、卸载，以及从一个位置运输到另一个位置。集装箱中的内容与其他集装箱的内容隔离，因此互不影响。这些基本原则也适用于软件容器 容器的核心技术 红帽企业Linux通过运用以下核心技术来支持容器: 1.用于资源管理的控制组(cgroups) 2.用于进程隔离的命名空间 3.加强安全边界的SELinux和Seccomp安全计算模式 容器和虚拟机的差异1.容器提供许多与虚拟机相同的益处，如安全、存储和网络隔离等2.这两种技术都将其应用库和运行时资源与主机操作系统或虚拟机监控程序隔离开，反之亦 3.容器和虚拟机以不同的方式与硬件和底层操作系统交互 ** 4.虚拟机具有以下特征: ** 使多个操作系统能够同时在一个硬件平台上运行 ** 使用虚拟机监控程序将硬件分为多个虚拟硬件系统 ** 需要一个完整的操作系统环境来支持该应用 ** 5.容器具有以下特征: ** 直接在操作系统上运行，从而跨系统上的所有容器共享资源 ** 共享主机的内核，但它将应用进程与系统其余部分隔离开来 ** 与虚拟机相比，它需要的硬件资源要少得多，因此容器的启动速度也更快 ** 包括所有依赖项，如系统和编程依赖项，以及配置设置 Rootless和Rootful容器在容器主机上，由特权用户运行的容器称为Rootful容器、由非特权用户运行的容器称为Rootless容器 **Rootless容器不允许使用通常为特权用户保留的系统资源，例如访问受限目录，或在受限端口(1024以下的端口)上发布网络服务。此功能可防止潜在攻击者获取容器主机上的root特权 **如有必要，可使用root用户身份直接运行容器，但如果有漏洞允许攻击者破坏容器，这样做会削弱系统的安全性 设计基于容器的架构 容器是重复利用托管应用并使其可以移植的有效方式 **容器可以轻松地从一个环境迁移到另一个环境，如从开发环境迁移到生产环境 ** 可以保存一个容器的多个版本，并根据需要快速访问每个版本 **容器通常是临时的，可以将运行中容器所生成的数据永久保存到持久存储中，但容器本身通常会在需要时运行，然后停止并被删除，下次需要该特定容器时，将启动新的容器进程 **可以在单个容器中安装含有多个服务的复杂软件应用。例如，Web服务器可能需要使用数据库和消息传递系统。不过，将一个容器用于多个服务会难以管理 **更好的设计是在单独的容器中运行每个组件、Web服务器、数据库和消息传递系统。这样，更新和维护单个应用组件不会影响其他组件或应用堆栈 容器镜像和注册表 运行容器必须使用容器镜像: **容器镜像是包含编码步骤的静态文件，它充当创建容器的蓝图。容器镜像打包应用及其所有依赖项，如系统库、编程语言运行时和库以及其他配置设置** **容器镜像根据规范构建，如开放容器项目(OCI)镜像格式规范。这些规范定义容器镜像的格式，以及镜像支持的容器主机操作系统和硬件架构的元数据 **容器注册表是用于存储和检索容器镜像的存储库。开发人员将容器镜像推送或上传到容器注册表中。可以从注册表中将这些容器镜像拉取或下载到本地系统，以用于运行容器 ** 可使用包含第三方镜像的公共注册表，也可使用贵组织控制的私有注册表 容器镜像来源很重要。和任何其他软件包一样，必须知道是否可以信任容器镜像中的代码。对于是否及如何提供、评估和测试提交给它们的容器镜像，不同的注册表具有不同的策略 **红帽通过两个主容器注册表分发认证容器镜像，可以使用红帽登录凭据来访问这两个注册表: ** 1.utility.redhat.io: 适用于基于官方红帽产品的容器 ** 2.utilityconnect.redhat,com:适用于基于第三方产品的容器 **3.红帽容器目录(https://access.redhat.com/containers)提供了一个基于Web的界面，通过它可以搜索这些注册表中的认证内容。 **4.培训环境中添加了红帽Quay,官方为收费版，培训环境中为免费版utility.lab.example.com 1234567891011121314151617181920# 环境中使用的镜像仓库浏览器访问为:https://utility 账号是:admin 密码:redhat321# 镜像对应的地址为:utility.lab.example.com[kiosk@foundation0 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6### rht-vm-hosts file listing the entries to be appended to /etc/hosts172.25.250.254 bastion.lab.example.com bastion172.25.250.10 servera.lab.example.com servera172.25.250.11 serverb.lab.example.com serverb172.25.250.220 utility.lab.example.com utility172.25.250.9 workstation.lab.example.com workstation# 登录servera请使用ssh方式，不要使用su切换。# 安装容器:[root@foundation0 ~]# ssh root@servera[root@servera ~]# ssh student@localhost[student@servera ~]$ sudo dnf -y install container-tools # 安装podman容器 [student@servera ~]$ podman --version 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 登录容器:# 需要红帽开发人员账户才能从红帽注册表下载镜像。可以使用podman login命令对注册表进行身份验证。如果不向podman login命令提供注册表URL，它会向默认配置的注册表进行身份验证$ podman login --help# 登录方法一(交互)：$ podman login utility.lab.example.com Username: adminPassword: redhat321Login Succeeded!# 登录方法二(非交互)： # 推荐$ podman login utility.lab.example.com -u admin -p redhat321 # 生产环境中是有https验证的Login Succeeded![student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comError: authenticating creds for &quot;utility.lab.example.com&quot;: pinging container registry utility.lab.example.com: Get &quot;https://utility.lab.example.com/v2/&quot;: tls: failed to verify certificate: x509: certificate is not valid for any names, but wanted to match utility.lab.example.com# 如果出现以上报错，是要求https验证，需要通过选项--tls-verify进行手动关闭# podman login utility.lab.example.com -u admin -p redhat321 --tls-verify=false[student@servera ~]$ podman login --helpDescription: Log in to a container registry on a specified server.Usage: podman login [options] [REGISTRY]Examples: podman login quay.io podman login --username ... --password ... quay.io podman login --authfile dir/auth.json quay.ioOptions: --authfile string path of the authentication file. Use REGISTRY_AUTH_FILE environment variable to override --cert-dir string use certificates at the specified path to access the registry --get-login Return the current login user for the registry -p, --password string Password for registry --password-stdin Take the password from stdin --tls-verify Require HTTPS and verify certificates when contacting registries -u, --username string Username for registry -v, --verbose Write more detailed information to stdout[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.com --tls-verify=falseLogin Succeeded!# 登录方法三(非交互):# 使用podman login命令的--username和--password-sdtin选项，指定用于登录注册表的用户和密码# --password-stdin选项从stdin读取密码# 红帽建议不要使用--password选项直接提供密码，因为此选项会将密码存储在日志文件中$ echo redhat321 | podman login -u admin --password-stdin utility.lab.example.com Login Succeeded! 要验证您是否已登录到某一注册表，请使用 podman login命令–get-login选项。及退出登录podman logout 12345678$ podman login --get-login # 查看登录的用户admin[student@servera ~]$ podman login utility.lab.example.com --get-login # 指定仓库地址，查看登录用户admin[student@servera ~]$ podman logout utility.lab.example.com # 登出Removed login credentials for utility.lab.example.com 配置容器注册表容器注册表的默认配置文件是 /etc/containers/registries.conf 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[student@servera ~]$ sudo vim /etc/containers/registries.conf[sudo] password for student: student#第22行 指定可搜索的镜像仓库地址，如果使用完全合格域名，此处可以留空unqualified-search-registries = [&quot;utility.lab.example.com&quot;,&quot;registry.access.redhat.com&quot;,&quot;registry.redhat.io&quot;,&quot;docker.io&quot;]#第24行[[utility]] 解除注释开启以下功能#第37行insecure = true #false/true 开启https安全验证/关闭安全验证#第40行blocked = false #需要过滤掉的镜像仓库地址#第56行location = &quot;utility.lab.example.com&quot; 指定容器注册表位置$注意~/.config/containers/registries.conf目录设置会覆盖/etc/containers/registries.conf推荐：【student】$ mkdir -p ~/.config/containers$ cp /etc/containers/registries.conf ~/.config/containers/registries.conf$ vim ~/.config/containers/registries.confunqualified-search-registries = [&quot;utility.lab.example.com&quot;] [[utility]] insecure = true blocked = false location = &quot;utility.lab.example.com&quot; # 登录容器注册表[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded!# 根据仓库地址搜索镜像[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 注意：如果只访问本地仓库，unqualified-search-registries = [&quot;utility.lab.example.com&quot;]默认即可，但要需要访问外网，需要用root用户修改vim /etc/resolv.conf文件内容添加nameserver 8.8.8.8 优先解析。阿里容器i2kldsde.mirror.aliyuncs.com 使用容器文件构建容器镜像 容器文件是一种文本文件，内含用于构建容器镜像的指令。 **容器文件通常具有定义其文件和目录所在路径或URL的上下文。生成的容器镜像由只读层组成，每一层代表容器文件中的一条指令。** **以下输出是一个容器文件示例，它使用utility.access.redhat.com注册表中的UBI镜像,安装python3 软件包，并将 hello 字符串打印到控制台。** 1234$ cat ContainerfileFROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python3CMD[&quot;/bin/bash&quot;，&quot;-c&quot;，&quot;echo hello&quot;] 创建容器文件及其使用说明超出了本课程的范畴。有关容器文件的更多信息，请参阅DO180课程。 规模化容器管理 新应用越来越多地使用容器来实施功能组件。这些容器提供应用的其他部分使用的服务。组织管理越来越多的容器，可能很快就会不堪重负。 在生产中大规模部署容器需要一个能够应对以下挑战的环境: 平台必须确保提供必要服务的容器的可用性。 环境必须通过增加或减少运行中的容器实例，并对流量进行负载平衡，从而应对应用的使用高峰。 平台必须检测容器或主机的故障，并相应地作出反应。 开发人员可能需要自动工作流，以便透明、安全地向客户交付新的应用版本。 Kubernetes是一项编排服务，可以使在容器主机集群中部署、管理和扩展基于容器的应用变得更加轻而易举。Kubernetes通过负载平衡器将流量重定向到容器，以便您可以扩展提供服务的容器数量。Kubernetes还支持用户定义的健康检查，以便监控您的容器，并在容器出现故障时将其重新启动。 红帽提供了一个名为红帽OpenShift 的kubernetes发行版。红帽OpenShift是基于Kubernetes基础架构构建的一组模块化组件和服务。它为开发人员提供的额外功能包括基于Web的远程管理、多租户、监控与审计、高级安全功能、应用生命周期管理和自助服务实例等。 红帽OpenShift不在本课程讨论范围之内，但您可以通过https://www.openshift.com了解更多相关信息。 34.2 部署容器Podman实用程序 **Podman是来自container-tools元数据包的全功能容器引警，用于管理开放容器计划(0C)容器和镜像 **podman实用程序的运作不使用守护进程，因此开发人员无需系统上的特权用户帐户来启动或停止容器 **Podman提供多个子命令来与容器和镜像交互。以下列表显示了本节中使用的子命令: ** Podman的命令: 命令 描述 podman build 使用容器文件构建容器镜像 podman run 在新容器中运行命令 podman images 列出本地存储中的镜像 podman ps 打印有关容器的信息 podman inspect 显示容器、镜像、卷、网络或容器集的配置 podman pull 从注册表下载镜像 podman cp 在容器和本地文件系统之间复制文件或目录 podman exec 在运行中的容器内执行命令 podman rm 删除一个或多个容器 podman rmi 删除一个或多个本地存储的镜像 podman search 在注册表中搜索镜像 有关各个子命令使用帮助手册的更多信息，请将子命令附加到podman命令，并用连字符将两者分隔。例如，podman-build帮助手册介绍了podmanbuild子命令的用法。 ** 为阐述本课中的主题，请想象以下情景:** ** 作为系统管理员，您被委任了一项任务，使用python-38软件包运行基于名为python38的RHEL8UBI容器镜像的容器。您还有一项任务，从容器文件创建容器镜像，并从该容器镜像运行名为python36的容器。使用容器文件创建的容器镜像必须具有python36:1.0标签。识别两个容器之间的差异。另外，请确保容器中安装的python软件包与本地计算机中安装的Python版本不相冲突。** 安装容器实用工具 container-tools 软件包包含与容器和容器镜像交互所需的实用程序 ** 若要在系统上下载、运行和比较容器，请使用dnfinstall命令来安装container-tools 元软件包** ** 使用dnf info命令查看 container-tools 软件包的版本和内容** 123[student@servera ~]$ sudo dnf -y install container-tools # 安装podman容器 [student@servera ~]$ podman --version[student@servera ~]$ dnf info container-tools container-tools元数据包提供所需的podman和skope实用程序，用于完成分配的任务 从注册表下载容器镜像文件 1.确保podman实用程序已配置为从utility.lab.example.com注册表搜索和下载容器 ** 2.podmaninfo命令显示podman实用程序的配置信息，包括其配置的注册表** 1[student@servera ~]$ podman info podmansearch命令使用registries.conf文件中指定的注册表列表搜索匹配的名称镜像。默认情况下，Podman在所有非限定搜索注册表中执行搜索 让servera联网方法 1231、f0宿主机上ens192是第二块网卡，vmware上选择nat模式-选择‘已连接’，再获取IP，保证可以上网2、在f0宿主机上执行ssh root@172.25.254.254 rht-config-nat3、servera上ping www.baidu.com测试 使用podmansearch命令，显示包含python-38软件包的已配置注册表的镜像列表 1234567891011121314151617181920212223242526272829# 在注册表中搜索镜像[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 # 从注册表中下载镜像[student@servera ~]$ podman pull utility.lab.example.com/ubi7/ubi[student@servera ~]$ podman pull utility.lab.example.com/rhel8/mariadb-103# 列出本地存储中的镜像[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB# 镜像信息注解:REPOSITORY :仓库地址TAG ：标记，latest最近版本IMAGE ID ：镜像ID，ID号唯一，保证镜像唯一性CREATED ：创建时间；SIZE ：镜像大小 12345678910111213141516171819202122232425262728293031323334353637383940练习：以普通用户身份远程登录系统ssh student@localhost 1.登录容器镜像仓库服务器utility.lab.example.com$ sudo vim /etc/containers/registries.conf $ podman login -u admin -p redhat321 utility.lab.example.com 2.搜索镜像服务器仓库utility.lab.example.com所有镜像$ podman search utility.lab.example.com/3.下载rhel7、8、9的ubi系统到本地$ podman pull utility.lab.example.com/ubi7/ubi$ podman pull utility.lab.example.com/ubi8/ubi$ podman pull utility.lab.example.com/ubi9/ubi4.查看本地镜像$ podman images5.通过rhel7的ubi运行一个交互式容器,然后退出$ podman run -ti utility.lab.example.com/ubi7/ubi$ exit #或者按ctrl+d6.通过rhel8的ubi运行一个长期挂载到后台的容器$ podman run -di utility.lab.example.com/ubi8/ubi7.通过rhel9的ubi运行一个长期挂载到后台的容器，并且指定容器名称为rhel9[student@servera ~]$ podman run -di --name rhel9 utility.lab.example.com/ubi9/ubib4b889bb5964acae14a6e7c2d138e8cc56e9ebf94edf9653f5341522ffc9ec768.进入rhel9容器进行交互[student@servera ~]$ podman exec -ti rhel9 /bin/bash[root@b4b889bb5964 /]# cat /etc/redhat-releaseRed Hat Enterprise Linux release 9.3 (Plow)9.使用httpd-24镜像运行一个web服务。并且访问测试#本地测试，如果在其他主机上访问servera容器web服务，需要在servera防火墙允许主机端口809010.使用nginx镜像运行一个web服务。并且访问测试，nginx容器内端口为8011.尝试运行一个mariadb-105的容器 从容器文件创建容器镜像 ** 您获得了以下容器文件，用于在 python36-app目录中创建容器镜像** 12345$ cat Containerfile FROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python36CMD[&quot;/bin/bash&quot;，&quot;-c&quot;，&quot;sleep infinity&quot;]# 此容器文件是教材中例子默认报错，可以使用下面的容器文件 12345[student@servera ~]$ vim ContainerfileFROM utility.lab.example.com/ubi9/ubi:latestRUN echo -e '[rhel-9.3-for-x86_64-baseos-rpms]\\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/BaseOS\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.3 BaseOS (dvd)\\n[rhel-9.3-for-x86_64-appstream-rpms]\\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/AppStream\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.3 Appstream (dvd)'&gt;/etc/yum.repos.d/rhel_dvd.repoRUN yum install --disablerepo=* --enablerepo=rhel-9.3-for-x86_64-baseos-rpms --enablerepo=rhel-9.3-for-x86_64-appstream-rpms -y python3CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;sleep infinity&quot;] 以上容器文件使用utility.lab.example.com/ubi9/ubi:latest镜像作为基础镜像。容器文件而后将安装python36软件包，并运行sleep infinity bash命令来防止容器退出 通常，容器运行一个进程，然后在该进程完成后退出。sleepnfinity命令可防止容器退出因为该进程永远不会完成。然后可以在容器内进行测试、开发和调试 在检查容器文件后，可以使用podman build命令来构建镜像。podmanbuild命令的语法如下所示: 1234567891011121314$ podman build -t NAME:TAG DIR[student@servera ~]$ podman build -t rhel7:2.0 .[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZElocalhost/rhel7 2.0 98d0b6385a00 40 seconds ago 238 MButility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB# 以上输出的最后一行显示了容器镜像ID。大多数Podman命令使用容器镜像ID的前12个字符来指代容器镜像，可以将此短ID或者容器或容器镜像的名称，作为大多数Podman命令的参数# 注解:-t,--tag name 生成镜像的名称NAME:新镜像的名称标签:新镜像的标签。如果未指定标签，则镜像自动标记为latestDIR:工作目录路径。容器文件必须位于工作目录中。如果工作目录是当前目录，则可以用点(.)来指定它。使用-f标志指定与当前目录不同的目录 使用podmaninspect命令来查看容器镜像的低级别信息，并验证其内容是否符合容器要求: 12(podman pull 先下载后再使用inspect)[student@servera ~]$ podman inspect localhost/rhel7:2.0 ** podmaninspect命令的输出显示reqistry.access.redhat.com/ubi8/ubi:latest基础镜像、用于安装python36 软件包的 dnf命令，以及在运行时执行以防止容器退出的sleepinfinity bash命令** 运行容器 现在，您已拥有所需的容器镜像，可以使用它们来运行容器。容器可以处于以下状态之一!Created 已创建好但尚未启动的容器。 运行中 与其进程一起运行的容器。已停止 其进程已停止的容器。 Paused 其进程已暂停的容器。不支持 Rootless容器。 Deleted 其进程处于已死状态的容器。 **podman ps命令列出系统上正在运行的容器。使用podman ps-a来命令查看计算机中的所有容器 (已创建、已停止、已暂停或正在运行)。 ** ** 可使用podmancreate命令来创建容器，以便稍后运行。若要创建容器，请使用容器localhost/rhel7:2.0镜像的ID。也可以使用–name选项设置名称来标识容器。此命令的输出是容器的长ID,如果不指定–name选项，会自动生成一个容器名称。** 1$ podman create --name python36 dd6ca291f097 然后，可使用podman ps和podman ps-a命令来验证容器是否已创建但尚未启动。您可以查看有关 python36容器的信息，如容器的短ID、名称和状态，容器在启动时运行的命令，以及用于创建容器的镜像 12$ podman ps $ podman ps -a 现在已验证容器已正确创建，决定启动容器，所以要运行 podmanstart命令。可以使用名称或容器ID来启动容器。此命令的输出是容器的名称。 12$ podman start python36$ podman ps 从远程存储库运行容器 您可使用podman run命令，在一个步骤中创建并运行容器。podman run命令在容器内运行进程，此进程将启动新容器。 您可以使用podman run命令-d选项以分离模式运行容器，这将在后台运行容器，而不是在会话的前台运行 在python36容器的示例中，您不需要提供容器运行所提的命令，原因是为该容器创建镜像的容器文件中已提供了sleepinfinity 命令 1234567891011121314151617181920212223242526272829podman run -t 终端-i 交互-d 放在后台--name 指定容器的名称，如果不指定，会自从产生名称[student@servera ~]$ podman run -it utility.lab.example.com/ubi7/ubi[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES537b1f1fbb6d utility.lab.example.com/ubi7/ubi:latest /bin/bash About a minute ago Up About a minute objective_antonelli#实验前可以提前下载镜像至本地 #podman search utility.lab.example.com/#podman pull utility.lab.example.com/ubi8/ubi#podman images[student@servera ~]$ podman run -it --name rhel9 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman run -di --name rhel9-1 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES537b1f1fbb6d utility.lab.example.com/ubi7/ubi:latest /bin/bash 5 minutes ago Up 5 minutes objective_antonellifb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 56 seconds ago Up 57 seconds rhel9-1# ctrl+d退出后再查看容器的状态[student@servera ~]$ podman exec -ti rhel9-1 /bin/bash[student@servera ~]$ podman run -d --name rhel9-2 utility.lab.example.com/ubi9/ubi sleep infinity[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 5 minutes ago Up 5 minutes rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 34 seconds ago Up 34 seconds rhel9-2 容器中的环境隔离 容器隔离应用的环境 **每个容器都有自己的文件系统、网络和进程。查看ps命令的输出，并在主机和运行中容器之间进行比较，就会注意到隔离功能** ** 在本地计算机上运行ps-ax命令，该命令将返回具有许多进程的预期结果** 123456789101112131415[student@servera ~]$ ps -ax[student@servera ~]$ podman run -di --name python36-db utility.lab.example.com/rhel8/mariadb-103f4c3d26df7bd3614e6b4954ae6ed485046128afc89a95cba20c834b2ba0327ff[student@servera ~]$ podman run -di --name python38 utility.lab.example.com/ubi9/ubi8e7870d50daa32c768c4301911364285a659a5383b4cdadc96b8d3b7ff411c2d[student@servera ~]$ podman run -id --name rhel7 utility.lab.example.com/ubi7/ubi2d4b030f4141656f8b4b74d419c2b8de52669927a261953c92409bc995b35922[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 9 hours ago Exited (0) 9 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 9 hours ago Up 9 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 9 hours ago Up 9 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 22 minutes ago Exited (1) 22 minutes ago python36-db8e7870d50daa utility.lab.example.com/ubi9/ubi:latest /bin/bash 16 minutes ago Up 16 minutes python382d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 12 seconds ago Up 13 seconds rhel7 podman exec命令可在运行中的容器内执行命令 **该命令取容器的名称或ID作为第一个参数，并将下列参数作为要在容器内运行的命令** ** 使用podman exec命令查看rhel7容器中正在运行的进程。psaux命令的输出看起来有所不同，因为它运行与本地计算机不同的进程** ** 使用sh -c命令来封装要在容器中执行的命令** ** ps ax &gt;/tmp/process-data.log命令被解释为要在容器中执行的命令。如果不封装命令，则Podman可能会将大于号字符(&gt;)解释为podman命令的一部分，而不是podmanexec选项的参数** 1234567891011121314151617#使用练习环境中的utility.lab.example.com/ubi7/ubi镜像，执行一些其他命令，比如ls /等[student@servera ~]$ podman exec rhel7 ps -ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 /bin/bash 2 ? R 0:00 ps -ax[student@servera ~]$ podman exec rhel7 sh -c 'ps -a &gt; /tmp/process_data.log'[student@servera ~]$ podman exec rhel7 sh -c 'echo China &gt; /test.txt'[student@servera ~]$ podman exec -ti rhel7 /bin/bash[root@2d4b030f4141 /]# ls /bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys test.txt tmp usr var[root@2d4b030f4141 /]# cat test.txtChina[root@2d4b030f4141 /]# cat /tmp/process_data.log PID TTY TIME CMD[root@2d4b030f4141 /]# exitexit[student@servera ~]$ ** 将主机系统上安装的python版本与容器上安装的python版本进行比较:** 123456[student@servera ~]$ podman exec rhel9-1 python3 --versionPython 3.9.18[student@servera ~]$ python3 --versionPython 3.9.18[student@servera ~]$ podman exec python38 python3 --versionPython 3.9.18 容器中的文件系统隔离 开发人员可以使用文件系统隔离功能，为不同版本的编程语言编写和测试应用，无需使用多个物理机或虚拟机。 您将在终端上的/tmp目录中创建一个显示hello world的简单bash 脚本。 12345678[student@servera ~]$ echo &quot;echo Hello China!&quot; &gt; /tmp/hello.sh[student@servera tmp]$ cd /tmp;lltotal 8-rw-r--r--. 1 student student 18 Mar 3 21:24 hello.sh-rw-r--r--. 1 student student 30 Mar 3 21:01 process_data.logdrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-chronyd.service-c0Zzhidrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-dbus-broker.service-QaiP7Ndrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-systemd-logind.service-iM6Zeq /tmp/hello.sh文件位于主机计算机上，而不存在于容器内的文件系统上。如果尝试使用podmanexec来执行脚本，则会出现错误，因为容器中不存在/tmp/hello.sh脚本 123456789101112[student@servera tmp]$ stat /tmp/hello.sh File: /tmp/hello.sh Size: 18 Blocks: 8 IO Block: 4096 regular fileDevice: fc04h/64516d Inode: 18159864 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/ student) Gid: ( 1000/ student)Context: unconfined_u:object_r:user_tmp_t:s0Access: 2025-03-03 21:24:33.865950531 -0500Modify: 2025-03-03 21:24:33.865950531 -0500Change: 2025-03-03 21:24:33.865950531 -0500 Birth: 2025-03-03 21:24:33.865950531 -0500[student@servera tmp]$ podman exec rhel7 stat /tmp/hello.shstat: cannot stat '/tmp/hello.sh': No such file or directory podman cp命令在主机和容器文件系统之间复制文件和文件夹。您可以使用podman cp 命令将/tmp/hello.sh文件复制到python38容器: 12345678910[student@servera ~]$ podman cp /tmp/hello.sh rhel7:/tmp/hello.sh[student@servera ~]$ podman exec rhel7 stat /tmp/hello.sh File: '/tmp/hello.sh' Size: 18 Blocks: 8 IO Block: 4096 regular fileDevice: 58h/88d Inode: 10261231 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2025-03-04 02:24:34.000000000 +0000Modify: 2025-03-04 02:24:34.000000000 +0000Change: 2025-03-04 02:28:24.720471184 +0000 Birth: - 脚本复制到容器文件系统后，即可从容器内执行: 12[student@servera ~]$ podman exec rhel7 bash /tmp/hello.shHello China! 删除容器和镜像 ** 使用podman rm和podman rmi命令删除容器和镜像** ** 删除容器镜像之前，必须先从该镜像移除任何现有的运行中容器** ** 删除python38容器及其相关镜像:** 12345678910[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Exited (0) 10 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Up 10 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 10 hours ago Up 10 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld About an hour ago Exited (1) About an hour ago python36-db8e7870d50daa utility.lab.example.com/ubi9/ubi:latest /bin/bash 55 minutes ago Up 55 minutes python382d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 39 minutes ago Up 39 minutes rhel7student@servera ~]$ podman rmi utility.lab.example.com/ubi9/ubi:latestError: image used by 8e7870d50daa32c768c4301911364285a659a5383b4cdadc96b8d3b7ff411c2d: image is in use by a container: consider listing external containers and force-removing image 必须先停止容器，然后才能删除它。若要停止容器，请使用podmanstop命令 12[student@servera ~]$ podman stop python38python38 停止容器后，使用 podman rm 命令来删除容器 12345678910[student@servera ~]$ podman rm --help[student@servera ~]$ podman rm python38python38[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Exited (0) 10 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Up 10 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 10 hours ago Up 10 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld About an hour ago Exited (1) About an hour ago python36-db2d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 45 minutes ago Up 45 minutes rhel7 ** 当容器不再存在时，可以使用podman rmi命令删除对应的镜像:** 12345678910111213[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZElocalhost/rhel7 2.0 98d0b6385a00 11 hours ago 238 MButility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman rmi 8d2a8803cfcaError: image used by c4f7f4d727471d590f6241cccf0be0b1ef2256cc43a710594642611fe6d0be47: image is in use by a container: consider listing external containers and force-removing image[student@servera ~]$ podman rmi 98d0b6385a00Untagged: localhost/rhel7:2.0Deleted: 98d0b6385a005e09cfcee59a393cfce2fc46b56f09af6c4f87bd874f00966ed2Deleted: 53c739e51f226903b6568038c9cf563de2007f756e0a0e86e5c00604cf474f3dDeleted: 92b83aa1157f23b209f53480c6bbdf780c39490b37337bc4f4fcb1061b7c978 34.3 管理容器存储和网络资源管理容器资源 可以使用容器来运行简单的进程，然后退出。 还可以配置容器以连续运行某一服务，如数据库服务器。如果您持续运行服务，您最终可能需要向容器添加更多资源，如持久存储或对其他网络的访问权限。 可以使用不同的策略为容器配置持久存储: ** 1.对于红帽OpenShift等企业容器平台上的大型部署，您可以使用复杂的存储解决方案为容器提供存储，而无需了解底层基础架构** **2.对于单个容器主机上且无需扩展的小型部署，您可以通过在运行中的容器上创建要挂载的目录，从容器主机创建持久存储** 当Web服务器或数据库服务器等容器为容器主机外部的客户端提供内容时，必须为这些客户端设置通信通道，以访问容器的内容。 可以配置端口映射，以启用与容器的通信。通过端口映射，目的地为容器主机上端口的请求将被转发到容器内的端口。 设想必须执行以下任务: 基于MariaDB，创建名为db01的容器化数据库。 配置容器端口映射和主机防火墙，以允许端口3306/tcp 上的流量。 配置db01容器，以使用具有适当SELinux 上下文的持久存储。 添加适当的网络配置，以便client01容器可以使用DNS与db01容器通信。 容器的环境变量 容器镜像允许在创建时传递环境变量以自定义容器 可以使用环境变量为容器设置参数，以根据您的环境进行定制，无需创建自己的自定义镜像。通常，您不会修改容器镜像，因为这会向镜像添加层，或许更加难以维护。 使用podman run -d –name db01utility.lab.example.com/rhel8/mariadb-103命令运行容器化数据库，但发现容器无法启动。 1234567891011121314151617181920212223242526[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 [student@servera ~]$ podman pull utility.lab.example.com/rhel8/mariadb-103[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman run -d --name db01 utility.lab.example.com/rhel8/mariadb-10329decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f# 发现容器无法启动[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES29decc6e48d6 utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 2 minutes ago Exited (1) 2 minutes ago db01 使用podman container logs命令调查容器状态的原因。 123456789101112131415[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...You must either specify the following environment variables: MYSQL_USER (regex: '^[a-zA-Z0-9_]+$') MYSQL_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$') MYSQL_DATABASE (regex: '^[a-zA-Z0-9_]+$')Or the following environment variable: MYSQL_ROOT_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$')Or both.Optional Settings:...... 12345678910111213# 输出中的usage 标签提供了如何运行镜像的示例。url标签指向红帽容器目录中的一个Web页面，其中记录了环境变量以及有关如何使用容器镜像的其他信息。# 此镜像的文档显示容器将3306端口用于数据库服务。文档中还显示了以下环境变量可用于配置数据库服务:[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman inspect utility.lab.example.com/rhel8/mariadb-103 | grep usage &quot;usage&quot;: &quot;podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103&quot;, &quot;usage&quot;: &quot;podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103&quot;,$ skopeo inspect docker://utility.lab.example.com/rhel8/mariadb-105 | grep -B 1 Usage#练习过程中可以将usage中提示的示例指令作为参考。 mariadb镜像的环境变量: 变量 描述 MYSQL_USER 要创建的MySQL帐户的用户名 MYSQL_PASSWORD 用户帐户的密码 MYSQL_DATABASE 数据库名称 MYSQL_ROOT_PASSWORD root用户的密码 (可选) 在检查了镜像的可用环境变量后，使用podmanrun命令-e选项将环境变量传递给容器，并使用podmanps命令来验证它是否正在运行。 12345678910111213[student@servera ~]$ podman rm -af29decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db utility.lab.example.com/rhel8/mariadb-10341a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896# 容器启动成功[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES41a62ff2efd7 utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 8 seconds ago Up 8 seconds db01 容器持久存储 ** 默认情况下运行容器时，所有内容都使用基于容器的镜像** **鉴于容器镜像的寿命短，用户或应用写入的所有新数据在移除容器后都会丢失** ** 若要持久保留数据，可以将容器中的主机文件系统内容与–volume(-v)选项搭配使用。在容器中使用此卷类型时，必须考虑文件系统级别的权限** **MariaDB容器镜像中，mysql用户必须拥有/var/lib/mysql目录，就如同MariaDB在主机上运行时一样** **打算挂载到容器中的目录必须具有mysql作为用户和组所有者(或mysql用户的UID/GID，如果主机上没有安装MariaDB)** ** 如果以root 用户身份运行容器，则主机上的UID和GID与容器内的UID和GID匹配** ** 可以使用podmanunshare命令在用户命名空间内运行命令。要获取用户命名空间的UID映射，请使用podmanunshare cat命令** 123456[student@servera ~]$ podman unshare cat /proc/self/uid_map 0 1000 1 1 100000 65536[student@servera ~]$ podman unshare cat /proc/self/gid_map 0 1000 1 1 100000 65536 以上输出显示： 容器中的root用户 (UID和GID为0)映射到主机计算机上的用户(UID和GID为1000) 容器中的UID和GID1映射到主机计算机上的UID和GID 100000 1后的每个UID和GID以1增量递增。例如，容器内的UID和GID30映射到主机计算机上的UID和GID100029 可以使用podmanexec命令查看使用临时存储运行的容器内的mysql用户UID和GID: 12[student@servera ~]$ podman exec -it db01 grep mysql /etc/passwdmysql:x:27:27:MySQL Server:/var/lib/mysql:/sbin/nologin 将/home/user/db_data目录挂载到db01容器中，以在容器的/var/lib/mysql目录中提供持久存储 创建/home/user/db_data目录，并使用podmanunshare命令将27的用户命名空间UID和GID设置为该目录的所有者 12345678910[student@servera ~]$ mkdir /home/student/db_data[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 student student 6 Mar 4 00:43 /home/student/db_data[student@servera ~]$ ll -d -n /home/student/db_datadrwxr-xr-x. 2 1000 1000 6 Mar 4 00:43 /home/student/db_data[student@servera ~]$ podman unshare chown 27:27 /home/student/db_data/[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 100026 100026 6 Mar 4 00:43 /home/student/db_data 容器中的UID和GID 27映射到主机计算机上的UID和GID100026。可以使用ll-d命令查看/home/student/db_data目录的所有权来验证映射。 现在已设置了正确的文件系统级权限，可使用podman run 命令-v选项来挂载目录: 123456789101112131415161718[student@servera ~]$ podman rm -af41a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql utility.lab.example.com/rhel8/mariadb-10354279d1fff7f3b679dd9d4efb7bfa28a626f41f7d07bea50a445ec2392c8cb02# db01容器未在运行[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES54279d1fff7f utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 6 minutes ago Exited (1) 6 minutes ago db01$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data/:/var/lib/mysql \\utility.lab.example.com/rhel8/mariadb-103 podman container logs命令显示/var/lib/mysql/data目录的权限错误： 12345678910111213141516171819[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...=&gt; sourcing 25-validate-replication-variables.sh ...=&gt; sourcing 30-base-config.sh ...---&gt; 05:58:29 Processing basic MySQL configuration files ...=&gt; sourcing 60-replication-config.sh ...=&gt; sourcing 70-s2i-config.sh ...---&gt; 05:58:29 Processing additional arbitrary MySQL configuration provided by s2i ...=&gt; sourcing 40-paas.cnf ...=&gt; sourcing 50-my-tuning.cnf ...---&gt; 05:58:29 Initializing database ...---&gt; 05:58:29 Running mysql_install_db ...mkdir: cannot create directory '/var/lib/mysql/data': Permission deniedFatal error Can't create database directory '/var/lib/mysql/data'# 发生此错误的原因是，主机上/home/user/db\\_data目录中设置的SELinux上下文不正确 容器存储的SELinux上下文 必须先设置container_file_t SELinux上下文类型，然后才能将该目录作为持久存储挂载到容器 如果目录没有container_file_t SELinux 上下文，则容器无法访问该目录 可以将Z选项附加到podmanrun命令-v选项的参数，以自动设置目录的SELinux上下文 当将/home/student/db_data目录挂载为/var/lib/mysql目录的持久存储时，可以使用podman run -v/home/student/db_data:/var/lib/mysql:Z 命令设置该目录的SELinux上下文 12345678910111213141516171819202122[student@servera ~]$ podman rm -af54279d1fff7f3b679dd9d4efb7bfa28a626f41f7d07bea50a445ec2392c8cb02[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z utility.lab.example.com/rhel8/mariadb-1036195fc399b1f6ae8f5b9d3f436c02bb5d6b093b597949dc968b2a64f6e7d023c[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6195fc399b1f utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 23 seconds ago Up 24 seconds db01[student@servera ~]$ ll -dZ /home/student/db_data/drwxr-xr-x. 3 100026 100026 system_u:object_r:container_file_t:s0:c428,c988 36 Mar 4 01:26 /home/student/db_data/$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data:/var/lib/mysql:Z \\utility.lab.example.com/rhel8/mariadb-103 分配端口映射到容器 要提供对容器的网络访问权限，客户端必须连接到容器主机上的端口，这些端口将网络流量传递到容器中的端口 将容器主机上的网络端口映射到容器中的端口时，容器将接收发送到主机网络端口的网络流量。 例如，可以将容器主机上的13306端口映射到容器上的3306端口，以便与MariaDB容器通信。因此，发送到容器主机端口13306的流量将由容器中运行的MariaDB接收。 可以使用 podman run命令 -p选项设置从容器主机上13306端口到db01容器上3306端口的端口映射 1234567891011121314151617181920[student@servera ~]$ podman rm -af6195fc399b1f6ae8f5b9d3f436c02bb5d6b093b597949dc968b2a64f6e7d023c[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z -p 13306:3306 utility.lab.example.com/rhel8/mariadb-10328202973f22d60ea4ccd096b8a321b30c7d57156a2c41d2502c1a0456c794ced[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES28202973f22d utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 20 seconds ago Up 20 seconds 0.0.0.0:13306-&gt;3306/tcp db01$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-p 13306:3306 \\-v /home/student/db_data:/var/lib/mysql:Z \\utility.lab.example.com/rhel8/mariadb-103 使用podmanport命令-a选项可显示正在使用的所有容器端口映射。还可以使用podmanportdb01命令显示 db01容器的映射端口。 1234[student@servera ~]$ podman port -a28202973f22d 3306/tcp -&gt; 0.0.0.0:13306[student@servera ~]$ podman port db013306/tcp -&gt; 0.0.0.0:13306 可以使用firewall-cmd命令允许端口13306流量传入容器主机，以便它可以重定向到容器: 1234567891011121314151617181920212223# Rootless(特权)容器无法打开主机上特权端口1024有 以下的端口。比如-p 80:8000 ，比必须使用root才可以对其进行调整[student@servera ~]$ sudo firewall-cmd --permanent --add-port=13306/tcp[sudo] password for student: success[student@servera ~]$ sudo firewall-cmd --reloadsuccess[student@servera ~]$ sudo firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: eth0 sources: services: cockpit dhcpv6-client ssh ports: 13306/tcp protocols: forward: yes masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: # firewall-cmd --add-port=13306/tcp --permanent# firewall-cmd --reload 附加测试通过主机mariadb数据库客户端软件访问容器数据库服务，需要安装mariadb软件后指定-u账号，-p密码(无空格)，-h数据库服务器所在主机名或IP(不是容器名)及-P(大写)主机映射端口 123456789101112131415161718192021222324252627[kiosk@foundation0 ~]$ sudo dnf -y install mariadb[kiosk@foundation0 ~]$ mysql -u user -ppass -h servera -P 13306 # -h 后面填写您当前实验的主机名或IPWelcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.3.17-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| db || information_schema || test |+--------------------+3 rows in set (0.012 sec)MariaDB [(none)]&gt; USE db;Database changedMariaDB [db]&gt; SHOW TABLES;Empty set (0.001 sec)MariaDB [db]&gt; exitBye 容器中的DNS配置Podmanv4.0支持两种容器网络后端，即Netavark和CNI 自RHEL9起，系统默认使用Netavark。若要验证所用的网络后端，请运行以下podmaninfo命令。 将网络堆栈从 CNI 切换到 Netavark | Red Hat ProductDocumentation 12$ podman info --format {{.Host.NetworkBackend}}netavark 主机上使用默认Podman网络的现有容器无法解析彼此的主机名，因为默认网络上未启用DNS。 使用podman network create命令创建一个支持DNS的网络。您可使用podmannetwork create命令创建名为db_net的网络，并将子网指定为10.87.0.0/16，网关指定为10.87.0.1。 123$ podman network create --gateway 10.87.0.1 --subnet 10.87.0.0/16 db_net$ podman network ls #列出容器网络 如果不指定–gateway 或–subnet 选项，则会使用默认值创建它们。 podman network inspect 命令显示关于特定网络的信息。您可以使用podmannetwork inspect 命令验证网关和子网的设置是否正确，以及新的dbnet网络是否启用了DNS。 1$ podman network inspect db_net 您可以使用podman run命令–network选项将启用DNS的db_net网络添加到新容器。您可以使用podman run命令–network选项创建连接到db_net网络的db01和client01容器 123456789101112131415161718$ podman run -d --name db01 \\--network db_net \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data:/var/lib/mysql:Z \\-p 13306:3306 \\utility.lab.example.com/rhel8/mariadb-105$ podman run -d --name client01 \\--network db_net \\-v /etc/yum.repos.d:/etc/yum.repos.d/ \\utility.lab.example.com/ubi9-beta/ubi \\sleep infinity$ podman ps -a 由于容器设计为仅具有所需的最少软件包，因此容器可能不具有测试通信所需的实用程序，如ping和ip命令。您可以使用podman exec 命令在容器中安装这些实用程序。 12$ podman exec client01 dnf install -y iputils iproute..output omitted.. 容器现在可以通过容器名称互相 ping。您可以使用podman exec命令来测试DNS解析。名称解析到为db_net网络手动设置的子网内的IP。 123456$ podman exec client01 ping -c4 db01PING db01.dns.podman (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=1 ttl=64 time=1.08 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=2 ttl=64 time=0.082 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=3 ttl=64 time=0.063 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=4 ttl=64 time=0.070 ms 您可以使用 podman exec命令验证每个容器中的IP地址是否与DNS解析匹配。 12$ podman exec client01 ip a | grep 10.8 inet 10.87.0.3/16 brd 10.87.255.255 scope global eth0 多个网络连接到单个容器多个网络可以同时连接到一个容器，以帮助分隔不同类型的流量。 您可以使用podman network create命令创建backend 网络 1$ podman network create backend 然后，使用podman network ls 命令查看所有 Podman 网络。 12345$ podman network lsNETWORK ID NAME DRIVER a7fea510a6d1 backend bridgefe680efc5276 db01 bridge2f259bab93aa podman bridge 没有通过podman network create 命令的–gateway和–subnet选项指定子网和网关。 使用podman network inspect 命令来获取backend网络的IP信息。 1$ podman network inspect backend 在容器运行时，您可以使用podman network connect命令将其他网络连接到容器。您可以使用podman networkconnect命令，将backend网络连接到db01和client01容器。 12$ podman network connect backend db01$ podman network connect backend client01 您可以使用podman inspect命令验证两个网络是否都已连接到各个容器并显示IP信息。 1234$ podman inspect db01$ podman inspect db01 | grep -A 34 Networks &gt; db01$ cat db01 #查看db01的两个网络IP为10.89.0.2 ， 10.87.0.2 client01容器现在可以与两个网络上的db01容器通信。您可以使用podman exec命令从cliento1容器pingdb01容器上的两个网络。 123456$ podman exec -ti client01 ping -c4 10.89.0.2PING 10.89.0.2 (10.89.0.2) 56(84) bytes of data.64 bytes from 10.89.0.2: icmp_seq=1 ttl=64 time=0.352 ms$ podman exec -ti client01 ping -c4 10.87.0.2PING 10.87.0.2 (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2: icmp_seq=1 ttl=64 time=0.594 ms 容器内安装mariadb客户端访问容器数据库 123$ podman exec client01 dnf -y install mariadbpodman$ podman exec -ti client01 mysql -u user -ppass -h db01 34.4 作为系统服务来管理容器使用systemd单元管理小型容器环境可以运行容器来完成系统任务，或获取一系列命令的输出 可能还希望运行无限期运行服务的容器，如Web 服务器或数据库 在传统环境中，特权用户通常将这些服务配置为在系统启动时运行，并使用systemctl 命令进行管理 作为普通用户，可以创建systemd单元来配置您的Rootless容器。利用此配置，可以通过systemctl命令将容器作为常规系统服务进行管理 基于systemd单元管理容器主要用于不需要扩展的基本和小型部署 对于许多基于容器的应用和服务的更复杂扩展和编排，可以使用基于Kubernetes的企业编排平台，如红帽OpenShift容器平台 为探讨本课中的主题，使用以下场景测试作为系统管理员，您被委任了一项任务，将基于nginx镜像的nginx容器配置为在系统启动时启动 必须为Web服务器内容挂载/home/appdev-adm/nginx_web目录，在目录中制作内容为“nginx_web_page”的索引页面，挂载至容器的nginx发布目录/usr/share/nginx/html，并将8080端口从本地计算机映射到容器80 将容器配置为通过systemctl命令来启动和停止 systemd用户服务要求作为普通用户，可以使用systemctl命令来启用服务 该服务在打开会话(图形界面、文本控制台或SSH)时启动，并在关闭最后一个会话时停止。此行为与系统服务有所不同，系统服务是在系统启动时启动并在系统关机时停止。 默认情况下，当使用useradd命令创建用户帐户时，系统将使用普通用户ID范围中的下一个可用ID 系统还在/etc/subuid文件中为用户的容器保留一系列ID 如果使用useradd命令–system选项创建用户帐户，则系统不会为用户容器保留范围。因此，无法使用系统帐户启动Rootless容器。 决定创建一个专门的用户帐户来管理容器。使用useradd命令创建appdev-adm用户，并将redhat用作密码。 12345678[student@servera ~]$ sudo useradd appdev-adm[sudo] password for student:student[student@servera ~]$ sudo passwd appdev-admChanging password for user appdev-adm.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully. 然后，使用 su命令切换到appdev-adm用户，并使用podman命令来启动。 1234567[student@servera ~]$ su appdev-admPassword:redhat[appdev-adm@servera student]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory &quot;/run/user/1000&quot; is not owned by the current user[root@servera ~]# su appdev-adm[appdev-adm@servera root]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory &quot;/run/user/0&quot; is not owned by the current user Podman是一款无状态实用程序，需要完整的登录会话 Podman 必须在SSH会话中使用，不能在sudo或su shell中使用。因此，您将退出sushell，并通过SSH登录计算机。 无状态应用:Stateless Application是指并不会在会话中保存下次会话中去要的客户端数据。每一个会话都像首次执行一样,不会依赖之前的数据进行响应。 123456789101112131415161718192021[appdev-adm@servera root]$ exitexit[root@servera ~]# ssh appdev-adm@localhostappdev-adm@localhost's password:Register this system with Red Hat Insights: insights-client --registerCreate an account or view all your systems at https://red.ht/insights-dashboardLast login: Tue Mar 4 09:06:27 2025[appdev-adm@servera ~]$ podman info[appdev-adm@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded![appdev-adm@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103utility.lab.example.com/rhel9/mariadb-105utility.lab.example.com/rhel9/httpd-24utility.lab.example.com/library/nginxutility.lab.example.com/ubi7/ubiutility.lab.example.com/ubi9/ubiutility.lab.example.com/ubi8/ubiutility.lab.example.com/ubi9/python-312utility.lab.example.com/rhel9/php-82 然后，配置容器注册表并使用您的凭据进行身份验证。您可以使用以下命令运行http 容器。 12345678910[appdev-adm@servera ~]$ mkdir /home/appdev-adm/nginx_web/[appdev-adm@servera ~]$ echo nginx_web_page &gt; /home/appdev-adm/nginx_web/index.html[appdev-adm@servera ~]$ cat /home/appdev-adm/nginx_web/index.htmlnginx_web_page[appdev-adm@servera ~]$ podman run -d --name nginx -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z -p 8080:80 utility.lab.example.com/library/nginx[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 2 minutes ago Up 2 minutes 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera ~]$ curl localhost:8080nginx_web_page 为容器创建systemd用户文件在~/.confiq/svstemd/user/目录中手动定义systemd服务 用户服务的文件语法与系统服务文件的相同。有关更多详细信息，请查看systemd.unit(5)和systemd.service(5)man手册 使用podman generate systemd 命令为现有容器生成systemd 服务文件podmangenerate systemd 命令使用容器作为模型来创建配置文件 podman generate systemd命令–new选项指示podman实用程序对systemd服务进行配置，以便在该服务启动时创建容器并在该服务停止时删除容器 可以使用podman generatesystemd命令和–name选项来显示为nginx容器建模的systemd服务文件 1234567891011121314151617181920212223242526272829303132[appdev-adm@servera ~]$ man systemd.unit | grep config.*user ~/.config/systemd/user.control/* ~/.config/systemd/user/* │~/.config/systemd/user.control │ using the dbus API ($XDG_CONFIG_HOME is used if │ │$HOME/.config/systemd/user │ set, ~/.config otherwise) │[appdev-adm@servera ~]$ man systemd.unit[appdev-adm@servera ~]$ mkdir -p ~/.config/systemd/user/[appdev-adm@servera ~]$ cd ~/.config/systemd/user/[appdev-adm@servera ~]$ podman stop nginx # 生成单元文件之前先停止容器nginx[appdev-adm@servera user]$ podman generate systemd -n nginx -f/home/appdev-adm/.config/systemd/user/container-nginx.service[appdev-adm@servera user]$ lscontainer-nginx.service[appdev-adm@servera user]$ systemctl --user enable --now container-nginx.serviceCreated symlink /home/appdev-adm/.config/systemd/user/default.target.wants/container-nginx.service → /home/appdev-adm/.config/systemd/user/container-nginx.service.[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 26 minutes ago Up About a minute 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera user]$ systemctl --user stop container-nginx.service[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 27 minutes ago Exited (0) 16 seconds ago 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera user]$ systemctl --user restart container-nginx.service$ podman generate systemd -n nginxExecStart=/usr/bin/podman start nginxExecStop=/usr/bin/podman stop -t 10 nginx*$ podman generate systemd -n nginx -f$ lscontainer-nginx.service 启动时，systemd守护进程执行podman start命令来启动现有容器 停止时，systemd守护进程执行podmanstop命令来停止容器。请注意，systemd守护进程不会删除该容器。 然后，使用上一命令并加上–new选项来比较systemd配置。 1234567891011$ podman generate systemd -n nginx --newExecStartPre=/bin/rm -f %t/%n.ctr-idExecStart=/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon --rm --sdnotify=conmon --replace -d --name nginx -p 8080:80 -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z utility.lab.example.com/library/nginxExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-idExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id#通过--new选项创建用户单元文件的方法，仅供参考$ cd ~/.config/systemd/user/$ podman generate systemd -n nginx --new -f/home/appdev-adm/.config/systemd/user/container-nginx.service 启动时，systemd守护进程执行 podman run命令以创建并启动新容器。此操作使用podman run命令–rm选项，它将在停止时删除容器。 停止时，systemd 执行 podman stop 命令以停止容器。 在systemd停止容器后，systemd 将使用podman rm -f命令将其移除。 验证 podman generate systemd 命令的输出，并使用–files选项运行上一命令，以在当前目录中创建systemd用户文件。由于nginx容器使用持久存储，因此您选择使用带有–new选项的podmangeneratesystemd命令。然后，创建~/config/systemd/user/目录并将文件移到此位置上 为容器管理systemd用户文件现在，您已创建了 systemd 用户文件，可以使用 systemctl命令 –user选项来管理nginx容器。首先，重新加载systemd守护进程，使systemctl命令知道新的用户文件。使用systemctl–userstart命令启动nginx容器。使用为容器生成的 systemd用户文件的名称。 123456$ systemctl --user enable --now container-nginx.service#其他的管理方法，仅供参考$ systemctl --user status container-nginx.service$ systemctl --user stop container-nginx.service#建议重启验证容器是否可以 开机自启动 下表总结了 systemd 系统和用户服务之间使用的不同目录和命令。 比较系统和用户服务 存储自定义单元文件 系统服务 /etc/systemd/system/unit.service 用户服务 \\~/.config/systemd/user/unit.service 重新加载单元文件 系统服务 # systemctl daemon-reload 用户服务 \\$ systemctl --user daemon-reload 启动和停止服务 系统服务 # systemctl start UNIT \\# systemctl stop UNIT 用户服务 \\$ systemctl --user start UNIT \\$ systemctl --user stop UNIT 在计算机启动时启动服务 系统服务 # systemctl enable UNIT 用户服务 \\$ loginctl enable-linger \\$ systemctl --user enable UNIT 将容器配置为在系统引导时启动此时，systemd服务配置已就绪，可以为给定的用户运行容器。但是，如果用户从系统注销，systemd服务会在特定时间后停止容器。出现此行为的原因是，systemd服务单元是使用.user选项创建的，它在用户登录时启动服务，并在用户注销时停止服务。 ​不过，您可以通过运行loginctl enable-linger命令来更改此默认行为，并强制已启用的服务在服务器启动时启动，并在服务器关闭期间停止。​可以使用loginctl命令将systemd用户服务配置为在所配置服务的最后一个用户会话关闭后保留 使用 loginctl show-user 命令验证配置是否成功。 123456789101112[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=no[appdev-adm@servera ~]$ loginctl enable-linger[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=yes# 重启后进行测试[kiosk@foundation0 ~]$ ssh root@servera[root@servera ~]# ssh appdev-adm@localhost[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 40 minutes ago Up About a minute 0.0.0.0:8080-&gt;80/tcp nginx 以Root 用户身份使用Systemd 管理容器将容器配置为以root身份运行，并使用systemd服务文件进行管理。这种方法的一个优势是，您可以将这些服务文件配置为像常见systemd单元文件那样工作，而不是以特定用户身份来运行。 将服务文件设置为 root的过程与前面概述的Rootless容器过程类似，但以下例外: ​ 不要创建专门的用户来管理容器。 ​服务文件必须在/etc/systemd/system目录中，而不是在~/config/systemd/user目录中 ​使用systemctl命令管理容器，但不使用 –user 选项 ​ 不要以root用户身份运行loginctl enable-linger命令 有关演示，请参见本节末尾参考资料中所列红帽视频频道中的YouTube视频 练习：P358 34.5 容器模考练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-RH134-foundation0$ for i in classroom utility bastion workstation servera;do rht-vmctl start $i;done$ ssh workstation-workstation$ lab start containers-deploy$ ssh servera#第一题-servera$ podman login utility.lab.example.com -u admin -p redhat321 #应提示登录成功$ sudo vim ~/Containerfile FROM utility.lab.example.com/ubi9-beta/ubi:latestRUN mkdir /dir{1,2}RUN echo -e '[rhel-9.0-for-x86_64-baseos-rpms]\\nbaseurl = http://content.example.com/rhel9.0/x86_64/dvd/BaseOS\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.0 BaseOS (dvd)\\n[rhel-9.0-for-x86_64-appstream-rpms]\\nbaseurl = http://content.example.com/rhel9.0/x86_64/dvd/AppStream\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.0 Appstream (dvd)'&gt;/etc/yum.repos.d/rhel_dvd.repoRUN yum install --disablerepo=* --enablerepo=rhel-9.0-for-x86_64-baseos-rpms --enablerepo=rhel-9.0-for-x86_64-appstream-rpms -y python3CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;sleep infinity&quot;]*$ podman build -t pdf .$ podman images#继续做第二题$ sudo -istudent# mkdir /opt/{file,progress}# chown -R student /opt # ll /opt# exit$ podman run \\ -d \\ --name ascii2pdf \\ -v /opt/file:/dir1:Z \\ -v /opt/progress:/dir2:Z \\ pdf$ podman stop ascii2pdf$ loginctl enable-linger$ loginctl show-user wallah$ MANWIDTH=160; man systemd.unit | grep config.*user... `│$HOME/.config/systemd/user` │...*$ mkdir -p ~/.config/systemd/user/*$ cd ~/.config/systemd/user/*$ podman generate systemd -n ascii2pdf -f*$ systemctl --user enable --now container-ascii2pdf$ systemctl --user status container-logserver 1234$ &lt;Ctrl-D&gt;# cp /etc/fstab /opt/file# ls /opt/progress# file /opt/progress/fstab","link":"/2025/04/15/podman%E5%AE%B9%E5%99%A8/"},{"title":"Ansible的基本使用","text":"1 介绍Ansible ​ Ansible是python开发的、开源的批量自动化运维工具 ​ 官方网站:https://www.ansible.com https://docs.ansible.com/ 1.1 Ansible的概念和架构​ 通过inventor定义Managed node，并由SSH与python进行连通 ​ 1.管理机上管理被管机 ​ 2.inventory(清单)分组被管机 ​ 基于SSH、PowerShell进行PUSH ad-hoc或基于YML文件Playbook ​ Python模块、插件、API 1.2 Absible的优势​ **简单明了:**Ansible playbook，更好的对任务进行排序编写​ **功能强大:**3000多个模块，配置管理、工作流自动化、网络自动化​ **无需代理:**通过SSH管理，而puppet、saltstack需要装客户端​ 与其他系统轻松集成，如jenkins​ **跨平台支持:**win、linux、unix、网络设备，虚拟机、物理机、云主机、容器 1.3 在控制节点上安装Ansible​ 1.Ansible自动化平台2概述-Ansible Core​ 红帽Ansible自动化平台2包含多个不同的组件，共同提供了一整套集成的自动化工具和资源**​ Ansible Core提供用于运行Ansible Playbook的基本功能。 ​ 定义了用于在YAML文本文件中编写Ansible Playbook的自动化语言 ​ 提供了自动化代码所需的关键功能，如循环、条件和其他Ansible命令 ​ 提供了驱动自动化所需的框架和基本命令行工具​ 红帽Ansible自动化平台2在ansible-core RPM软件包及其ee-minimal-rhel8和ee-supported-rhel8自动化执行环境中提供Ansible Core 2.13 ​ 2.Ansible自动化平台2概述-Ansible内容集合​ 在过去，Ansible提供了大量模块作为核心软件包的一部分;这种方法在Ansible社区中被称为“自带电池”。Ansible中包含的模块数量呈指数级增长。这导致了支持方面的一些挑战，特别是因为用户有时希望使用比Ansible特定版本中附带模块版本更早或更高的模块​ 上游开发人员决定将大多数模块重新整理为单独的Ansible collection(内容集合)，这些资源collection相关的模块角色和插件构成，由同一组开发人员提供支持。 ​ Ansible Core本身仅限于由ansible.builtin、Ansible collection(内容集合)提供的一小组模块，该集合始终是Ansible Core的一部分​ 订阅红帽Ansible自动化平台2后，可获得红帽提供的120多个认证内容集合的访问权限，另外还可通过AnsibleGalaxy获得很多受社区支持的集合 ​ 3.Ansible自动化平台2概述-自动化内容导航器​ 红帽Ansible自动化平台2还可提供新的顶级工具(自动化内容导航(ansble-navigator))来开发和测试Ansible Playbook。该工具可取代并扩展多个命令行实用程序的功能，包括ansible-playbook、ansible-inventory、ansible-config​ 通过在容器中运行playbook，将运行Ansible的控制节点与运行它的自动化执行环境分隔开来。这样一来，可以更轻松地为自动化代码提供完整的工作环境，以部署到生产环境中 ​ 4.Ansible自动化平台2概述-自动化执行环境​ 自动化执行环境是一种容器镜像，包含Ansible Core、Ansible内容集合以及运行playbook所需的任何Python库、可执行文件或其他依赖项​ 使用ansible-navigator运行playbook时，可选择用于运行该playbook的自动化执行环境 ​ 当代码运行时，可以向自动化控制器提供playbook和自动化执行环境，并且也知道其具有正确运行playbook所需的一切 ​ 5.Ansible自动化平台2概述-准备控制节点​ 要运行Ansible Playbook，需在控制节点安装自动化内容导航器(ansible-navigator)，然后下载执行环境 ​ 由Ansible托管的主机无需安装ansible-navigator，该工具只需安装在运行Ansible Playbook的控制节点 ​ 安装ansible-core软件包前，先要在控制节点上安装Python3.8或更高版本​ 需要有效的红帽Ansible自动化平台订阅，才能在控制节点上安装自动化内容导航器 ​ 如果已在红帽客户门户中为您的组织激活了简单内容访问，则您无需再将订阅连接到系统 ​ 7.Ansible自动化平台2概述-安装Ansible 1234567#登录workstation后默认为student普通用户，根据实际使用和考试结合建议使用普通用户操作。以下本课程所有操作均为普通用户操作。方法1:[kiosk@foundation0 ~]$ ssh student@workstation方法2:--考试推荐使用[kiosk@foundation0 ~]$ ssh root@workstation[root@workstation ~]$ ssh student@localhost 12345678910111213141516171819202122#在控制节点上安装自动化内容导航器- workstation[student@workstation ~]$ lab start intro-install[student@workstation ~]$ sudo dnf search ansible #搜索ansible关键字的软件包，方便查找ansible的软件[sudo] password for student:ansible-navigator.noarch : Red Hat Ansible Automation Platform CLIansible-core.x86_64 : SSH-based configuration management, deployment, and task execution system[student@workstation ~]$ sudo dnf -y install ansible-navigator.noarch ansible-core.x86_64[student@workstation ~]$ rpm -q ansible-navigatoransible-navigator-2.1.0-1.el9ap.noarch[student@workstation ~]$ rpm -q ansible-coreansible-core-2.13.0-2.el9ap.x86_64[student@workstation ~]$ rpm -qc ansible-core/etc/ansible/ansible.cfg/etc/ansible/hosts[student@workstation ~]$ rpm -qc ansible-navigator 1234567891011121314151617181920212223242526#检查ansible的版本[student@workstation ~]$ ansible --versionansible [core 2.13.0] config file = /etc/ansible/ansible.cfg configured module search path = ['/home/student/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python3.9/site-packages/ansible ansible collection location = /home/student/.ansible/collections:/usr/share/ansible/collections executable location = /bin/ansible python version = 3.9.10 (main, Feb 9 2022, 00:00:00) [GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] jinja version = 3.0.3 libyaml = True[student@workstation ~]$ ansible-navigator --versionansible-navigator 2.1.0# 安装ansible后会提供导航器配置文件[student@workstation ~]$ ls -a. .ansible .ansible-navigator.yml .bash_logout .bashrc .config Documents .grading .jupyter Music Pictures .ssh .venv.. ansible-navigator.log .bash_history .bash_profile .cache Desktop Downloads .ipython .local .npm Public Templates Videos[student@workstation ~]$ cat .ansible-navigator.yml---ansible-navigator: execution-environment: image: utility.lab.example.com/ee-supported-rhel8:latest pull: policy: missing 8.Ansible自动化平台2概述-登录镜像仓库 123456789101112131415161718192021222324252627282930313233#配置镜像仓库不进行https验证,可以使用全局或个人的，考试已设置好。[student@workstation ~]$ mkdir ~/.config/containers #~/.config/containers等价于/home/student/.config/containers[student@workstation ~]$ cp /etc/containers/registries.conf ~/.config/containers[student@workstation ~]$ vim ~/.config/containers/registries.conf# 22行unqualified-search-registries = [&quot;utility.lab.example.com&quot;]# 24行[[registry]]# 37行insecure = true# 40行blocked = false# 56行location = &quot;utility.lab.example.com&quot;#登录容器镜像服务器，为下载自动化执行环境容器镜像做准备[student@workstation ~]$ podman --versionpodman version 4.0.2[student@workstation ~]$ ping utilityPING utility.lab.example.com (172.25.250.220) 56(84) bytes of data.64 bytes from utility.lab.example.com (172.25.250.220): icmp_seq=1 ttl=64 time=0.496 ms64 bytes from utility.lab.example.com (172.25.250.220): icmp_seq=2 ttl=64 time=0.456 ms......[student@workstation ~]$ podman login -u admin -p redhat utility.lab.example.comLogin Succeeded!#下载自动化内容导航器或使用ansible-navigator命令自动下载[student@workstation ~]$ ansible-navigator collections #如果发现镜像服务器登录失败，可重置一下utility服务器[student@workstation ~]$ ansible-navigator images #查看下载的镜像环境esc退出 2 部署Ansible2.1 构建Ansible清单系统默认的清单文件1234567891011121314151617181920212223242526272829303132333435363738394041# 清单定义Ansible管理的主机集合。这些主机也可以分配到组中，以进行集中管理。组可以包含子组，主机也可以是多个组的成员# 清单还可以设置应用到它所定义的主机和组的变量# 定义主机清单可采用两种方式: 1.使用文本文件定义静态主机清单 2.通过外部信息提供程序，使用Ansible插件按需生成动态主机清单# 系统默认清单在/etc/ansibile/hosts# 举例1:[test] #组名172.25.250.10serveraservera.lab.exaple.com[web]servera.example.comserverb.example.com[webservers]web[1:50].example.com #表示从web1到web50，共计50台主机# 举例2:# [嵌套组名:children]，嵌套组内只能包含组，不包含主机[test]172.25.250.10serveraservera.lab.exaple.com[web]servera.example.comserverb.example.com[servers:children] #表示servers组是一个超级组，包含test和web两个组(嵌套)testweb# 指定清单范围格式：通配符或正则表达式的方法[START:END] #开始:结束范围192.168.[0:15].[0:255] #表示 192.168.0.0-192.168.15.255server[a:c].example.com #表示 a-cserver[01:15].example.com #表示 server01.example.com-server15.example.comall： #表示 所有主机ungrouped: #表示 指定组/未分配组的主机 12345[student@workstation ~]$ rpm -q ansible-coreansible-core-2.13.0-2.el9ap.x86_64[student@workstation ~]$ rpm -qc ansible-core/etc/ansible/ansible.cfg #默认全局配置文件/etc/ansible/hosts #默认全局清单文件 自定义清单文件123456# 当使用特权用户管理Ansible时，可以在家目录中为其创建工作目录，目录名称可以根据业务自定义名称,今后的所有文件都放到此目录，包括配置文件、清单文件、playbook等1.创建工作目录[student@workstation ~]$ mkdir ~/ansible[student@workstation ~]$ cd ~/ansible/[student@workstation ansible]$ pwd/home/student/ansible 1234#查看清单实例文件[student@workstation ansible]$ ansible-doc -t inventory -l[student@workstation ansible]$ ansible-doc -t inventory ini[student@workstation ~]$ ansible-navigator doc -t inventory ini 1234567891011121314152.编辑清自定义单文件+嵌套组[student@workstation ansible]$ vim inventoryservera #未在组内的主机[web] #主机组，主机组名称需要使用中括号括起来[]，web是组名称server[b:c] #主机组成员，web组内的主机 表示两个主机serverb至serverc172.25.250:[10:15][db]server[d:z].lab.example.com[servers:children] #嵌套组名servers是自定义的，但是:children是固定语法，表示web、db在servers组中，嵌套组成员应为组，不应为主机webdb#注意：不要在清单里书写无用的符号，及一些特殊符号。主机名称不要和主机组冲突，组名尽量不要用数字开头。 1234567891011121314151617183.验证清单： #使用ansible-navigator或ansible-inventory命令验证计算机是否存在于清单中 1.ansible-navigator inventory以stdout模式运行 2.第一条传统Ansible的验证方式，第二条使用Ansible自动化平台2的方式-RHEL8 &amp; 9-i inventory #指定清单文件的位置--list-hosts #列出清单中的主机 --graph #通过ansible-inventory命令列出清单整个pattern$ ansible all -i inventory --list-hosts*$ ansible-inventory --graph -i inventory #推荐，RHEL9考试可用[student@workstation ansible]$ ansible-inventory --graph -i /home/student/ansible/inventory-RHEL 9$ ansible-navigator inventory -i inventory -m stdout --list$ ansible-navigator inventory -i inventory -m stdout --graph$ ansible-navigator inventory -i inventory -m stdout --graph webservers重要：清单中含有名称相同的主机和主机组，ansible命令显示警告并以主机作为其目标，组被忽略 覆盖清单位置1234567891011121314#安装ansible软件后，在/etc/ansible/hosts位置提供一个默认主机清单，属于全局管理范围#特权用户管理时可以为其在工作目录中创建清单，在工作目录中使用ansible时，且优先度最高/home/student/ansible/inventory 优 #用于针对某个用户设置清单(考试使用)/etc/ansible/hosts 劣 #用于全局设置[student@workstation /]$ ansible-inventory --graph@all: |--@ungrouped:[student@workstation /]$ pwd/[student@workstation ansible]$ ansible-inventory --graph@all: |--@ungrouped:[student@workstation ansible]$ pwd/home/student/ansible 多清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#一个用户可以有一个或多个清单文件，若同时使用，可将多个清单文件放置清单目录中，清单目录需自行创建，名称自定义[student@workstation ansible]$ vim inventoryservera[web]serverbserverc[db]serverd[servers:children]webdb[student@workstation ansible]$ ansible-inventory --graph -i inventory@all: |--@servers: | |--@db: | | |--serverd | |--@web: | | |--serverb | | |--serverc |--@ungrouped: | |--servera[student@workstation ansible]$ cp inventory inventory2 #额外创建一份清单名为inventory2# [student@workstation ansible]$ echo servere &gt; inventory2 #inventory2内指定一个主机servere[student@workstation ansible]$ vim inventory2 #inventory2内指定一个主机servereservere[student@workstation ansible]$ mkdir invdir #创建清单存储目录，名称自定义[student@workstation ansible]$ mv inv* invdir/ #将所有清单移动至清单存储目录mv: cannot move 'invdir' to a subdirectory of itself, 'invdir/invdir'[student@workstation ansible]$ ls invdir/inventory inventory2[student@workstation ansible]$ lltotal 0drwxr-xr-x. 2 student student 41 Mar 8 00:05 invdir[student@workstation ansible]$ tree.└── invdir ├── inventory └── inventory21 directory, 2 files[student@workstation ansible]$ ansible-inventory --graph -i invdir/ #查看主机模式结构@all: |--@servers: | |--@db: | | |--serverd | |--@web: | | |--serverb | | |--serverc |--@ungrouped: | |--servera | |--servere 2.2 管理Ansible配置文件12345678910111213141516171819# 还原清单文件[student@workstation ansible]$ mv invdir/inventory .[student@workstation ansible]$ lsinvdir inventory[student@workstation ansible]$ rm -rf invinvdir/ inventory[student@workstation ansible]$ rm -rf invdir/[student@workstation ansible]$ lsinventory[student@workstation ansible]$ ansible-inventory --graph -i inventory@all: |--@servers: | |--@db: | | |--serverd | |--@web: | | |--serverb | | |--serverc |--@ungrouped: | |--servera 配置Ansible1234# Ansible的配置文件作用是指导ansible工具的功能设置# 安装Ansible软件后，自动生成配置文件 /etc/ansible/ansible.cfg 用于配置多个Ansible工具的行为 ~/.ansible-navigator.yml 用于更改ansible-navigator命令默认选项 123456789[student@workstation ansible]$ rpm -qc ansible-core/etc/ansible/ansible.cfg/etc/ansible/hosts[student@workstation ~]$ ls -a. ansible .bash_history .bashrc Desktop .grading .lesshst .npm .ssh Videos.. ansible-navigator.log .bash_logout .cache Documents .ipython .local Pictures Templates .viminfo.ansible .ansible-navigator.yml .bash_profile .config Downloads .jupyter Music Public .venv[student@workstation ~]$ ls -a ~/.ansible-navigator.yml/home/student/.ansible-navigator.yml 管理Ansible设置 指令 描述 inventory 指定清单文件的路径。 remote_user 指定Ansible用于连接受管主机的用户名。如果未指定，则使用当前用户的名称。(在由ansible-navigator 运行的基于容器的自动化执行环境中，始终为 root。) ask_pass 指示是否提示输入SSH 密码。 (可以是 false，如果使用SSH公钥身份验证，则此为默认值。) become 指定连接后是否在受管主机上自动切换用户(一般切换为root)。这也可以通过play来指定 become_method 指定如何切换用户(通常为 sudo，此为默认值，但也可选择su) become_user 指定要在受管主机上切换到哪个用户(通常为 root，此为默认值) become_ask_pass 指示是否提示输入become_method参数密码。默认为false 自定义配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131.普通用户身份远程 #重点掌握，考点 # 在工作目录中生成ansible的配置文件[student@workstation ~]$ cat /etc/ansible/ansible.cfg | grep ansible.cfg# $ ansible-config init --disabled &gt; ansible.cfg# ansible-config init --disabled -t all &gt; ansible.cfg# for example, for 2.9: https://github.com/ansible/ansible/blob/stable-2.9/examples/ansible.cfg[student@workstation ~]$ ansible-config init --disabled &gt; /home/student/ansible/ansible.cfg[student@workstation ~]$ pwd/home/student[student@workstation ~]$ cd /home/student/ansible/[student@workstation ansible]$ lsansible.cfg inventory [student@workstation ansible]$ ansible --versionansible [core 2.13.0] config file = /home/student/ansible/ansible.cfg[student@workstation ansible]$ cd /[student@workstation /]$ ansible --versionansible [core 2.13.0] config file = /etc/ansible/ansible.cfg [student@workstation /]$ cp /home/student/ansible/ansible.cfg ~/.ansible.cfg[student@workstation /]$ ansible --versionansible [core 2.13.0] config file = /home/student/.ansible.cfg # Ansible的配置文件/etc/ansible/ansible.cfg，由几个部分组成，每一部分含有以键值对形式定义的设置。部分的标题以方括号括起。对于基本操作，请使用以下两部分:1.[defaults]---用于设置Ansible操作的默认值2.[privilege_escalation]---用于配置Ansible如何在受管主机上执行特权升级 [student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ vim ansible.cfg[defaults]inventory=/home/student/ansible/inventory #139行 工作目录清单位置remote_user=student #222行 远程用户可选root或普通用户 host_key_checking=false #318行 不进行公钥记录[privilege_escalation] #搜/become，n向下查找 或 输入:430become=true #430行 开启特权功能，#become_ask_pass=False #433行 远程免特权密码，需要对端添加sudo免密 #become_method=sudo #442行 远程功能启用sudo#become_user=root #445行 特权用户为root备注:剪切操作 dd+p# 验证配置文件是否书写正确[student@workstation ansible]$ ansible-inventory --graph # 取消对清单的指定@all: |--@servers: | |--@db: | | |--serverd | |--@web: | | |--serverb | | |--serverc |--@ungrouped: | |--servera # 测试[student@workstation ansible]$ ansible -m ping allservera | FAILED! =&gt; { &quot;msg&quot;: &quot;Missing sudo password&quot;}serverd | FAILED! =&gt; { &quot;msg&quot;: &quot;Missing sudo password&quot;}serverc | FAILED! =&gt; { &quot;msg&quot;: &quot;Missing sudo password&quot;}serverb | FAILED! =&gt; { &quot;msg&quot;: &quot;Missing sudo password&quot;}#练习环境默认student远程免密，所以不用做。#但是student未做sudo免密，以下命令为servera~d设置sudo免密。[workstation][student@workstation ansible]$ for i in {a..d};do ssh root@server$i 'sed -i s/^%wheel.*$/&quot;%wheel ALL=(ALL) NOPASSWD: ALL&quot;/ /etc/sudoers';done[student@workstation ansible]$ for i in {a..d};do ssh root@server$i 'grep ^%wheel /etc/sudoers';done%wheel ALL=(ALL) NOPASSWD: ALL%wheel ALL=(ALL) NOPASSWD: ALL%wheel ALL=(ALL) NOPASSWD: ALL%wheel ALL=(ALL) NOPASSWD: ALL# 测试远程部署[student@workstation ansible]$ ansible all -m pingserverd | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;}serverc | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;}servera | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;}serverb | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;} 1234567892.# ansible配置文件可以存在于不同位置其中包括：$ /etc/ansible/ansible.cfg #默认路径$ ~/.ansible.cfg #家目录$ ~/ansible/ansible.cfg #ansible为工作目录(练习和考试时使用)$ grep ANSIBLE_CONFIG /etc/profile #环境变量export ANSIBLE_CONFIG=/opt/ansible.cfg （此时/opt下需要有ansible.cfg配置文件）source /etc/profile 加载优先级 ：变量＞当前目录＞用户家目录＞/etc 123456789101112133.# 其他指定远程用户及密码的方法，以root用户身份远程方法一：ansible.cfgremote_user=rootinventory[all:vars]ansible_password=redhat方法二：inventory[all:vars]ansible_user=rootansible_password=redhat 1234567891011121314151617184.# 练习根据以上笔记将清单路径记录至inventory=后，要求远程用户为普通用户，并查看清单主机模式结构。1.创建工作目录，创建并完善清单2.在工作目录中制作配置文件，并完善3.保证远程和sudo都免密#练习环境默认student远程免密，所以不用做。#但是student未做sudo免密，以下命令为servera~d设置sudo免密。[workstation]$ for i in {a..d};do ssh root@server$i 'sed -i s/^%wheel.*$/&quot;%wheel ALL=(ALL) NOPASSWD: ALL&quot;/ /etc/sudoers';done$ for i in {a..d};do ssh root@server$i 'grep ^%wheel /etc/sudoers';done4.测试远程部署$ ansible all -m pingservera | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/libexec/platform-python&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; 管理自动化内容导航器的设置12345678910111213141516 #可以为ansible-navigator创建配置文件(或设置文件)，以覆盖其配置设置的默认值 #配置文件可以采用JSON(json)或YAML(yml或yam)格式。本项讨论主要采用YAML格式 #自动化内容导航器按以下顺序查找配置文件，并使用它找到的第一个文件: 1.如果设置了ANSIBLE NAVIGATOR_CONFIG环境变量，则使用所指定位置处的配置文件 2.当前Ansible项目目录中的ansible-navigator.yml文件 3.~/.ansible-navigator.yml文件(主目录中)。请注意，其文件名开头有一个“点” #与Ansible配置文件一样，每个项目都可以有自己的自动化内容导航器设置文件。#创建导航器配置文件[student@workstation ~]$ rpm -ql ansible-navigator | grep temp/usr/lib/python3.9/site-packages/ansible_navigator/actions/__pycache__/template.cpython-39.opt-1.pyc/usr/lib/python3.9/site-packages/ansible_navigator/actions/__pycache__/template.cpython-39.pyc/usr/lib/python3.9/site-packages/ansible_navigator/actions/template.py/usr/lib/python3.9/site-packages/ansible_navigator/package_data/settings-sample.template.yml[student@workstation ~]$ vim /usr/lib/python3.9/site-packages/ansible_navigator/package_data/settings-sample.template.yml 12345678910111213141516171819[student@workstation ~]$ vim ~/.ansible-navigator.yml---ansible-navigator: execution-environment: image: utility.lab.example.com/ee-supported-rhel8:latest pull: policy: missing # 容器镜像下载策略 missing系统里有就不下载，否则下载$ vim ~/.ansible-navigator.yml ---ansible-navigator: execution-environment: image: utility.lab.example.com/ee-supported-rhel8:latest pull: arguments: - &quot;--tls-verify=false&quot; policy: missing playbook-artifact: enable: false #关闭运行playbook时生成日志 执行剧本所产生的日志，执行一次记录一次 1234567891011#anisble远程连接时的必要条件1.配置链接：如何选择远程的用户2.清单位置：相对路径、绝对路径、多清单等。3.链接设置remote_user= ，~/.ansible-navigator.yml中playbook-artifact：4.ssh免密ssh-key-gen，ssh-copy-id5.升级特权visudo，/etc/sudoers 2.3 编写和运行Playbook​ Play是针对清单中选定的主机运行的一组有序任务 ​ Playbook是一个文本文件，其中包含由一个或多个按特定顺序运行的play组成的列表 ​ 临时命令可以作为一次性命令对一组目标主机运行一项简单的任务 ​ Playbook可以通过轻松重复的方式对一组目标主机执行多项复杂的任务 Playbook-yaml语法 1.playbook是使用YAML语法编写的文本文件，格式为.yml 2.严格缩进，空格 3.YAML文件以—开头，…. 结束，可以省略 4.使用”-“(减号加一个或多个空格)作为列表项 5.#注释 1234567891011$ ansible-doc -l | grep yum$ ansible-doc yum #进入之后，搜索/EXAMPLE$ vim ~/ansible/web.yml--- #yaml语法，---开头- name: install httpd #play任务的描述：描述部分name字段是可选的选项 hosts: servera #主机模式：任务目标主机 tasks: #任务列表：下面通常为任务模块，有两格缩进 - name: Install Apache #任务模块：注意和tasks有两格缩进，name是可选字段，模块描述 ansible.builtin.yum: #模块名称： name: httpd #模块选项1 state: latest #模块选项2 练习：写一个在servera上部署整套httpd服务的剧本 123456789101112131415161718192021222324252627282930313233343536[student@workstation ~]$ cd ansible[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ vim inventory[dev]serveraserverb[test]servercserverd[student@workstation ansible]$ ansible-inventory --graph@all: |--@dev: | |--servera | |--serverb |--@test: | |--serverc | |--serverd |--@ungrouped:[student@workstation ansible]$ vim soft.yml---- name: install web server hosts: servera tasks: #写模块时格式可以参考帮助ansible-doc -l | grep yum发现yum模块后，ansible-doc yum查看帮互助，/EX 找到例子复制到剧本中，再进行修改 - name: Install the latest version of Apache ansible.builtin.yum: name: httpd state: latest[student@workstation ansible]$ cd /home/student/ansible[student@workstation ansible]$ ansible-navigator run web.yml --syntax-check -m stdout #执行前进行语法检查playbook: /home/student/ansible/web.yml[student@workstation ansible]$ ansible-navigator run soft.yml -m stdout 关闭运行playbook时生成的日志123456789[student@workstation ansible]$ vim ~/.ansible-navigator.yml---ansible-navigator: execution-environment: image: utility.lab.example.com/ee-supported-rhel8:latest pull: policy: missing playbook-artifact: enable: false #关闭playbook时生成的日志 调整tab键缩进 1.为了方便后期编写剧本，建议调节缩进(可选) 2.整体缩进–方便对齐yaml语法文本缩进(必选) 12345678910111213141516171819vim ~/.vimrcset tabstop=2 #将vim的tab键缩进调至两格set nu #设置行号set autoindent #回车时调整至上一行文本缩进 set cursorcolumn #设置竖坐标线 简写set cucset cursorline #设置横坐标线 简写set cul:set all #末行模式下set all 查看所有环境设置帮助#整体缩进 视图模式ctrl+v ， jjj(+G) ，I，(空格、空格)，esc分解：1.光标放在需要调节的行上2.按ctrl+v，用方向键或G选定需要调节的列3.输入I进入插入模式4.空格空格，调节需要的缩进5.按esc同步所有列 查找用于任务的模块用Ansible进行部署任务时，可针对管理员任务需求，选择对应功能模块，通过以下方法可以查询模块帮助，以便编写临时命令及playbook 12345678910111213141516171819202122232425-RHEL&lt;=8[student@workstation ansible]$ ansible-doc -l[student@workstation ansible]$ ansible-doc -l | grep yumyum Manages packages with the `y...yum_repository Add or remove YUM repositori...# 查看某个模块的帮助[student@workstation ansible]$ ansible-doc yum-RHEL=9$ ansible-navigator collections$ ansible-navigator doc ansible.posix.firewalld$ ansible-navigator doc ansible.posix.firewalld -m stdout[student@workstation ansible]$ ansible-navigator collections -m stdout | grep firewalld- full_name: ansible.posix.firewalld path: /usr/share/ansible/collections/ansible_collections/ansible/posix/plugins/modules/firewalld.py short_description: Manage arbitrary ports/services with firewalld - full_name: ansible.posix.firewalld_info path: /usr/share/ansible/collections/ansible_collections/ansible/posix/plugins/modules/firewalld_info.py short_description: Gather information about firewalld[student@workstation ansible]$ ansible-navigator doc ansible.posix.firewalld -m stdout#两个考试都可用，推荐优先用RHEL8版本的，用法方便。#找不到模块时就需要用RHEL9版本的，怕麻烦可以选择统一都用RHEL9版本的方法，省事 运行Playbook运行前建议使用语法检查验证语法错误:ansible-navigator run web.yml –syntax-check file.yml 或执行空运行ansible-navigator run web.yml -C 通常直接运行ansible-navigator run web.yml进入交互模式，或添加-m stdout可将任务打印到标准输出 1234#上节实验做了多清单实验，恢复为最初配置$ cd ~/ansible$ mv invdir/inventory . $ rm -rf invdir 123456#运行playbook$ ansible-navigator run web.yml # 交互式$ ansible-navigator run web.yml -m stdout # 非交互式[student@workstation ansible]$ lsansible.cfg ansible-navigator.log inventory soft.yml[student@workstation ansible]$ ansible-navigator run soft.yml -m stdout 2.4 实施多个Play​ Playbook是一个YAML文件，含有由一个或多个play组成的列表 ​ 如果一个playbook中含有多个 play，每个play可以将其任务应用到单独的一组主机 ​ 在编排可能涉及对不同主机执行不同任务的复杂部署时，这会大有帮助 ​ 可以这样编写playbook：对一组主机运行一个play，完成后再对另一组主机运行另一个play ​ 编写包含多个play的playbook非常简单 ​ Playbook中的各个play编写为playbook中的顶级列表项 编写多个Play123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[student@workstation ansible]$ vim install_yum.yml---- name: install yum repo hosts: servera,serverb tasks: - name: BaseOS_REPO ansible.builtin.yum_repository: name: Red Hat Enterprise Linux 9 for x86_64 - BaseOS (RPMs) description: BaseOS file: rhel_BaseOS baseurl: http://content.example.com/rhel9.0/x86_64/dvd/BaseOS gpgcheck: no - name: AppStream_REPO ansible.builtin.yum_repository: name: Red Hat Enterprise Linux 9 for x86_64 - AppStream (RPMs) description: AppStream file: rhel_AppStream baseurl: http://content.example.com/rhel9.0/x86_64/dvd/AppStream gpgcheck: no- name: install yum repo hosts: serverc tasks: - name: BaseOS_REPO ansible.builtin.yum_repository: name: Red Hat Enterprise Linux 9 for x86_64 - BaseOS (RPMs) description: BaseOS file: rhel_BaseOS baseurl: http://content.example.com/rhel9.0/x86_64/dvd/BaseOS gpgcheck: no #ansible-navigator collections,ansible-navigator doc ansible.posix.firewalld -m stdout[student@workstation ansible]$ ansible-navigator collections -m stdout | grep firewalld - full_name: ansible.posix.firewalld path: /usr/share/ansible/collections/ansible_collections/ansible/posix/plugins/modules/firewalld.py short_description: Manage arbitrary ports/services with firewalld - full_name: ansible.posix.firewalld_info path: /usr/share/ansible/collections/ansible_collections/ansible/posix/plugins/modules/firewalld_info.py short_description: Gather information about firewalld[student@workstation ansible]$ ansible-navigator doc ansible.posix.firewalld -m stdout--syntax-check [student@workstation ansible]$ ansible-navigator run install_yum.yml -m stdout --syntax-checkplaybook: /home/student/ansible/install_yum.yml-v -vv -vvv[student@workstation ansible]$ ansible-navigator run install_yum.yml -m stdout --syntax-check -vUsing /home/student/ansible/ansible.cfg as config fileplaybook: /home/student/ansible/install_yum.yml[student@workstation ansible]$ ansible-navigator run install_yum.yml -m stdout# 测试运行剧本后的结果[student@workstation ansible]$ ansible -m shell all -a 'yun -y install ftp'[student@workstation ansible]$ ansible all -m shell -a 'rpm -q ftp'serverd | CHANGED | rc=0 &gt;&gt;ftp-0.17-89.el9.x86_64serverc | CHANGED | rc=0 &gt;&gt;ftp-0.17-89.el9.x86_64serverb | CHANGED | rc=0 &gt;&gt;ftp-0.17-89.el9.x86_64servera | CHANGED | rc=0 &gt;&gt;ftp-0.17-89.el9.x86_64以上实验，用ansible-doc 查询课程中的所有模块yum 安装软件service 管理服务shell模块 管理防火墙copy 拷贝，1有拷贝功能，2 可以将一段文本，复制到某个文件中，如文件不存在，则生成文件。uri 网站连接测试 选择模块 类别 模块 文件 ansible.builtin.copy: 将本地文件复制到受管主机ansible.builtin.file: 设置文件的权限和其他属性ansible.builtin.lineinfile: 确保特定行是否在文件中ansible.posix.synchronize: 使用rsync 同步内容 软件 ansible.builtin.package: 使用操作系统自带的自动检测软件包管理器管理软件包。ansible.builtin.dnf: 使用DNF软件包管理器管理软件包ansible.builtin.apt: 使用APT 软件包管理器管理软件包ansible.builtin.pip: 从PyPI管理Python 软件包。 系统 ansible.posix.firewalld: 使用firewalld 管理任意端口和服务ansible.builtin.reboot: 重新启动计算机。ansible.builtin.service: 管理服务ansible.builtin.user: 添加、删除和管理用户帐户 网络工具 ansible.builtin.get_url: 通过HTTP、HTTPS或FTP 下载文件ansible.builtin.uri: 与Web 服务交互 3 管理变量和事实3.1 管理变量Ansible变量简介​ Ansible支持利用变量来存储值，并在Ansible项目的所有文件中重复使用这些值 ​ 可以简化项目的创建和维护，并减少错误的数量 1234567#key：vaule 变量可以重复的应用到项目中，简化管理，应用对象可以是：1.要创建的用户2.要安装的软件包3.要重新启动的服务4.要删除的文件5.互联网的文档等 命名变量​ 变量的名称必须以字母开头，并且只能含有字母、数字和下划线 无效变量名称 有效变量名称 web server web_server remote.file remote_file 1st file file_1，file1 remoteserver $1 remote_server_1,remote_server1 定义变量​ 可在Ansible项目中的多个位置定义变量 ​ 如果在两个位置设置了同名变量，并且变量值不同，则通过优先级来决定要使用哪个值​ 可以设置会影响一组主机的变量，也可以设置只会影响个别主机的变量 ​ 有些变量是Ansible可以根据系统配置来设置的事实 ​ 有些变量可在playbook中设置，然后影响该playbook中的一个play，或者仅影响该play中的一项任务 ​ 可通过–extra-vars或-e选项并指定变量值 1#Ansible的变量可以定义在不同位置，根据需要设定，其中也有优先度 应用场景 描述 优先度 全局范围 命令行执行临时命令时指定的变量 -e key=vaule 高 play范围 playbook的Play部分或模块内部指定变量信息key: vaule 中 主机范围 清单中主机或主机组指定变量（主机 优先 主机组） 低 1.全局范围-命令行​ 清单变量可被playbook中设置的变量覆盖，这两种变量又可通过在命令行中传递参数到ansible-navigatorrun 命令来覆盖 ​ 在命令行上设置的变量称为额外变量 1234567#命令行使用变量优先级最高[student@workstation ansible]$ ansible servera -m shell -a whoami -e ansible_user=root -e ansible_password=redhatservera | CHANGED | rc=0 &gt;&gt;root#在执行playbook时指定变量[student@workstation ansible]$ ansible-navigator run install_yum.yml -m stdout -e ansible_user=root -e ansible_password=redhat 2.PlAY范围-Playbook​ 变量在Ansible Playbook中发挥着重要作用，可以简化playbook中变量数据的管理 ​ 编写play时，可以定义自己的变量，然后在任务中调用这些值 ​ 例如，可以使用值httpd来定义名为web_package的变量。然后，任务可以使用ansible.builtin.dnf模块调用该变量来安装httpd软件包 12345678910111213141516171819202122232425262728293031323334353637383940414243#playbook中可以在play位置使用vars直接定义变量，也可以通过vars_files加载包含变量的文件。#1.在playbook的play部分使用vars直接定义变量-vars[student@workstation ansible]$ vim web.yml---- name: PLAY1 hosts: servera vars: #vars关键字就是在playbook中设置自定义变量 - package: httpd #key：vaule 键值间：冒号隔开，冒号后有一个空格 tasks: - name: install {{ package }} ansible.builtin.yum: name: &quot;{{ package }}&quot; #使用变量时，变量两边有空格，并且用双大括号括起来，变量开头要加“”双引号，非变量开头不用加双引号 state: latest [student@workstation ansible]$ ansible-navigator run web.yml -m stdout --syntax-checkplaybook: /home/student/ansible/web.yml[student@workstation ansible]$ ansible-navigator run web.yml -m stdout#2.生成变量文件-vars_files [student@workstation ansible]$ vim /home/student/ansible/var.yml ---package: httpd #定义变量[student@workstation ansible]$ vim /home/student/ansible/httpd.yml---- name: PLAY2 hosts: serverb vars_files: - /home/student/ansible/var.yml #vars_files 加载变量文件到剧本中 tasks: - name: install {{ package }} ansible.builtin.yum: name: &quot;{{ package }}&quot; state: latest [student@workstation ansible]$ ansible-navigator run httpd.yml -m stdout --syntax-checkplaybook: /home/student/ansible/httpd.yml[student@workstation ansible]$ ansible-navigator run httpd.yml -m stdout 3.主机范围-清单中(主机变量和组变量)​ 直接应用于主机的清单变量分为两大类: ​ 1.主机变量，应用于特定主机 ​ 2.组变量，应用于一个主机组或组主机组中的所有主机。 ​ 主机变量优先于组变量，但playbook中定义的变量的优先级比这两者更高 ​ 若要定义主机变量和组变量，一种方法是直接在清单文件中定义 123456789101112131415161718[student@workstation ansible]$ vim /home/student/ansible/inventory172.25.250.9 ansible_password=redhat #给主机定义变量 #模拟考试环境中密码是flectrag[test]172.25.250.10 [test:vars] #主机组变量中vars是固定语法ansible_password=redhat #给主机组定义变量 #模拟考试环境中密码是flectrag[prod]172.25.250.[11:12][balancers]172.25.250.13[all:vars] #给所有主机和主机组组定义变量ansible_user=rootansible_password=redhat #模拟考试环境中密码是flectrag 4.使用目录填充主机和组变量​ 定义主机和主机组变量的首选做法是在清单文件或目录相同的工作目录中，创建group_vars和host_vars两个目录。这两个目录分别包含用于定义组变量和主机变量文件 ​ 建议在host_vars和group_vars目录定义清单变量，而不是直接在清单文件中定义他们 字典形式表示变量​ 除了将与同一元素相关的配置数据分配到多个变量外，管理员也可以使用字典 ​ 字典是一个包含键值对的数据结构，其中的值也可以是字典 1.同一元素相关变量的键值关系123456user1_A_name: zhanguser1_B_name: sanuser1_C_name: /home/zhangsanuser2_A_name: liuser2_B_name: siuser2_C_name: /home/lisi 2.字典形式1234567891011vim vari.yml---users: user1: A_name: zhang B_name: san C_name: /home/zhangsan user2: A_name: li B_name: si C_name: /home/lisi 3.调用变量123456789101112131415161718192021例子：调用数组#调用变量方法1： users.user1.A_name users.user2.B_name#调用变量方法2： 应用方法2：python字典 users['user1']['A_name'] # [student@bastion ansible]$ vim user.yml---- name: useradd hosts: dev vars_files: - vari.yml tasks: - name: Add the user ansible.builtin.user: name: &quot;{{ users.user1.A_name }}{{ users.user1.B_name }}&quot; home: &quot;{{ users['user1']['C_name'] }}&quot; 使用已注册变量捕获命令输出​ register用来捕获命令输出或有关模块执行的其他信息。输出会保存至一个变量中，稍后可用于调试或其他目的。 12345678910111213141516$ vim register.yml---- name: install a packages hosts: servera tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest register: install_result #register字段负责收集变量 install_result自定义变量名被收集变量名 - name: message ansible.builtin.debug: var: install_result #debug模块var选项打印register获取install_result变量值#验证$ ansible-navigator run -m stdout register.yml 3.2 管理机密-vault介绍Ansible-vault​ Ansible可能需要访问密码或API密钥等敏感数据，以配置受管主机。通常，此信息会以纯文本形式存储在清单变量或其他Ansible文件中。但若如此，任何有权访问Ansible文件的用户或存储这些Ansible文件的版本控制系统都能够访问此敏感数据。这显然存在安全风险 ​ 使用Ansible随附的Ansible Vaut可以加密和解密任何由Ansible使用的数据文件。若要使用Ansible Vaut，可通过一个名为ansible-vault的命令行工具创建、编辑、加密、解密和查看文件 ​ Ansible Vault可以加密任何由Ansible使用的数据文件。这可能包括清单变量、playbook中含有的变量文件、在执行playbook时作为参数传递的变量文件，或者Ansible角色中定义的变量 123456789101112[student@workstation ~]$ ansible-vault --helpusage: ansible-vault [-h] [--version] [-v] {create,decrypt,edit,view,encrypt,encrypt_string,rekey} ...encryption/decryption utility for Ansible data filespositional arguments: {create,decrypt,edit,view,encrypt,encrypt_string,rekey} create Create new vault encrypted file #创建密码文件 decrypt Decrypt vault encrypted file #解密现有密码文件 edit Edit vault encrypted file #编辑现有密码文件 view View vault encrypted file #查看加密文件 encrypt Encrypt YAML file #加密现有文件 encrypt_string Encrypt a string rekey Re-key a vault encrypted file #更改加密文件的密码 1 创建与查看加密文件123456789101112131415161718192021[student@workstation ansible]$ pwd/home/student/ansible#创建加密文件-create[student@workstation ansible]$ ansible-vault create sec1.txt #默认sec1.txt不存在，通过该命令生成New Vault password: redhatConfirm New Vault password: redhat[student@workstation ansible]$ cat sec1.txt$ANSIBLE_VAULT;1.1;AES256353331313634363638366264313362303535326134376238623163613131306463386131633932666234663835643533336635323435313064386363303337650a663261613334653066373463663230316433326364353830633535356261666266323130346363356437663266383431343566636537616330663638613335340a66333763613266336264653165353762666536306432386461393638613632323636366431666130386333346236643033373062303938303937383436326232#查看加密文件-view[student@workstation ansible]$ ansible-vault view sec1.txtVault password: redhat---This is a encrypted file! 2 编辑现有的加密文件1234567891011#编辑加密文件-edit[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ ansible-vault edit sec1.txtVault password:[student@workstation ansible]$ ansible-vault view sec1.txtVault password:---This is a encrypted file!password: redhat321 3 加密现有的文件123456789101112131415161718192021222324[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ echo China &gt; sec2.txt #创建文件[student@workstation ansible]$ cat sec2.txt China#加密现有文件-encrypt[student@workstation ansible]$ ansible-vault encrypt sec2.txt New Vault password: redhatConfirm New Vault password: redhatEncryption successful[student@workstation ansible]$ cat sec2.txt$ANSIBLE_VAULT;1.1;AES256393331636135643434373534663565366664376339376165336232316335613135373466333636306535653834383263356261623737376131333237643330610a313134373235336430316139623035633239353565653135363831643439383666396630363232646666363539623431336365343966356566656361323462650a3431396532633862303939383465656266343033353132626266396537373562[student@workstation ansible]$ ansible-vault view sec2.txtVault password:China 4 解密现有的文件12345678#解密现有的文件-decrypt[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ ansible-vault decrypt sec2.txtVault password: redhatDecryption successful[student@workstation ansible]$ cat sec2.txtChina 5 更改加密文件的密码123456789101112131415#更改加密文件的密码-rekey[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ ansible-vault rekey sec1.txtVault password: redhat #旧密码 redhatNew Vault password: redhat321 #新密码 redhat321 Confirm New Vault password: redhat321 #重复新密码 redhat321Rekey successful[student@workstation ansible]$ ansible-vault view sec1.txtVault password: redhat321---This is a encrypted file!password: redhat321 6 使用密码文件12345678910111213141516171819#查看帮助[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ ansible-vault view sec1.txt --help---省略--- --vault-id VAULT_IDS the vault identity to use --ask-vault-password, --ask-vault-pass ask for vault password --vault-password-file VAULT_PASSWORD_FILES, --vault-pass-file VAULT_PASSWORD_FILES vault password file---省略---[student@workstation ansible]$ echo redhat321 &gt; secret.txt #创建密码文件[student@workstation ansible]$ cat secret.txtredhat321[student@workstation ansible]$ ansible-vault view sec1.txt --vault-id=secret.txt #通过变量文件指定密码---This is a encrypted file!password: redhat321 7 密码文件记录到ansible.cfg配置文件中1密码文件记录在ansible.cfg配置文件中的好处是，当执行一个使用了加密文件的playbook时，不必手工指定加密文件密码。 1234567891011121314151617181920212223242526[student@workstation ansible]$ pwd/home/student/ansible[student@workstation ansible]$ vim ansible.cfg #第一次填写vault路径时，搜索`vault`关键字找该选项vault_password_file=/home/student/ansible/secret.txt #配置文件中指定密码文件位置 [student@workstation ansible]$ ansible-vault view sec1.txt #自动调用配置文件中密码文件---This is a encrypted file!password: redhat321#密码文件记录在配置文件中后1.加密现有文件时会直接引用[student@workstation ansible]$ ansible-vault encrypt sec2.txtEncryption successful2.更改密码时会直接覆盖[student@workstation ansible]$ ansible-vault rekey sec2.txtRekey successful3.更改密码需使用--ask-vault-password参数指定[student@workstation ansible]$ ansible-vault rekey sec2.txt --ask-vault-passwordVault password: redhatNew Vault password: redhatConfirm New Vault password: redhatRekey successful 3.3 管理事实facts​ Ansible事实是Ansible在受管主机上自动检测到的变量。事实中含有与主机相关的信息，可以像play中的常规变量、条件、循环或依赖于从受管主机收集的值的任何其他语句那样使用。​ 为受管主机收集的一些事实可能包括:​ 主机名称、内核版本、网络接口名称、网络接口IP地址、操作系统版本、CPU数量提供的或可用的内存、存储设备的大小和可用空间 ​ 借助事实，可以方便地检索受管主机的状态，并根据该状态确定要执行的操作。例如: ​ 1.根据含有受管主机当前内核版本的事实运行条件任务，以此来重新启动服务器 ​ 2.根据通过事实报告的可用内存来定义MySQL配置文件​ 3.根据事实的值设置配置文件中使用的IPv4地址​ 通常，每个play在执行第一个任务之前会先自动运行setup模块来收集事实。这在Ansible2.3中报告为GatheringFacts任务，或者更早版本中报告为setup。默认情况下，无需具有在play中运行setup的任务，通常会自动运行​ 查看受管主机收集的事实的方式是: ​ 1.使用ad-hoc命令运行setup模块 ​ 2.使用playbook运行debug模块并提取变量var: ansible facts 收集事实1#收集事实常用两种手段常用是临时命令ad-hoc及Playbook，事实以josn语法格式列出。收集时要找ansible_开头的事实名称 123# 如果变量值为散列/字典，则可以用两种语法来检索该值:ansible_default_ipv4.hostnameansible_default_ipv4.[ 'hostname' ] 1 临时命令 ad-hoc123456789101112131415161718192021222324252627282930313233343536373839401.使用ad-hoc方式收集事实[student@workstation ansible]$ ansible -m setup all #收集清单中所有主机的事实[student@workstation ansible]$ ansible -m setup servera[student@workstation ansible]$ ansible -m setup servera -a filter=ansible_nodename #过滤servera | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;ansible_nodename&quot;: &quot;servera.lab.example.com&quot;, &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false}[student@workstation ansible]$ ansible -m setup serverc -a filter=*ipv4* #过滤&amp;模糊匹配serverc | SUCCESS =&gt; { &quot;ansible_facts&quot;: { &quot;ansible_all_ipv4_addresses&quot;: [ &quot;172.25.250.12&quot; ], &quot;ansible_default_ipv4&quot;: { &quot;address&quot;: &quot;172.25.250.12&quot;, &quot;alias&quot;: &quot;eth0&quot;, &quot;broadcast&quot;: &quot;172.25.250.255&quot;, &quot;gateway&quot;: &quot;172.25.250.254&quot;, &quot;interface&quot;: &quot;eth0&quot;, &quot;macaddress&quot;: &quot;52:54:00:00:fa:0c&quot;, &quot;mtu&quot;: 1500, &quot;netmask&quot;: &quot;255.255.255.0&quot;, &quot;network&quot;: &quot;172.25.250.0&quot;, &quot;prefix&quot;: &quot;24&quot;, &quot;type&quot;: &quot;ether&quot; }, &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot; }, &quot;changed&quot;: false}[student@workstation ansible]$ ansible -m setup serverc &gt; fact.txt #将事实记录到fact.txt文件中，方便后期查找事实[student@workstation ansible]$ ll fact.txt-rw-r--r--. 1 student student 25988 Mar 11 01:55 fact.txt[student@workstation ansible]$ pwd/home/student/ansible 2 PLAYBOOK 收集事实12345678910111213141516171819202122232425262728293031[student@workstation ansible]$ vim debug.yml---- name: debug hosts: servera tasks: - ansible.builtin.debug: msg: servera ip address &quot;{{ ansible_default_ipv4.address }}&quot; #简化后可将ansible_facts去掉，二级变量开头，要保留ansible_,如：ansible_default_ipv4.address - ansible.builtin.debug: var: ansible_hostname [student@workstation ansible]$ ansible-navigator run debug.yml -m stdout --syntax-checkplaybook: /home/student/ansible/debug.yml[student@workstation ansible]$ ansible-navigator run debug.yml -m stdoutPLAY [debug] ************************************************************************************************************************************************TASK [Gathering Facts] **************************************************************************************************************************************ok: [servera]TASK [ansible.builtin.debug] ********************************************************************************************************************************ok: [servera] =&gt; { &quot;msg&quot;: &quot;servera ip address \\&quot;172.25.250.10\\&quot;&quot;}TASK [ansible.builtin.debug] ********************************************************************************************************************************ok: [servera] =&gt; { &quot;ansible_hostname&quot;: &quot;servera&quot;}PLAY RECAP **************************************************************************************************************************************************servera : ok=3 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 3 关闭事实12345678910111213[student@workstation ansible]$ vim debug.yml---- name: debug message hosts: dev gather_facts: on/off true/false tasks: - debug: msg: &quot;{{ ansible_facts.default_ipv4.address }}&quot; [greg@bastion ansible]$ ansible-playbook debug.yml#如果playbook内容和事实收集没有关系，关闭可以大量减少playbook执行时间。#备注:RHCE考试时不要关闭 魔法变量1#实时变量通常收集的是受管节点的信息，而魔法变量收集的是本机的变量值，先了解课上的4个魔法变量功能，后面再看使用场景。 1234567891011121314151617181920212223242526#inventory_hostname 列出组在清单中的主机名[student@workstation ansible]$ ansible web -m debug -a var=inventory_hostnameserverb | SUCCESS =&gt; { &quot;inventory_hostname&quot;: &quot;serverb&quot;}serverc | SUCCESS =&gt; { &quot;inventory_hostname&quot;: &quot;serverc&quot;}#group_names 列出当前主机归属于哪个组[student@workstation ansible]$ ansible serverd -m debug -a var=group_namesserverd | SUCCESS =&gt; { &quot;group_names&quot;: [ &quot;db&quot;, &quot;servers&quot; ]}#groups 列出清单中的所有主机名称。以及所在组[student@workstation ansible]$ ansible all -m debug -a var=groups#hostvars 列出系统中所有魔法变量及所有事实变量[student@workstation ansible]$ ansible all -m debug -a var=hostvars$ https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html #官网文档# dosc.ansible.com中搜索magic或facts 1 临时命令收集魔法变量值 ad-hoc12345ansible servera -m debug -a var=inventory_hostnameansible servera -m debug -a var=groupsansible all -m debug -a var=group_namesansible all -m debug -a var=hostvarsansible servera -m debug -a var=groups.all 2 PLAYBOOK收集事实+魔法变量12345678910111213141516[student@workstation ansible]$ vim hoc_debug.yml---- name: debug hosts: servera gather_facts: on tasks: - ansible.builtin.debug: var: hostvars[student@workstation ansible]$ ansible-navigator run hoc_debug.yml -m stdout --syntax-checkplaybook: /home/student/ansible/hoc_debug.yml[student@workstation ansible]$ ansible-navigator run hoc_debug.yml -m stdout#重定向到文件中的意义是方便在hoc_fact.txt文件中搜索需要的值[student@workstation ansible]$ ansible-navigator run hoc_debug.yml -m stdout &gt; hoc_fact.txt 3 魔法变量hostvars 临时命令与playbook收集hostvars变量值是不同的 临时命令不会执行setup模块，所以收集不到事实，PLAYBOOK方法则可以收集到事实和魔法变量 1[student@workstation ansible]$ ansible all -m setup &gt; all_host.txt 4 实施任务控制4.1 编写循环和条件任务利用循环迭代任务​ 通过利用循环，管理员无需编写多个使用同一模块的任务。例如，不必编写五个任务来确保存在五个用户，而是只需编写一个任务来对含有五个用户的列表迭代，从而确保他们都存在​ Ansible支持使用loop关键字对一组项目迭代任务。可以配置循环以利用列表中各个项目、列表中各个文件的内容、生成的数字序列或更为复杂的结构来重复任务。 123#loop字段通常在同一缩进的模块下面，对该模块生效，通过item来加载loop循环中的值或变量#帮助：搜索loop可以搜到相应语法$ https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html 1 简单循环 简单循环对一组项目迭代任务 loop 关键字添加到任务中，将应对其迭代任务的项目列表取为值 循环变量item保存每个迭代过程中使用的值 12345678910111213141516171819202122232425262728293031323334#1.无循环[student@workstation ansible]$ vim loop.yml---- name: service hosts: servera tasks: - name: Start service nfs-server ansible.builtin.service: name: nfs-server state: started - name: Start service chronyd ansible.builtin.service: name: chronyd state: started #2.使用循环[student@workstation ansible]$ vim loop.yml---- name: service hosts: servera tasks: - name: Start service nfs-server&amp;chronyd ansible.builtin.service: name: &quot;{{ item }}&quot; state: started loop: - nfs-server - chronyd [student@workstation ansible]$ ansible-navigator run loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/loop.yml[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout 2 循环使用变量 在playbook中通过vars或vars files方式加载变量servers中包含循环列表，模块通过loop字段加载servers变量列表中的值。 123456789101112131415161718192021222324252627282930313233343536373839#vars字段[student@workstation ansible]$ vim loop.yml---- name: service loop hosts: servera vars: servers: - nfs-server - chronyd tasks: - name: Start service ansible.builtin.service: name: &quot;{{ item }}&quot; state: stopped loop: &quot;{{ servers }}&quot; #vars字段也可以替换为vars_files，将变量保存至文件中，加载到Playbook [student@workstation ansible]$ mkdir /home/student/ansible/vars/[student@workstation ansible]$ vim /home/student/ansible/vars/var.ymlservers:- nfs-server- chronyd[student@workstation ansible]$ vim loop.yml---- name: service loop hosts: servera vars_files: - /home/student/ansible/vars/var.yml tasks: - name: Start service ansible.builtin.service: name: &quot;{{ item }}&quot; state: stopped loop: &quot;{{ servers }}&quot;[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/loop.yml[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout 3 循环字典列表123456789101112131415161718192021#循环字典列表保存在loop字段中[student@workstation ansible]$ vim loop.yml---- name: service loop hosts: servera tasks: - name: Start service ansible.builtin.user: name: &quot;{{ item.name }}&quot; comment: &quot;{{ item.comment }}&quot; state: present loop: - name: jane comment: tom - name: joe comment: harry [student@workstation ansible]$ ansible-navigator run loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/loop.yml[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout 1234567891011121314151617181920212223#循环字典列表保存在play的vars中 [student@workstation ansible]$ vim loop.yml---- name: service loop hosts: servera vars: users: - name: jane comment: tom - name: joe comment: harry tasks: - name: Start service ansible.builtin.user: name: &quot;{{ item.name }}&quot; comment: &quot;{{ item.comment }}&quot; state: present loop: &quot;{{ users }}&quot;[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/loop.yml[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout 123456789101112131415161718192021222324252627#循环字典列表保存在play的vars_files中 [student@workstation ansible]$ vim /home/student/ansible/vars/var.ymlservers:users:- name: jane comment: tom- name: joe comment: harry[student@workstation ansible]$ vim loop.yml---- name: service loop hosts: servera vars_files: - /home/student/ansible/vars/var.yml tasks: - name: Start service ansible.builtin.user: name: &quot;{{ item.name }}&quot; state: present comment: &quot;{{ item.comment }}&quot; loop: &quot;{{ users }}&quot; [student@workstation ansible]$ ansible-navigator run loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/loop.yml[student@workstation ansible]$ ansible-navigator run loop.yml -m stdout 有条件地运行任务 ​ Ansible可使用conditionals在符合特定条件时运行任务或play。例如，可以使用条件句在Ansible安装或配置某个服务之前，确定受管主机上的可用内存。 ​ 条件句可帮助区分不同的受管主机，并根据所符合的条件来分配功能角色 ​ Playbook变量、注册的变量和Ansible事实都可通过条件句来进行测试。可以使用比较字符串、数字数据和布尔值的运算符。 1#应用场景：通常主机模式为多个节点时，可以让符合when条件的主机执行模块任务。符合条件则为真，则执行模块。否则为假，跳过模块任务 ​ when判断对象是模块，和模块在同一下列层次 ​ when判断当前模块是否执行，而不是它下面模块是否执行 ​ When中引用变量、facts，不需加大括号 ​ 用于测试条件中相等的==运算符不可与变量赋值的=运算符混淆 ​ 一个when语句可用于评估多个值。 可以使用and和or关键字组合条件，或使用括号分组条件 ​ 1.or是或的关系，任意一个条件为真即可 1when: ansible_distribution == &quot;RedHat&quot; or ansible_distribution == &quot;Fedora&quot; ​ 2.and是与的关系，多个条件需同时为真 1when: ansible_distribution version == &quot;7.5&quot; and ansible_kernel == &quot;3.10.0-327.el7.x86_64&quot; ​ When语句多条件的另外方式: 123when: -ansible_distribution_version == &quot;7.5&quot; -ansible_kernel == &quot;3.10.0-327.el7.x86_64&quot; ​ 使用括号分组条件来表达更复杂的条件语句: 123456when: &gt; ( ansible_distribution == &quot;RedHat&quot; and ansible_distribution_major_version == &quot;7&quot;) or ( ansible_distribution == &quot;Fedora&quot; and ansible_distribution_major_version == &quot;28&quot;) 简单的有条件任务示例:1234567891011121314151617181920212223242526272829303132[student@workstation ansible]$ vim when.yml---- name: repository hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest when: ansible_default_ipv4.address == '172.25.250.10' [student@workstation ansible]$ ansible-navigator run when.yml -m stdout --syntax-checkplaybook: /home/student/ansible/when.yml[student@workstation ansible]$ ansible-navigator run when.yml -m stdout[student@workstation ansible]$ vim when-vdb.yml---- name: repository hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest when: ansible_devices.vdb is defined[student@workstation ansible]$ ansible-navigator run when-vdb.yml -m stdout --syntax-checkplaybook: /home/student/ansible/when-vdb.yml[student@workstation ansible]$ ansible-navigator run when-vdb.yml -m stdout#如果使用inventory_hostname这个魔法变量，要参考清单中的主机名称。node1位置，单双引号都可以识别为字符串 组合循环和有条件任务示例：123456789101112131415161718192021222324252627282930313233[student@workstation ansible]$ vim when_loop.yml---- name: 安装软件包 hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: &quot;{{ item }}&quot; state: latest loop: - php - mariadb when: ansible_hostname == 'servera' or ansible_hostname == 'serverc' [student@workstation ansible]$ ansible-navigator run when_loop.yml -m stdout --syntax-checkplaybook: /home/student/ansible/when_loop.yml[student@workstation ansible]$ ansible-navigator run when_loop.yml -m stdout[student@workstation ansible]$ vim when_loop2.yml---- name: repository hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: &quot;{{ item }}&quot; state: latest loop: - mariadb when: '&quot;52:54:00:00:fa:0a&quot; in ansible_default_ipv4.macaddress'[student@workstation ansible]$ ansible-navigator run when_loop2.yml -m stdout --syntax-checkplaybook: /home/student/ansible/when_loop2.yml[student@workstation ansible]$ ansible-navigator run when_loop2.yml -m stdout 常用when条件语句123456789101112131415161718192021222324252627[student@workstation ansible]$ ansible all -m debug -a var=groups[student@workstation ansible]$ ansible all -m debug -a var=group_names#变量值 == '字符串'inventory_hostname == 'node1'inventory_hostname != 'node1''&quot;52:54:00:00:fa:0b&quot; in ansible_default_ipv4.macaddress'ansible_default_ipv4.address == '172.25.250.11'#变量值存在 in 第二个变量inventory_hostname in groups.dev #可以匹配组'&quot;dev&quot; in group_names' #可以匹配[student@workstation ansible]$ vim when_loop3.yml---- name: repository hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest when: '&quot;db&quot; in group_names'[student@workstation ansible]$ ansible-navigator run when_loop3.yml -m stdout --syntax-checkplaybook: /home/student/ansible/when_loop3.yml[student@workstation ansible]$ ansible-navigator run when_loop3.yml -m stdout#default变量查询方法#搜索引擎中搜索：filters --- Using filters to --- 搜索admin---default('admin', true) 4.2 实施处理程序​ handlers是处理程序的一种实现，当对一个Playbook模块改动时，通过监控发现改动，并自动执行后续处理动作。帮助管理员节省管理成本。​ 比如一种场景，当修改了服务配置文件时，需要对服务进行重启。可以在配置文件模块位置用notify监视是否修改后，用handlers中的处理程序如:service模块对其重启服务。达到修改文件便自动重启服务的效果。 Ansible处理程序123456789101112131415161718192021222324$ vim handlers.yml---- name: hosts: servera tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest - name: Copy using inline content ansible.builtin.copy: content: 'heihei' dest: /var/www/html/index.html notify: restart #notify字段冒号后的名称restart，指向handlers中的描述为restart的模块 - name: Start firewalld ansible.builtin.service: name: firewalld state: started handlers: #handlers是缩进和tasks对齐 - name: restart ansible.builtin.service: name: httpd state: restarted 4.3 执行中对错误的处理​ Ansible评估各任务的返回代码，从而确定任务是成功还是失败​ 通常而言，当任务失败时，ansible将立即在该主机上终止play的其余部分并且跳过所有后续任务​ 有些时候，可能希望即使在任务失败时也继续执行play ignore_errors忽略任务失败 ignore_errors 123456789101112131415161718192021222324252627[student@workstation ansible]$ vim ignore_errors.yml---- name: test error hosts: servera tasks: - name: touch directory ansible.builtin.shell: mkdir /a/b ignore_errors: yes - name: Add the user ansible.builtin.user: name: johnd [student@workstation ansible]$ ansible-navigator run ignore_errors.yml -m stdout --syntax-check[student@workstation ansible]$ ansible-navigator run ignore_errors.yml -m stdout#也可以在任务失败时强制执行处理程序,详见教材---- name: test error force_handlers: yes tasks: - xxxx handlers: - name: haha ansible.builtin.service: xxx xxx 4.4 Ansible块和错误的处理block、rescue、always 定义区域中失败的任务block:定义要运行的主要任务 rescue:定义要在block子句中定义的任务失败时运行的任务 always:定义始终都在独立运行的任务 12345678910111213141516171819202122---- name: block hosts: all tasks: - block: - name: ansible.builtin.yum: name: http state: present rescue: - name: ansible.builtin.yum: name: httpd state: present when: inventory_hostname == 'serverb' always: - name: Start service httpd, if not started ansible.builtin.service: name: httpd state: started#Ansible官方文档：搜索：rescue https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html block示例123456789101112131415161718192021222324252627#未使用block时：---- name: test error hosts: all tasks: - name: touch file ansible.builtin.shell: mkdir -p /a/b when: inventory_hostname == &quot;servera&quot; - name: Add the user ansible.builtin.user: name: johnd when: inventory_hostname == &quot;servera&quot;#使用block时---- name: test error hosts: all tasks: - block: - name: touch file ansible.builtin.shell: mkdir -p /a/b - name: Add the user ansible.builtin.user: name: johnd when: inventory_hostname == &quot;servera&quot; 5 将文件部署到受管主机5.1 修改文件并将其复制到主机文件模块介绍1.在被管机上创建文件和目录 2.复制文件(或内容)到被管机 control –&gt; node1 3.从被管机复制文件到管理机 node1 –&gt; control 4.修改文件内容 5.查看文件状态 6.修改文件属性(所有者、权限、selinux) 7.文件同步 ansible.builtin-描述文件模块 模块名 说明 blockinfile 插入、更新 、删除，自定义标记的多行文本块 file 设置权限、所有者、SElinux上下文及常规文件、符号连接、硬链接等 copy 远程copy，类似file，可以设置文件属性、SElinux上下文 fetch 和copy类似，相反工作方式，从远端拷贝到控制节点 lineinfile 改文件某一行时使用 stat 检测文件状态，类似linux中stat命令 synchronize 围绕rsync一个打包程序 12345#查找模块可使用命令$ ansible-doc -l | grep file$ ansible-navigator collections -m stdout | grep file$$ ansible-doc file#注意：很多模块已经不在ansible.builtin集合中了，所以需要通过ansible-navigator collections命令搜索。 ansible.builtin.file12345678910111213- name: Change file ownership, group and permissions ansible.builtin.file: path: /var/www/html/index.html owner: apache group: apache mode: '0644' state: touch setype: default_t #(Choices: absent, directory, file, hard, link, touch)[Default: file]#file：修改文件内容，无该文件则不修改#touch：创建文件#touch，mkdir，cp，mv，rm，ln，chmod，chown，chcon ansible.builtin.copy123456789101112131415#复制本机文件到受管节点- name: Copy file with owner and permissions ansible.builtin.copy: src: /srv/myfiles/foo.conf dest: /var/www/html/index.html owner: foo group: foo mode: '0644' setype: httpd_sys_content_t #复制文本内容testweb至目标文件，文件不存在则创建 - name: Copy using inline content ansible.builtin.copy: content: &quot;testweb&quot; dest: /var/www/html/index.html ansible.builtin.lineinfile1234567891011121314151617181920212223[student@workstation ansible]$ ansible-doc -l | grep linelineinfile Manage lines in text files[student@workstation ansible]$ ansible-doc lineinfile[student@workstation ansible]$ vim lineinfile.yml---- name: lineinfile hosts: all tasks: - name: Ensure SELinux is set to enforcing mode ansible.builtin.lineinfile: path: /etc/selinux/config regexp: '^SELINUX=' line: SELINUX=enforcing[student@workstation ansible]$ ansible-navigator run lineinfile.yml -m stdout --syntax-checkplaybook: /home/student/ansible/lineinfile.yml[student@workstation ansible]$ ansible-navigator run lineinfile.yml -m stdout#验证:[student@workstation ansible]$ ansible servera -m shell -a 'cat /etc/selinux/config'#docs.ansible.com 搜索引擎中搜索：filters --- Using filters to --- 搜索admin---default('admin', true) ansible.builtin.blockinfile12345678- name: Insert/Update HTML surrounded by custom markers after &lt;body&gt; line ansible.builtin.blockinfile: path: /opt/index.html marker: &quot;&lt;!-- {mark} ANSIBLE MANAGED BLOCK --&gt;&quot; insertafter: &quot;&lt;body&gt;&quot; block: | &lt;h1&gt;Welcome to {{ ansible_hostname }}&lt;/h1&gt; &lt;p&gt;Last updated on {{ ansible_date_time.iso8601 }}&lt;/p&gt; ansible.builtin.template12345678910- name: Template a file to /etc/files.conf ansible.builtin.template: src: /mytemplates/foo.j2 dest: /etc/file.conf- name: Download foo.conf ansible.builtin.get_url: #该模块可以将网络上的文件，直接下载至受管节点上。 url: http://materials/hosts.j2 #源文件 dest: /opt/host.txt #目标文件位置 5.2 使用Jinja2模板部署自定义文件jinja2简介​ ansible中可以使用jinja2模板对文件进行部署。再用template模块同步jinja2模板文件至受管节点。该模块和copy模块作用基本一样，都是把某个文件复制到被管主机上，但是区别在于template模块可以获取变量的值和使用循环。​ 1.管理文件通常会使用一些模块，copy，file，blockinfile，lineinfile​ 2.更好的配置文件管理方式是使用jinja2语法制作模板文件来生成最终使用的配置文件 ​ 3.jinja2模板文件内，可以通过多种方式编辑或构成，比如魔法变量、事实变量、普通字符、控制语句语法…​ 4.使用jinja2模板的方法是，先构建jinja2模板，再通过template模块将j2模板同步至受管节点 ​ 5.构建模板文件通常名称自定义，以.j2结尾，类似shell脚本的.sh、python脚本的.Py 1 使用分隔符123456789101112131415161718192021222324251、构建jinja2模板$ vim jin.j2 #文件名用.j2结尾127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6{# host file #} #描述，为管理员做提示作用。用户不可见haha {{ ansible_hostname }}2、通过templete模块，同步模板文件至受管主机，同时收集事实变量值，将结果生成至相应文件中。$ vim temp.yml---- name: sync file hosts: servera tasks: - name: Template a file to /etc/files.conf ansible.builtin.template: src: jin.j2 dest: /etc/myhosts$ ansible-navigator run temp.yml -m stdout3、在受管节点上查看文件结果$ ansible servera -m shell -a 'cat /etc/myhosts'servera | CHANGED | rc=0 &gt;&gt;hahaservera heihei servera.lab.example.com 2 管理模版文件1234567891011121、在配置文件中定义ansible_managed功能，添加描述信息：“Ansible hahaha”[greg@control ansible]$ vim ansible.cfg[defaults]ansible_managed = Ansible hahaha变量名 = 变量值2、在jinja2模板中调用该功能#vim jinja.j2{# host file #} #{##}注释客户端生成文件是不显示{{ ansible_managed }} #{{}}描述，客户端生成文件时会显示127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 控制结构-使用循环123456789101112131415161718-shellfor user in `ls /`;do echo $userdone-jinja2{% for user in users %} #user变量替换为users变量中的所有值，一行一个值。{{ user }}{% endfor %}#示例$ vim jinja2.j2{% for host in groups.all %} #使用for 或if 时控制结构使用{% %}{{ host }}{% endfor %}#查看语法帮助:官网或关键词搜索示例[student@workstation ansible]$ grep -r '{%' /etc 1文件的生成方法12345678$ vim debug.yml---- name: hosts: all tasks: - ansible.builtin.debug: var: hostvars$ ansible-navigator run debug.yml -m stdout &gt; 1.txt 生成/etc/hosts123456789101112131415161718192021222324252627282930313233343536373839401$ vim /home/student/ansible/temp.yml127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6{% for host in groups.all %}{{ hostvars[host].ansible_default_ipv4.address }} {{ hostvars[host].ansible_nodename }} {{ hostvars[host].ansible_hostname }} {% endfor %}2vim /home/student/ansible/temp.yml---- name: sync file hosts: all #一定要用all，因为要收集5台主机的事实变量 tasks: - name: Template a file to /etc/files.conf ansible.builtin.template: src: hosts.j2 dest: /etc/myhosts when: inventory_hostname in groups.dev #匹配dev组 $ ansible-navigator run temp.yml -m stdout$ ansible servera -m shell -a 'cat /etc/myhosts'servera | CHANGED | rc=0 &gt;&gt;127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.25.250.10 servera.lab.example.com servera172.25.250.11 serverb.lab.example.com serverb172.25.250.12 serverc.lab.example.com serverc172.25.250.13 serverd.lab.example.com serverd实验完毕[Discovering variables: facts and magic variables — Ansible Documentation](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html)网站中查找关键字：facts 选择：Discovering variables: facts and magic variables 然后搜索hostvars[host]以json格式查看：{{ hostvars[i]['ansible_facts'] | to_nice_json }} 6 管理大项目6.1 引用清单主机12345678使用主机模式的常见方式：1.[ad-hoc:]ansible dev -m shell 2.[playbook:]- name: hosts: dev 1234567891011121314151617181920212223242526271 清单里使用通配符匹配多个主机[START:END]192.168.[0:15].[0:255] 表示 192.168.0.0-192.168.15.255server[a:c].example.com 表示 a-cserver[01:15].example.com 表示 server01.example.com-server15ipv6也可以通过[a:f]这种方式all： 所有主机ungrouped ： 不属于任何一个组的所有主机2 主机模式其他方式hosts： allhosts： ungrouped#使用特殊字符时，必须添加单引号，否则不生效hosts： '*' 和all相同 hosts：'*.example.com'hosts：'datacenter*'#列表形式hosts：servera,serverb hosts：webserver,serverchosts：'devops,server*'#冒号：取代逗号hosts：lab,&amp;datacenter 匹配lab组同时也属于datacenter组，顺序无所谓&amp;符号时同时也属于的意思hosts：datacenter,!test2.example.com 表示datacenter组，但不包括test2.。。这个主机hosts：all,!datacenter1 所有组，但不包含datacenter1组 6.2 包含和导入文件管理大型Playbook123456如果playbook很长很复杂，可以拆分成较小的文件便于管理，以模块化管理，可以将多个不同功能的play，组合成一个主要的playbook，将文件中的任务列表插入play，这样可以将这种模块化的play应用到不同场景。playbook- httpd- php- mysql 1.导入Playbook123456789101112131415161718192021222324252627282930313233343536371.将两个playbook加入到主playbook$ vim one.yml ---- name: play1 hosts: node1 tasks: - name: Install the latest version of Apache ansible.builtin.yum: name: httpd state: latest $ vim two.yml ---- name: play2 hosts: node1 tasks: - name: Make sure a service unit is running ansible.builtin.systemd: state: started name: httpd enabled: yes 2.在主playbook中和其他play交替使用$ vim main.yml ---- name: four hosts: node1 tasks: - ansible.builtin.debug: msg: haha - name: one 因为加载的是playbook所以需要顶头写无缩进。 import_playbook: one.yml- name: two import_playbook: two.yml 包含与导入123Ansible可以支持两种方法将文件放入playbook中：包含：内容是一个动态操作。在playbook运行期间，Ansible会在内容到达时处理所包含的内容。导入：内容是一个静态操作。在运行开始之前，Ansible在最初解析playbook时预处理导入的内容。 1.包含和导入1234567包含：1.使用include_tasks功能时，包含时设置的when等条件语句将确定任务是否包含在play中2.如果运行ansible-playbook --list-tasks以列出playbook中的任务，则不会显示已包含任务文件中的任务。将显示包含任务文件的任务。相比之下，import_tasks功能不会列出导入任务文件的任务，而列出已导入任务文件中的各个任务#（[greg@control ansible]$ ansible-playbook playbook.yml --start-at-task webserver）3.不能使用ansible-playbook --start-at-task从已包含任务文件中的任务开始执行playbook#（[greg@control ansible]$ ansible-playbook playbook.yml --start-at-task webinstall）4.不能使用notify语句触发已包含任务文件中的处理程序名称。可以在包含整个任务文件的主playbook中触发处理程序，在这种情况下，已包含文件中的所有任务都将运行 1234导入：1.使用import_tasks功能时，导入时设置的when等条件语句将应用于导入的每个任务2.无法将循环用于import_tasks功能3.如果使用变量来指定要导入的文件的名称，则将无法使用主机或组清单变量 2.示例12345678910111213141516171819202122232425第一个tasks任务[greg@bastion ansible]$ mkdir tasks #tasks目录是自定义的，创建的目的只是方便存储管理tasks任务文件。[greg@bastion ansible]$ vim tasks/apache.yml #tasks任务文件，文件中没有主机模式---- name: ansible.builtin.yum: name: httpd state: latest第二个tasks任务[greg@bastion ansible]$ vim tasks/service.yml ---- name: ansible.builtin.service: name: httpd enabled: yes state: started 包含和导入的方式：[greg@bastion ansible]$ vim main.yml #此处main.yml是一个playbook，有主机模式---- name: hosts: node1 tasks: - include_tasks: tasks/apache.yml - import_tasks: tasks/service.yml 7 使用角色和Ansible collections简化Playbook7.1 描述角色结构123# Ansible中的角色，一个角色是一个结构化的目录组成，可以根据业务需要创建不同的角色，apache的、mysql的等# 角色的优势是类似将playbook分割成更小的模块，进行模块化管理，简化playbook# 除了自行编写、使用、重用和共享角色外，您也可以从其他来源获取角色。您可以使用分发包(如Ansible内容集合)查找角色 7.2 创建角色1234567在playbook的项目目录中创建一个角色，并将其作为playbook中某个play的一部分来运行1.yum install -y httpd yum模块2.index.html, fcontext copy模块3.httpd service service模块4.firewalld.service service模块5.firewalld permit apache firewalld模块# 使用web角色一键部署以上服务 角色创建流程12345创建和使用角色分四步进行:1.创建角色目录存储路径2.创建角色3.定义角色内容4.在playbook中使用角色 1.创建角色目录存储路径1234567891011121314151617181920212223242526272829303132333435363738394041#配置ansible.cfg文件中的roles-path,默认ansible会在roles子目录中查找角色#可以将自己的角色安装在~/ansible/roles子目录中1.默认路径：[student@workstation ansible]$ ansible-galaxy --helppositional arguments: TYPE collection Manage an Ansible Galaxy collection. role Manage an Ansible Galaxy role.[student@workstation ansible]$ ansible-galaxy role --help #查看角色的子命令帮助positional arguments: ROLE_ACTION init Initialize new role with the base structure of a role. remove Delete roles from roles_path. delete Removes the role from Galaxy. It does not remove or alter the actual GitHub repository. list Show the name and version of each role installed in the roles_path. search Search the Galaxy database by tags, platforms, author and multiple keywords. import Import a role into a galaxy server setup Manage the integration between Galaxy and the given source. info View more details about a specific role. install Install role(s) from file(s), URL(s) or Ansible Galaxy[student@workstation ansible]$ ansible-galaxy role list #新版本查看角色指令[student@workstation ansible]$ ansible-galaxy list #旧版本查看角色指令# /usr/share/ansible/roles -- 系统角色# /etc/ansible/roles -- 全局角色路径[WARNING]: - the configured path /home/student/.ansible/roles does not exist. --默认该目录不存在，需要的话可以根据需求创建`如果ansible无法找到该位置角色，会按照ansible.cfg中roles_path指定的目录中查找`1.创建角色目录存储路径 使用自定义工作目录时，创建自定义roles(角色)目录，并使用ansible.cfg中roles_path=字段指定角色路径[student@workstation ansible]$ pwd #进入自己的工作目录/home/student/ansible[student@control ansible]$ mkdir roles #创建存放角色的目录[student@control ansible]$ vim ansible.cfg roles_path=/home/student/ansible/roles #指定角色路径[student@workstation ansible]$ ansible-galaxy list #一定要在工作目录中使用查看命令，调用当前工作目录配置文件中的角色路径# /home/student/ansible/roles #查询结果应和配置文件的roles_path字段一致 2.创建角色12345678910111213141516171819202122232425262728[student@workstation ansible]$ ansible-galaxy role init roles/apache #创建角色- Role roles/apache was created successfully[student@workstation ansible]$ ansible-galaxy role list #列出所有角色# /home/student/ansible/roles- apache, (unknown version)[student@workstation ansible]$ tree roles/apache/roles/apache├── defaults #角色默认变量│ └── main.yml├── files #引用的静态文件，可以是一些文件、网页模板等├── handlers #处理程序，通常通过模块完成的│ └── main.yml├── meta #作者，许可、兼容性│ └── main.yml├── README.md├── tasks #任务，任务的组成就是模块应用，也是角色的主要功能│ └── main.yml├── templates #模板文件，通常使用jinja2模板├── tests #测试│ ├── inventory│ └── test.yml└── vars #角色变量 └── main.yml8 directories, 8 files#用不到的目录可以删除，如defaults、vars、tests 3.定义角色内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[student@control ansible]$ tree roles/apache (可选，方便查看路径信息)*[student@control ansible]$ vim roles/apache/tasks/main.yml #在tasks目录中完善角色内容---- name: install apache #编写角色时，任务中只有模块任务，没有PLAY ansible.builtin.yum: name: httpd state: latest- name: Start service httpd ansible.builtin.service: name: httpd state: started enabled: yes- name: create web page ansible.builtin.template: src: jin2.j2 #jin2.j2需要手动创建 dest: /var/www/html/index.html notify: - restart #需要时将调用handlers处理程序，需要手动创建，restart通知中的处理程序名要和handlers/main.yml中处理程序描述一致- name: Start service firewalld ansible.builtin.service: name: firewalld state: started enabled: yes - name: permit apache ansible.posix.firewalld: service: http permanent: yes state: enabled immediate: yes #ansible-navigator collections可以查看posix集合 #ansible-navigator doc ansible.posix.firewalld -m stdout #以上25-30行客替换为如下:- name: permit apache ansible.builtin.shell: firewall-cmd --permanent --add-service=http - name: permit apache ansible.builtin.shell: firewall-cmd --reload [student@control ansible]$ vim roles/apache/templates/jin2.j2 #编写模板文件ipadd={{ ansible_default_ipv4.address }} hostname={{ ansible_hostname }}[student@control ansible]$ vim roles/apache/handlers/main.yml #编写处理程序---- name: restart ansible.builtin.service: name: httpd state: restarted 4.在playbook中使用角色12345678910[student@bastion ansible]$ vim roles.yml---- name: hosts: servera roles: #roles字段用来调用角色 - apache #被调用角色的名称 - xxx[student@bastion ansible]$ ansible-navigator run -m stdout roles.yml [student@control ansible]$ curl serveraipadd=172.25.250.10 hostname=servera 7.3 从外部内容源部署角色​ 从Git存储库或AnsibleGalaxy 等外部资源中选择和检索角色，并在playbook中使用 ​ https://galaxy.ansible.com 1.外部内容来源12345678910111213141516角色有多种获取方式：本地tar包安装通过网络地址安装通过文件同时安装网络中多个地址角色（本课介绍）roles/requirements.yml- src： #角色网址 varsion：#角色版本 name：#安装在本地的角色名- src： name：ansible-galaxy role install -r roles/requirements.yml -p roles-r 指定文件路径-p 指定角色安装路径roles/requirements.yml 角色安装信息，包括地址，角色名称等。 练习 1234567891011121314151617181920212223242526#软件包参考班级群看板资料里：1.将phpinfo.tar,haproxy.tar上传到Linux，kiosk家目录下，用kiosk登录2.将两个角色包拷贝到foundation0的rhel9.0目录中$ ssh root@localhost cp /home/kiosk/{phpinfo.tar,haproxy.tar} /content/courses/rh294/rhel9.0/materials3.打开foundation0的浏览器输入http://172.25.254.254/materials/就可以看到两个软件包实验：[student@workstation ansible]$ mkdir roles[student@workstation ansible]$ $ vim ansible.cfg[defaults]roles_path=/home/student/ansible/roles[student@workstation ansible]$ vim roles/requirements.yml---- src: http://172.25.254.254/materials/haproxy.tar name: balancer- src: http://172.25.254.254/materials/phpinfo.tar name: phpinfo[student@workstation ansible]$ ansible-galaxy install -r roles/requirements.yml [student@workstation ansible]$ ansible-galaxy list# /home/student/ansible/roles- apache, (unknown version)- balancer, (unknown version)- phpinfo, (unknown version) 7.4 从内容集合获取角色和模块​ 从Ansible 内容集合中获取一组相关角色、补充模块和其他内容，并在playbook中使用 Ansible内容集合123#随着模块数量增加，管理困难。模块需要唯一名称，并保持更新。#借助Ansible内容集合，Ansible代码可以与模块和插件分开更新#Ansible 内容集合可提供一组您可在您的playbook中使用的相关模块、角色和其他插件。这种方法便于供应商和开发人员按照自己的节奏维护和分发集合，而不受Ansible版本的影响 1.Ansible内容集合的命名空间1234567891011#命名空间是集合名称的第一部分。#由Ansible社区维护的所有集合可能会放入community命名空间中名称类似于: community.crypto community.postgresql community.rabbitmq#红帽直接维护和支持的Ansible内容集合可能使用redhat命名空间有redhat.rhvredhat.satelliteredhat.insights等名称 2.选择Ansible内容集合的来源12345678910无论您是将ansible-navigator 用于最小自动化执行环境，还是在裸机Ansible Core上使用ansible-playbook，您始终至少有一个可用Ansible内容集合:ansible.builtin。此外，您的自动化执行环境可能还内置了其他自动化执行环境，例如，红帽Ansible 自动化平台2.2使用的默认执行环境ee-supported-rhel8。如果您需要其他Ansible内容集合，可以将其添加到Ansible 项目的collections 子目录中。您可以从多个来源获取Ansible内容集合:自动化中心私有自动化中心Ansible Galaxy第三方Git存储库或存档文件 3.安装Ansible内容集合12ansible配置文件ansible.cfg中设置了collections_paths选项来指定集合的默认路径：~/.ansible/collections;/usr/share/ansible/collections 如果消除这两个目录的指定，则ansible-navigator 无法在这些目录的其版本中找到自动化执行环境内提供的Ansible内容集合。 12345678$ ansible-galaxy collection install 集合 -p collections-p collections 选项会将该集合安装到本地collections 子目录中。或者不适用-p，而在ansible.cfg文件中collections_paths选项来指定集合的默认路径集合的来源可以是：本地 互联网git仓库 4.使用要求文件安装Ansible内容集合1234567891011121314151617181920212223242526271.将三个集合包上传到Linux，kiosk家目录下，用kiosk登录2.将三个集合包拷贝到foundation0的rhel9.0目录中$ ssh root@localhost cp /home/kiosk/{community-general-5.5.0.tar.gz,redhat-insights-1.0.7.tar.gz,redhat-rhel_system_roles-1.19.3.tar.gz} /content/courses/rh294/rhel9.0/materials3.打开foundation0的浏览器输入http://172.25.254.254/materials/就可以看到两个软件包-------------------------【workstation】1.创建存储集合的位置$ mkdir /home/student/ansible/mycollections $ vim ansible.cfg[defaults]... #集合默认路径不删除，额外添加当前用户工作目录中集合路径collections_path=/home/student/ansible/mycollection:~/.ansible/collections:/usr/share/ansible/collections 2.部署requirements.yml文件$ vim /home/student/ansible/mycollections/requirements.yml---collections:- name: http://172.25.254.254/materials/community-general-5.5.0.tar.gz- name: http://172.25.254.254/materials/redhat-insights-1.0.7.tar.gz- name: http://172.25.254.254/materials/redhat-rhel_system_roles-1.19.3.tar.gz3.安装集合$ ansible-galaxy collection install -r requirements.yml -p /home/student/ansible/collections/mycollections$ ansible-galaxy collection list 7.5 利用系统角色重用内容​ 编写利用红帽帽企业Linux的系统角色执行标准操作的 playbook 系统角色1# linux6时间服务ntpd，linux7，chronyd，管理员必须配置两个服务，如果用系统角色system-roles.timesync角色就可以配置6、7的时间同步 1.内容集合方式安装系统角色12345678910111213#角色以两种形式提供：1.内容集合 redhat.rhel_system_roles$ mkdir /home/student/ansible/collections$ vim /home/student/ansible/collections/requirements.yml---collectionsname: redhat.rhel system roles$ ansible-galaxy collection install -p collections/ -r home/student/ansible/collections/requirements.yml此处可以通过文件安装，也可通过直接指定本地tar包安装，可以参考教材练习 123$ sudo find ./mycollection/ -name selinux-playbook.yml #不安装角色包可以使用该条命令搜索$ find mycollection/ -name '*.yml' | grep selinux$ cp /usr/share/ansible/collections/ansible_collections/redhat/rhel_system_roles/docs/selinux/selinux-playbook.yml /home/student/ansible/selinux.yml 2.rpm包方式安装系统角色123456系统角色使用流程1.通过软件安装获得系统角色（rhel-system-roles.noarch）2.定义系统角色路径（存放角色的位置），并将其记录配置文件cd /;ansible-galaxy list , vim ~/ansible/ansible.cfg/;roles_path=xxxx:xxxx3.使用系统角色，将系统角色添加至playbook，并修改内容4.应用 1234567891011121.安装系统帮助我们定义了一些角色，有不同的功能，需要通过安装软件包。[greg@control ansible]$ cd /[greg@control /]$ sudo yum search roles[greg@control /]$ sudo yum install -y rhel-system-roles.noarch [greg@control /]$ ansible-galaxy list #在根目录下查看角色路径，该路径为默认系统角色路径# /usr/share/ansible/roles #系统角色路径- linux-system-roles.kdump, (unknown version)....- rhel-system-roles.timesync, (unknown version)# /etc/ansible/roles [WARNING]: - the configured path /home/greg/.ansible/roles does not exist. 12345678910112.定义角色路径[greg@control /]$ cd ~/ansible/ #在ansible工作目录中查看时属于greg用户定制的角色路径[greg@control ansible]$ vim ansible.cfgroles_path = /home/greg/ansible/roles:/usr/share/ansible/roles #:冒号分割，并添加系统角色路径[greg@control ansible]$ ansible-galaxy list# /home/greg/ansible/roles #之前定义好的自定义角色路径- apache, (unknown version)# /usr/share/ansible/roles #系统角色路径- linux-system-roles.kdump, (unknown version)......- rhel-system-roles.timesync, (unknown version) 1234567891011121314151617183.使用系统角色，将系统角色添加至playbook并应用[greg@control ansible]$ rpm -ql rhel-system-roles.noarch | grep timesync #看README.md[greg@control ansible]$ cp /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml /home/greg/ansible/timesync.yml #找例子，并复制到工作目录中[greg@control ansible]$ vim timesync.yml #编辑角色---- hosts: all vars: timesync_ntp_servers: - hostname: 172.25.254.254 iburst: yes roles: - rhel-system-roles.timesync4 使用系统角色[greg@control ansible]$ ansible-playbook timesync.yml查询验证ansible all -a 'chronyc sources -v' 通过内容集合安装使用系统角色1.timesync1234567891011$ cp /usr/share/ansible/collections/ansible_collections/redhat/rhel_system_roles/docs/timesync/multiple-ntp-servers.yml timesync.yml$ vim timesync.yml- hosts: all vars: timesync_ntp_servers: - hostname: 172.25.254.254 iburst: yes roles: - redhat.rhel_system_roles.timesync$ ansible-navigator run timesync.yml -m stdout$ ansible all -m shell -a 'chronyc sources -v ' 2.selinux12345678910111213$ cp /usr/share/ansible/collections/ansible_collections/redhat/rhel_system_roles/docs/selinux/selinux-playbook.yml selinux.yml$ vim selinux.yml---- hosts: all vars: selinux_policy: targeted selinux_state: permissive roles: - redhat.rhel_system_roles.selinux$ ansible-navigator run selinux.yml -m stdout# 验证$ ansible all -m shell -a 'grep ^SELINUX= /etc/selinux/config' 7.6 通过文件安装角色123456789101112131415161718Ansible官网：https://docs.ansible.com/ansible/2.9/galaxy/user_guide.html#installing-roles-from-galaxyhttps://galaxy.ansible.com/nginxinc/nginx_core #该网站可以查看角色包信息#实验需要在模拟考试环境下做，普通环境没有角色包[greg@control ansible]$ vim roles/requirements.yml #制作角色部署文件---- src: http://materials/phpinfo.tar #角色在网络中的路径 name: phpinfo #指定安装在系统中的角色名称- src: http://materials/haproxy.tar name: balancer [greg@control ansible]$ ansible-galaxy install --help[greg@control ansible]$ ansible-galaxy install -r roles/requirements.yml #-r 指定角色文件[greg@control ansible]$ ansible-galaxy list #检测# /home/greg/ansible/roles- phpinfo, (unknown version) #查看结果- balancer, (unknown version) 8 对Ansible进行故障排除8.1 对playbook进行故障排除调试Playbook12345-rhel8ansible-playbook debug.yml -v #显示详细信息-v -vv -vvv -vvvv-rhel9ansible-navigator run playbook.yml -m stdout -v Debug12345678910111213141516171819202122232425262728#通过debug模块打印收集到的变量信息，帮助管理员了解模块执行过程及结果---- hosts: serverb tasks: - name: install the latest version of Apache ansible.builtin.yum: name: vsftpd state: latest register: web_install #注册变量收集模块的执行信息 - ansible.builtin.debug: var: web_install #debug模块可以帮助打印出执行信息#可以一次性将hostvars收集到的所有魔法及事实变量打印出来，并可以记录到文件中[greg@control ansible]$ vim debug.yml---- name: test hosts: node1 tasks: - ansible.builtin.debug: var: hostvars[greg@control ansible]$ ansible-navigator run -m stdout debug.yml &gt; 2.txt 关闭事实收集如果要关闭收集，可以编辑配置文件gathering = explicit或者在playbook里gather_facts: yes/no true/false 检查 Playbook 中的错误12345678-RHEL8$ ansible-playbook playbook.yml --syntax-checkplaybook: playbook.yml-RHEL9greg@control ansible]$ ansible-navigator run -m stdout debug.yml --syntax-checkplaybook: /home/greg/ansible/debug.yml 检查 Playbook的问题并遵循良好实践123456#常见语法问题name： 冒号后面要空格，内容随意hosts： all 指定的主机不在清单中，报错无parttensyntax-errors：注意格式缩进，2格缩进变量设置错误，或调用时错误（变量名写错，变量开头要加双引号） when条件： （逻辑判断思路错误，或书写错误） 检查Playbook 工件和日志文件12ansible-navigator 可以生成 playbook工件，以JSON格式存储与 playbook的运行相关的信息。您可以将与 playbook运行相关的信息记录到系统上您可写入位置处的文本文件中。 123456789101112131415RHEL9中的ansible自动开启日志功能，可通过配置文件设置及手工设置#配置文件$ vim ~/.ansible-navigator.yml---ansible-navigator: execution-environment: image: utility.lab.example.com/ee-supported-rhel8:latest pull: policy: missing playbook-artifact: enable: false # false/true 关闭/打开#手工指定--pae --playbook-artifact-enable 将输出记录到文本文件1234-RHEL8&amp;9Ansible 提供了一个内置日志基础架构，可通过ansible.cfg 配置文件 [defaults] 部分中的log_path参数进行配置，或通过$ANSIBLE_LOG_PATH环境变量进行配置。在进行上面一项或两项配置后，Ansible会以文本形式将ansible-navigator 命令的输出存储到所配置的日志文件中。此机制也适用于ansible-playbook 等早期的工具。如果您将Ansible配置为将日志文件写入 /var/log，红帽建议您配置 logrotate来管理文件。 8.2 对Ansible受管主机进行故障排除对连接进行故障排除1231 远程用户（普通，root）2 远程密码、特权密码问题3 账号密码有多种设置方案 使用Ansible运行临时命令123456789ad-hoc命令可以用于简单部署场景，比如对一组目标部署一个任务，或检索受管节点的运行情况、状态等。ansible all -m ping#注意RHEL9中默认不允许root用户登录，需要修改配置文件允许root登录。所建议使用普通用户作为远程管理用户。解决方法,服务器端：$ vim /etc/ssh/sshd_config#PermitRootLogin prohibit-passwordPermitRootLogin yes$ systemctl reload sshd –step 手动控制执行的步骤123456789101112$ ansible-playbook playbook.yml --step$ ansible-navigator run playbook.yml -m stdout --stepPLAY [PLAY1] ********************************************************************************************Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: n手动输入n y c来控制playbook中执行的步骤n 不执行该步骤y 执行该步骤c 继续自动执行到结束通过该方法，我们可以让有问题的步骤执行，而无关紧要的步骤可以跳过不执行。达到排错的目的。 –start-at-task 从指定步骤执行任务1234[greg@control ansible]$ ansible-playbook playbook.yml --start-at-task='Start service httpd'选项“--start-at-task #指定具体执行步骤，等号后面指定模块的描述，如果描述内容中有空格，建议用单或双引号引起来，表示为一个参数。 -C –check 烟雾测试12345678910111213141516171819202122232425262728293031烟雾测试：在管理节点执行剧本，显示剧本的真实执行结果，但是不在受管节点上部署。$ ansible-playbook playbook.yml --help | grep \\\\-C$ ansible-navigator run playbook.yml -m stdout -C[greg@control ansible]$ vim playbook.yml---- name: PLAY1 hosts: node2 tasks: - name: install apache ansible.builtin.yum: name: httpd state: latest - name: Copy using inline content ansible.builtin.copy: content: 'test web page' dest: /var/www/html/index.html - name: Start service httpd ansible.builtin.service: name: httpd state: started - name: Start service firewalld ansible.builtin.service: name: firewalld state: started - name: permit apache ansible.posix.firewalld: service: http permanent: yes state: enabled immediate: yes[greg@control ansible]$ ansible-playbook playbook.yml -C 通过发送脚本解决问题12345678910111213141516$ vim test.sh #自定义脚本名及内容#!/bin/bashdate$ vim debug.yml #剧本名自定义---- name: hosts: node1 tasks: - name: Run a script ansible.builtin.script: /home/greg/ansible/test.sh #使用script模块，加脚本文件路径 register: haha #register收集上面模块执行结果至 haha（自定义名称）的这个变量中 - ansible.builtin.debug: var: haha #通过debug模块将haha变量的值打印出来。$ ansible-playbook debug.yml `如果不想写register，可以执行剧本时添加-v 类似：ansible-playbook debug.yml -v` 9 自动执行Linux管理任务9.1 管理软件和订阅优化多软件包安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ansible.builtin.---- name: hosts: all tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd #httpd state: latest - name: install the latest version of Apache ansible.builtin.yum: name: php #php state: latest---------------------------------------------- name: install the latest version of Apache ansible.builtin.yum: name: &quot;{{ item }}&quot; state: latest loop: #用loop方式简化playbook - httpd - php yum install -y httpdyum install -y php---------------------------------------------- name: install the latest version of Apache ansible.builtin.yum: name: - httpd - php state: latestyum install -y httpd php--------------------------------------------- - name: ensure a list of packages installed ansible.builtin.yum: name: &quot;{{ packages }}&quot; vars: packages: - httpd - httpd-tools--------------------------------------------- 等同于：yum install -y httpd php或loop的这种方式，系统会执行两次独立事务，对每个事务应用一个软件包yum模块：state： absent删除, installed, present确保安装 latest升级到最新版本latest 等同 yum updateyum remove yum install name： '*' 代表所有软件包 name: &quot;@RPM Development tools&quot; ansible命令里面安装包组要加@ 收集有关已安装软件包的事实12345678910111213141516---- name: hosts: node1 tasks: - name: Gather the package facts ansible.builtin.package_facts: manager: auto #- name: Print the package facts # ansible.builtin.debug: # var: ansible_facts.packages - name: Check whether a package called foobar is installed ansible.builtin.debug: msg: &quot;{{ ansible_facts.packages.zip.0.version }}&quot; 查看用于管理软件包的其他模块123456789- name: Install httpd on RHEL 8 and 9 ansible.builtin.dnf name: httpd state: present- name: Install httpd on RHEL 7 and earlier ansible.builtin.yum: name:httpd state:present 配置RPM软件包存储库1234567891011121314151617181920212223242526272829303132333435363738394041424344$ ansible-doc -l | grep yum---- name: hosts: node1 tasks: - name: Add multiple repositories into the same file (1/2) ansible.builtin.yum_repository: name: EX294_BASE #file字段不存在时，默认用name字段代替源文件名称 description: EX294 base software file: rhel #file选项作用是定义yum源文件名称，无该字段时会用name字段后的值代替文件名 例如：rhel.repo baseurl: http://content/rhel8.4/x86_64/dvd/BaseOS gpgcheck: yes gpgkey: http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release enabled: yes - name: Add multiple repositories into the same file (1/2) ansible.builtin.yum_repository: name: EX294_STREAM description: EX294 stream software file: rhel #多个模块使用同一个file字段的名称时，会将源地址写入到同一个文件中。 baseurl: http://content/rhel8.4/x86_64/dvd/AppStream gpgcheck: yes gpgkey: http://content/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-release enabled: yes #enabled默认值为yes，考试时要写该选项。ansible模块选项和vim配置文件内容对比 vim： ansible： rhel.repo file [rhel] * name name=rhel * description baseurl= * baseurl gpgcheck= * gpgcheck gpgeky= * gpgkey enabled= * enabled 测试方法：$ ansible all -a 'yum repolist all'# 受管节点检测$ cat rhel.repo 1234$ ansible-doc rpm_key - ansible.builtin.rpm_key: state: present key: http://apt.sw.be/RPM-GPG-KEY.dag.txt 9.2 管理用户和身份验证user 模块12345678910111213141516171819202122232425262728293031323334353637需求:在servera上创建用户tom 附加组为group1，并设置密码为password tom: tom123用sha512方式哈希，uid =2000user这个模块类似这些功能： useradd userdel usermod$ cat group.yml - name: hosts: node1 vars: - passwordtom: tom123 tasks: - name: create group ansible.builtin.group: name: &quot;{{ item }}&quot; loop: - group1 - group2 - name: Add the ansible.builtin.user: name: tom #useradd tom comment: student #useradd -c student uid: 2000 #useradd -u 2000 password_expire_max: 10 #passwd -e 10 group: group1 #useradd -g group1 groups: group1,group2 #-G group1,group2 shell: /bin/bash #-s /bin/bash password: &quot;{{ passwordtom | password_hash('sha512') }}&quot; passwd tom #passwordtom该密码位置如果是字符串用单引号引起来，如果是变量则不需要单引号 #验证用户密码过期时间chage -l tomPassword expires : Jun 11, 2024#验证用户密码是否正确，可以从node2登录node1，测试node1上的tom用户ssh tom@node1Ansible网页搜索：password_hash--Using filter--网页中查找password_hash，查看密码哈希方式，一定注意是512Ansible官网： https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html 模块中：append: yes 如果想额外添加附加群组，此选项需要yes(usermod -a -G grouptest u1) group模块123456789101112131415[greg@bastion ansible]$ cat group.yml ---- name: hosts: dev tasks: - name: Ensure group &quot;grouptest&quot; exists ansible.builtin.group: gid: 10000 name: grouptest state: present | absent #创建|删除 二选一等同于：groupadd grouptest等同于：groupadd -g 10000 grouptestgroupdel 9.3 管理启动过程和调度进程at1234567891011---- name: hosts: dev tasks: - name: Schedule a command to execute in 20 minutes as root ansible.posix.at: command: ls -d / &gt;/dev/null count: 20 units: minutes默认是创建一个任务，给root，删除的 话使用选项state：absent cron1234567891011121314151617181920212223[greg@bastion ansible]$ ansible-doc cron[greg@bastion ansible]$ cat cron.yml ---- name: hosts: all tasks: - name: Ensure a job that runs at 2 and 5 exists. ansible.builtin.cron: name: &quot;check dirs&quot; #描述 minute: &quot;*/2&quot; #分钟 hour: &quot;2,5&quot; #小时 day: 1-10 #天 user: harry job: &quot;ls -alh &gt; /dev/null&quot; [greg@bastion ansible]$ ansible dev -m shell -a 'crontab -u harry -l'#rh134课程练习内容指令： conrtab -u harry -e1、每年2月2日上午9点执行echo hello任务0 9 2 2 echo hello2、七月每周5的,9点至下午5点，每5分钟执行echo hi*/5 9-17 * 7 5 管理服务1234567891011121314151617---- name: hosts: dev tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest - name: Start service httpd, if not started ansible.builtin.service: name: httpd state: started enabled: yes #开机自启动~ service restart network systemd12345678910111213141516171819[greg@bastion ansible]$ cat systemd.yml ---- name: hosts: dev tasks: - name: install the latest version of Apache ansible.builtin.yum: name: httpd state: latest - name: Make sure a service is running ansible.builtin.systemd: name: httpd state: started enabled: yes 测试命令：ansible dev -m shell -a 'systemctl status httpd'ansible dev -m shell -a 'systemctl is-enabled httpd' 1.reboot123- name: Unconditionally reboot the machine with all defaults reboot: 2.command &amp; shell 支持更多的特殊字符1234$ ansible servera -m command -a 'useradd user1'$ ansible servera -a 'useradd user2'$ ansible servera -a 'echo 123456 | passwd --stdin user1'$ ansible servera -m shell -a 'echo 123456 | passwd --stdin user1' 9.4 管理存储 模块名 linux指令 Linux实施命令 community.general.parted parted parted /dev/vdb mkpart part1 2048s 1G community.general.lvg vgcreate vgcreate -s 16M vg100 /dev/vdb{1..2} community.general.lvol lvcreate lvcreate -L 100M -n lv100 vg100 community.general.filesystem mkfs mkfs.ext4 /dev/vg100/lv100 ansible.posix.mount /etc/fstab echo “/dev/vg100/lv100 ext4 /mnt/data defaults 0 0” &gt; /etc/fstab 通过模块管理存储1.纯分区无lvm逻辑卷11.分区-格式化-挂载 1234567891011121314151617181920212223242526272829303132333435363738394041424344451-1 分区 community.general.parted #先确保community.general集合已经安装，可通过ansibl-galaxy collection list来查看#创建两个分区每个500M---- name: parted hosts: node2 tasks: - name: part 1 2048s-500M community.general.parted: device: /dev/vdc number: 1 state: present part_end: 500MiB - name: part 2 500M-1000M community.general.parted: device: /dev/vdc number: 2 state: present part_start: 500MiB part_end: 1GiB1-2 格式化 community.general.filesystem#两个分区都格式化为ext4文件系统，如果选择不同文件系统，可以分成两个模块。 - name: Create a ext4 community.general.filesystem: fstype: ext4 dev: &quot;{{ item }}&quot; loop: - /dev/vdc1 - /dev/vdc21-3 挂载 ansible.posix.mount#自动创建挂载点/mnt/part1,再将/dev/vdc1写入/etc/fstab文件最后一行，并挂载。 - name: Mount DVD read-only ansible.posix.mount: path: /mnt/part1 #挂载点 src: /dev/vdc1 #设备 fstype: ext4 #文件系统类型 state: mounted #参考下面解释 -挂载选项解释：#absent: 卸载并删除/etc/fstab内容 #unmounted： 卸载不删除/etc/fstab内容#present： 将挂在信息写入/etc/fstab，不挂载#mounted： 将挂在信息写入/etc/fstab，并创建挂载点及挂载#remounted： 重新挂载 2.有lvm逻辑卷实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021032.分区-lvm（pv,vg,lv）-格式化-挂载2-1 分区 community.general.parted #分两个区每个大约500M，/dev/vdb---- name: lv hosts: node2 tasks: - name: part 1 2048s-500M community.general.parted: device: /dev/vdb number: 1 state: present part_end: 500MiB - name: part 2 500M-1000M community.general.parted: device: /dev/vdb number: 2 state: present part_start: 500MiB2-2 pv+vg community.general.vg#两个分区都加入vg，名称vg100#ansible-navigator collections -m stdout | grep vg$ 查看帮助 - name: Create a volume group vg100 community.general.lvg: vg: vg100 pvs: /dev/vdb1,/dev/vdb2 pesize: 322-3 lv community.general.lvol#创建一个lv名为lv100，大小800M - name: Create a logical volume lv100 size 800M community.general.lvol: vg: vg100 lv: lv100 size: 8002-4 格式化 community.general.filesystem#格式化为xfs文件系统 - name: Create a xfs community.general.filesystem: fstype: xfs dev: /dev/vg100/lv1002-5 挂载 ansible.posix.mount#lv挂载到/mnt/data，并设置为开机自启动。 - name: /mnt/data ansible.posix.mount: path: /mnt/data src: /dev/vg100/lv100 fstype: xfs state: mounted #整体配置---- name: lv hosts: node2 tasks: - name: part 1 2048s-500M community.general.parted: device: /dev/vdb number: 1 state: present part_end: 500MiB - name: part 2 500M-1000M community.general.parted: device: /dev/vdb number: 2 state: present part_start: 500MiB - name: Create a volume group vg100 community.general.lvg: vg: vg100 pvs: /dev/vdb1,/dev/vdb2 pesize: 32 - name: Create a logical volume lv100 size 800M community.general.lvol: vg: vg100 lv: lv100 size: 800 - name: Create a xfs community.general.filesystem: fstype: xfs dev: /dev/vg100/lv100 - name: /mnt/data ansible.posix.mount: path: /mnt/data src: /dev/vg100/lv100 fstype: xfs state: mounted#搜索帮助总结nsible-navigator --helpansible-navigator collections -m stdout | grep parted$ansible-navigator collections -m stdout | grep lvg$ansible-navigator collections -m stdout | grep lvol$ansible-navigator collections -m stdout | grep filesystem$ansible-navigator collections -m stdout | grep mount$ansible all -m shell -a 'lsblk'ansible-navigator doc -m stdout community.general.partedansible-navigator doc -m stdout community.general.filesystemansible-navigator doc -m stdout ansible.posix.mountansible-navigator doc -m stdout community.general.lvg 通过系统角色管理存储1.磁盘管理角色1当前版本测试失败，暂时不做 2.逻辑卷角色1234567891011121314151617181920212223242526272829[greg@control ansible]$ sudo find ./mycollection/ -name '*.yml' | grep storage|grep test.yml./mycollection/ansible_collections/redhat/rhel_system_roles/tests/storage/test.yml[greg@control ansible]$ cp ./mycollection/ansible_collections/redhat/rhel_system_roles/tests/storage/test.yml ./storage.yml[greg@control ansible]$ vim disk.yml$ vim storage.yml---- hosts: node4 vars: storage_use_partitions: true roles: - name: redhat.rhel_system_roles.storage storage_pools: - name: vg100 disks: - /dev/vdb volumes: - name: lv100 size: 200M fs_type: ext4 mount_point: '/mnt/lvm100' state: &quot;present&quot; - name: lv200 size: 300M fs_type: xfs mount_point: '/mnt/lvm200' state: &quot;absent&quot;$ ansible-navigator run storage.yml -m stdout 9.5 管理网络1234567891011121314151617181920212223242526272829303132[greg@control ansible]$ sudo find ./mycollection/ -name '*.md' | grep network[greg@control ansible]$ vim ./mycollection/ansible_collections/redhat/rhel_system_roles/roles/network/README.md[greg@control ansible]$ sudo find ./mycollection/ -name '*.yml' | grep network $ vim /usr/share/doc/rhel-system-roles/collection/roles/network/README.md$ vim playbook.yml---- hosts: node5 vars: network_connections: - name: eth0 interface_name: eth0 type: ethernet state: up autoconnect: yes ip: address: - 192.0.2.3/24 dns: - 192.0.2.2 dns_search: - example.com dhcp4: no gateway4: 192.0.2.1 auto6: no roles: - redhat.rhel_system_roles.network$ ansible-navigator run playbook.yml -m stdout 附加：使用普通用户远程管理受管主机1234567891011121314151617181920212223242526272829303132333435【超级用户远程管理方式】vim /home/greg/ansible/ansible.cfgremote_user=roothost_key_checking = Falsevim /home/greg/ansible/inventory[all:vars]#ansible_user=rootansible_password=redhat【普通用户远程管理方式】需求，请使用greg用户远程管理受管主机【bastion】控制节点ansible.cfg[defaults]remote_user = greghost_key_checking = False[privilege_escalation]become=Truebecome_method=sudo become_user=rootbecome_ask_pass=false----------------------------------------以下配置考试环境下已做管理节点ssh-keygen 三个回车ssh-copy-id greg@workstationssh greg@workstation其他受管主机上每一个主机都做如下操作[root@workstation ~]# useradd greg[root@workstation ~]# echo redhat | passwd --stdin greg[root@workstation ~]# visudogreg ALL=(ALL) NOPASSWD: ALL","link":"/2025/04/15/Ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"podman容器","slug":"podman容器","link":"/tags/podman%E5%AE%B9%E5%99%A8/"},{"name":"Ansible","slug":"Ansible","link":"/tags/Ansible/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"容器技术","slug":"容器技术","link":"/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"},{"name":"Ansible","slug":"Ansible","link":"/categories/Ansible/"}],"pages":[{"title":"","text":"个人简介 -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：毕业院校：山西大同大学本科专业：光电信息科学与工程专业技术点：从事Linux技术运维 技术知识点 Linux基础命令、Linux服务 待补充","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://luovip.github.io/img/avatar.png 网站名称：罗宇 网站地址：https://luovip.github.io/ 网站简介：Linux运维技术交流 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"🎈🎈相信技术的力量🎈🎈 RHCE认证 K8S认证 🎈🎈生活🎈🎈 点滴记录","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出! &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}]}