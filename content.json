{"posts":[{"title":"Linux基本使用","text":"1 访问命令行1.1 登录Linux系统12345678910111213141516图形化​ 系统菜单-注销-或切换用户字符界面​ Ctrl+alt+F2-F6 在本机上切换用户给su - root 切换用户ctrl+d 退出登录(ctrl+d or exit or logout)网络登录​ ssh ip 或 主机名[kiosk@foundation0 ~]$ ssh servera​ ssh 用户名@ip/主机名[kiosk@foundation0 ~]$ ssh root@servera[kiosk@foundation0 ~]$ ssh student@servera 1.2 终端切换12CLI Ctrl+alt+Fx xin （2，6）GUI Ctrl+alt+F1 1.3 Shell简介​ 是一个解释器，可以帮助用户将指令信息传递内核 ​ 红帽企业Linux中为用户提供默认shell是bash，bash是与UNIX类似的系统上使用的其中一个最成功的shell改进版本 1.4 基本组成12345678[kiosk@foundation0 ~]$ #$普通用户[kiosk@foundation0 ~]$ su - root #切换用户：su - 用户名Password: #输入用户登录密码Last login: Sat Feb 22 15:11:13 CST 2020 on tty3[root@foundation0 ~]# #超级用户ctrl+d or exit 退出登录 注：bash shell在概念上与微软的cmd相似，但bash具有更加复杂的脚本语言 ​ 与win系统powershell类似、mac的管理终端使用工具也是使用的bash shell 1.5 GNOME Shell123456789ALT+F2 输入 gnome-terminal # 启动终端# 锁定 win+l# 关闭和重启 init 0 init 6 poweroff reboot systemctl poweroff systemctl reboot shutdown -h 20：00 shutdown -r 0# 工作区切换 ctrl+alt 上\\|下 箭头 1.6 Shell的特性linux命令语法完成具体功能的命令、扩展该命令功能的选项、命令要操作的对象 cmd 【-option】 【arg1】 【arg2】 1234567891011121314简单的命令示例：whoamidatetouch file1；mkdir dir1完成某些工作的指令扩展命令功能的选项参数lsls -a ls -a ~/.bashrcls -a -l ~/.bashrcls -al ~/.bashrc 回显式命令12date +%Y%m%ddate +%Y-%m-%d 交互式命令1passwd tab补全123按一下是补全按两下列出可用命令tab键 输入单词或命令前面几个首字母后，保证唯一可补全，不唯一可列出能选择的命令 历史命令-history123env--能容纳1000条[root@servera ~]# env | grep SIZEHISTSIZE=1000 1234567891011121314151617181920212223[root@servera ~]# history -w [root@servera ~]# vim ~/.bash_history 记录历史命令文件，vim是一个文本工具，可以打开后面的文件，进入后:q退出[root@servera ~]# history -c 清除[root@servera ~]# history history的其他方法：！！！23 历史命令的编号！h 命令首字母当前历史命令支持的最大条数[root@foundation0 /]# grep ^HISTSIZE /etc/profileHISTSIZE=1000历史命令存放文件路径[root@foundation0 /]# set | grep HISTFILEHISTFILE=/root/.bash_historyvim /etc/profileexport HISTFILE=/root/.newfilesource /etc/profilehistory -wcat /root/.newfilectrl+R 搜索历史命令 1.7 命令行快捷键12345ctrl+shift+t #当前画面添加一个标签ctrl+shift+n #打开一个新的标签alt+1，alt+2 #切换标签ctrl+shift+ =，ctrl+ - #扩大终端字体，缩小字体ctrl+shift+w #关闭标签 1.8 Bash Shell常用的快捷键123456789ctrl+a #光标跳至行首ctrl+e #光标跳至行尾ctrl+u #从光标所在位置清空至行首ctrl+k #从光标所在位置清空至行末ctrl+左箭头 #光标向左跳一个单词ctrl+右箭头 #光标向右跳一个单词ctrl+w #回删一个单词alt+d #删除光标后一个单词esc + . 或 alt + . #调用之前使用过的路径，alt+.一直点可以向上翻阅路径 2 从命令行管理文件2.1 Linux系统目录结构1234567891011121314151617181920/目录下每个目录的作用:bin 用户可执行目录(命令 root 和 普通)sbin 系统可执行目录(命令 root)lib 库文件目录(32位)lib64 库文件目录(64位)dev 设备文件目录dev 设备文件目usr 应用程序目录var 服务器数据目录(数据 日志)srv 服务器数据目录etc 配置文件目录tmp 临时文件目录boot 服务器启动目录(内核和启动文件)media 媒介目录(u盘,cdrom)mnt 其他挂载点opt 第三方应用程序目录proc 伪文件系统(内核参数,进程信息,硬件信息)sys 伪文件系统(c 配置文件目录 内核参数,进程信息,硬件信息)run 进程锁目录root root管理员家目录home 普通用户家目录 2.2 文件类型12345678文件类型:(7种)- 普通文件 filed 目录文件 directoryc 字符设备文件 characterb 块设备文件 blocks 套接字文件 socketp 管道文件 pipel 符号链接文件(软链接) symbolic 2.3 通过文件名定位文件12[root@foundation0 home]# cd /[root@foundation0 /]# cd /etc/ 2.4 路径的表示绝对路径 ,通常以/开头 例子： 根开头 cd /etc/sysconfig 相对路径 非根开头 cd .. 2.5 导航路径123# pwd[root@foundation0 yum.repos.d]# pwd/etc/yum.repos.d 12345# cdcd - 返回之前的目录cd or cd ~ 家目录cd . 当前目录cd .. 上一级目录 12345678910111213141516171819# lslsls -a ls -a /home ls -a -l ls -al[root@foundation0 ~]# ls -a .viminfo.viminfo[root@foundation0 ~]# ls -a -l .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 ~]# ls -al .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 /]# ls -l -d /homedrwxr-xr-x. 4 root root 30 Mar 13 11:38 /homels -ld /optll -d /optalias 2.6 查看文件内容12345678cat cat /etc/passwd 将文件内容打印到屏幕上tail tail /var/log/message 默认查看文件后10行。-F （追踪）指定文件不存在时再创建相同名称文件 tail -n 5 或 tail -5 /var/log/message head head /var/log/message 默认查看文件头10行 head -5 /var/log/message less less /var/log/message more more /var/log/message vim vim /etc/passwd 文本编辑器 2.7 使用命令行管理文件/目录123456 创建 touch mkdir -p 改名 mv mv 移动 mv mv 拷贝 cp cp -r 删除 rm rm -rtouch、mkdir、rm、cp、mv 123456789101112131415161718192021touch：[root@servera ~]# cd /opt/[root@servera opt]# pwd/opt[root@servera opt]# ls[root@servera opt]# man touch[root@servera opt]# touch file1[root@servera opt]# lsfile1[root@servera opt]# touch file2 file3[root@servera opt]# lsfile1 file2 file3[root@servera opt]# touch /file4 /tmp/file5[root@servera opt]# ls /file4;ls /tmp/file5/file4/tmp/file5[root@servera opt]# touch file{10..20}[root@servera opt]# lsfile1 file11 file13 file15 file17 file19 file20file10 file12 file14 file16 file18 file2 file3a1.txt a2.txt a3.txt b1.txt.....c3.txt 123456789101112131415161718192021222324252627282930313233343536373839mkdir选项：-p：递归创建-v：显示过程[root@servera opt]# rm -f file* [root@servera opt]# ls[root@servera opt]# man mkdir[root@servera opt]# mkdir dir1[root@servera opt]# lsdir1[root@servera opt]# mkdir dir2 /dir3[root@servera opt]# lsdir1 dir2[root@servera opt]# ls /bin dir3 home media proc sbin tmpboot etc lib mnt root srv usrdev file4 lib64 opt run sys var[root@servera opt]# lsdir1 dir2[root@servera opt]# mkdir dir3/dir4mkdir: cannot create directory ‘dir3/dir4’: No such file or directory[root@servera opt]# mkdir -pv dir3/dir4mkdir: created directory 'dir3'mkdir: created directory 'dir3/dir4'[root@servera opt]# ls -R dir3 #-R递归查看，可以查看多级目录内容dir3:dir4dir3/dir4:[root@servera opt]# ll -R dir3/dir4dir3/dir4:total 0[root@servera opt]# ll dir3total 0drwxr-xr-x. 2 root root 6 Mar 13 22:23 dir4[root@servera opt]# ll dir3/dir4/total 0[root@servera opt]# ll dir3/dir4/ -ddrwxr-xr-x. 2 root root 6 Mar 13 22:23 dir3/dir4/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566rm[root@servera opt]# man rm[root@servera opt]# lsdir1 dir2 dir3 file1 file2 file3[root@servera opt]# rm file1rm: remove regular empty file 'file1'? y 询问是否删除y删除n不删除[root@servera opt]# lsdir1 dir2 dir3 file2 file3[root@servera opt]# rm file2rm: remove regular empty file 'file2'? n[root@servera opt]# rm -f file2 强制删除不询问[root@servera opt]# lsdir1 dir2 dir3 file3[root@servera opt]# rm -f file* *代表一个或多个字符[root@servera opt]# lsdir1 dir2 dir3[root@servera opt]# rm dir1 rm: cannot remove 'dir1': Is a directory[root@servera opt]# rm -r dir1 删除目录需要-r表示递归rm: remove directory 'dir1'? y[root@servera opt]# rm -rf dir2[root@servera opt]# lsdir3copy[root@servera opt]# lsdir1 dir2 file1 file2 file3[root@servera opt]# cp file1 /tmp/[root@servera opt]# ls /tmp/file1/tmp/file1[root@servera opt]# cp file1 /tmp/file10[root@servera opt]# ls /tmp/file10/tmp/file10[root@servera opt]# cp /etc/man_db.conf .[root@servera opt]# lsdir1 dir2 file1 file2 file3 man_db.conf[root@servera opt]# cp file2 file3 /tmp/[root@servera opt]# ls /tmp/file*/tmp/file1 /tmp/file2 /tmp/file5/tmp/file10 /tmp/file3[root@servera opt]# cp -r dir1 /tmp/[root@servera opt]# cp -r dir1 /tmp/di10[root@servera opt]# cp /home/student/.bashrc /opt/[root@servera opt]# ll -a [root@servera opt]# cp -p /home/student/.bashrc ./.bashrc1[root@servera opt]# ll -amv[root@servera opt]# lsdir1 dir2 file1 file2 file3 man_db.conf[root@servera opt]# mv file1 /[root@servera opt]# lsdir1 dir2 file2 file3 man_db.conf[root@servera opt]# mv file2 /file20[root@servera opt]# lsdir1 dir2 file3 man_db.conf[root@servera opt]# mv file3 file30[root@servera opt]# lsdir1 dir2 file30 man_db.conf[root@servera opt]# mv dir1 /[root@servera opt]# lsdir2 file30 man_db.conf[root@servera opt]# mv dir2 dir20[root@servera opt]# lsdir20 file30 man_db.conf 2.8 通配符通配符 1234567# 通配符规则* 匹配0个或多个任意字符？ 匹配1个任意字符[ ] 匹配中括号内一个字符[ - ] 匹配中括号内连续范围的一个字符[ ^ ] 取反。匹配非中括号内的字符，表示一定有一个字符，但不是中括号内出现的。【^ab】{a,b}或{a..c} 匹配号中的字符，或连续的字符 123456789101112131415161718192021222324252627282930313233[root@servera opt]# rm -rf *[root@servera opt]# touch {a..c}{1..3}.txt[root@servera opt]# lsa1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls *.txta1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls a*a1.txt a2.txt a3.txt[root@servera opt]# ls a?.txta1.txt a2.txt a3.txt[root@servera opt]# ls ?2*a2.txt b2.txt c2.txt[root@servera opt]# ls ?[23]*a2.txt a3.txt b2.txt b3.txt c2.txt c3.txt[root@servera opt]# ls ?[^23]*a1.txt b1.txt c1.txt[root@servera opt]# ls ?[!23]*a1.txt b1.txt c1.txt[root@servera opt]# ls {a1,b1}*a1.txt b1.txt[root@servera opt]# ls {a..c}*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [[:alpha:]]*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [a-z]*a1.txt a3.txt b2.txt c1.txt c3.txta2.txt b1.txt b3.txt c2.txt[root@servera opt]# ls [A-Z]*b1.txt b2.txt b3.txt c1.txt c2.txt c3.txt 3 在线获取帮助3.1 MAN帮助手册12345678man 1 用户命令 *man 2 系统调用man 3 库调用man 4 特殊文件man 5 配置文件 *man 6 游戏man 7 杂项man 8 系统命令 * 3.2 –help1234567891011121314man passwdman -k passwd mandbman -k passwdman 1 passwdman 5 passwd ls --helpman tarman setfacl | grep lisaman setfacl | grep -B 1 lisasetfacl --help | grep \\\\-asetfacl --help | grep -w \\\\-a 3.3 Pinfo123infopinfo 回车 upinfo ls 3.4 rpm包中提供帮助1234567891011121314yum install -y httpdrpm -qa | grep httpdrpm -ql 软件包名称rpm -qchttp tools install serveraclassroom和bastionyum install -y httpd-manualsystemctl start servera允许http，或关闭防火墙found：http：//172.25.250.10/manual 3.5 在线帮助https://access.redhat.com/ 4 创建、查看编辑文本4.1 VIM文本编辑器1234# 模式 功能 命令模式 光标移动、复制删除 cmd 输入模式 输入文本内容 a 末行模式 保存退出、设置环境 4.2 命令模式12345678910111213# 命令 解释 h j k l 左下上右 方向键 上下左右 1G、nG n代表一个数字，去第1行或n行 gg 将光标定位到文章的顶端 G 将光标定位到文章的底端 （\\$定位光标到行尾，0和\\^定位光标到行首） x，X 向后删除，向前删除一个字符 dd ， ndd 删除1行，n是一个数字，n行 。 例子：dgg dG d\\$ d0 D yy，nyy 复制1行，n行 p，P 粘贴到下一行，粘贴到上一行 u 撤销 ZZ 保存退出 按键ZZ 4.3 插入模式12345678a 字符后进入插入模式i 当前字符位置进入插入模式o 在下一行新创建一行进入插入模式A 在行尾进入插入模式I 在行首进入插入模式O 在上一行新创建一行进入插入模式s 删除光标位置字符并进入插入模式S 删除光标所在行并进入插入模式 4.4 末行模式1234567891011w 保存q 退出wq 退出并保存q！ 强制退出x 保存退出set nu 设置行号set nonu 取消行号：w /newfile 另存为其他文件 例子：&quot;:w /man.txt&quot;：r /newfile 读取/newfile到本文件中 例子： &quot;:r /etc/passwd&quot;：！ command vim编辑过程中，查询linux &quot;:! ls /&quot;: e！ 重新读取文件 4.5 其他模式1234v、V或Ctrl+V 可视模式R 替换模式/word，？word /向下查找，？向上查找n，N 定位到下一个匹配字符，定位到上一个匹配字符 4.6 视图模式12视图模式修改方法：ctrl+v ， jjj，I， 写入#号，esc 4.7 缩进+永久保存12345678910111213：set all 查看末行模式的帮助：set autoindent 保存上下缩进：set tabstop=2 调整tab键缩进：set nu 设置行号[root@foundation0 ~]# vim ~/.vimrc 仅对当前用户生效set nuset tabstop=2[root@foundation0 ~]# vim /etc/vimrc 全局设置，每个用户使用vim工具都有行号set nu 4.8 替换12345678910:s/// @@@ AAA ; ;;:s/old/new/:s/old/new/g:#,#s/old/new/g #井号代表一个数字比如：1,5s/old/new/g:%s/old/new/g:#,$s/old/new/g #井号代表数字，比如1，$s ，$代表末行，该命令为1行至末行修改某一段ip地址: %s/192.168.1/172.25.250/g取消文本中某个字段：:%s/10.10.10.10//g 4.9 重定向1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511=stand，2=error，&amp;=1+2pwdlsecho helloecho $SHELLecho 12345echo 123456 &gt; file1cat file1grep root /etc/passwdgrep root /etc/passwd &gt; /opt/a.txtcat /opt/a.txtgrep apache /etc/passwdgrep apache /etc/passwd &gt; /opt/a.txtcat a.txtecho 123456echo 123456 &gt;&gt; a.txtcat a.txtecho abcd 1&gt;&gt; a.txtcat a.txtlscd dir1cd dir1 2&gt; errcat errcd dir1 2&gt; /dev/nullfind / -user studnetfind / -user studentfind / -user student 2&gt; errvim errfind / -user student 2&gt; err &gt; stavim stafind / -user student &amp;&gt; sharevim sharegrep na /etc/resolv.confvim /etc/resolv.confgrep ^$ /etc/resolv.confcat -n /etc/resolv.confcat -n /etc/resolv.conf | grep ^$cat -n /etc/resolv.confvim ~/.vimrccat -n /etc/resolv.confcat /etc/resolv.confgrep -n ^$ /etc/resolv.confgrep na /etc/resolv.confls /root/lsgrep na /etc/resolv.confgrep na /etc/resolv.conf &gt; /root/lines.txtcat /root/lines.txthistory -wtc/resolv.conf &gt; /root/lines.txtcat /root/lines.txt 5 管理本地用户和组5.1 USER-用户基本概念：用户用于访问计算机资源 12340 超级用户 1000以下 系统用户1000以上 普通用户 组与用户ID对应(自然创建) useradd-添加用户1234567891011121314语法:useradd 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录(通常不更改，如果设置，需要是未存在的目录)例：useradd user1 创建user1passwd user1 为user1设置密码id user1 查询用户信息 用户配置文件12345678910111213141516171819202122232425262728293031323334用户配置文件路径:/etc/passwd[kiosk@foundation0 ~]$ vim /etc/passwdroot:x:0:0:root:/root:/bin/bash用户名：密码占位符：UID：GID：描述：家目录：shell环境练习1： [root@servera /]# useradd -u 2000 user1[root@servera /]# id user1[root@servera /]# groupadd group1[root@servera /]# tail -1 /etc/group[root@servera /]# useradd -g group1 user2[root@servera /]# tail -1 /etc/passwd[root@servera /]# useradd -G wheel user3[root@servera /]# useradd -c student -d /user4dir -s /sbin/nologin user4[root@servera /]# tail -1 /etc/passwd[root@servera /]# su - user1[user1@servera /]# ctrl+d[root@servera /]# su - user1[root@servera /]# su - user2 需要密码[root@servera /]# ctrl+d 退出用户[root@servera /]# passwd user2 超级用户设置密码123456123456[root@servera /]# su - user1[root@servera /]# su - user2 输入密码[root@servera /]# useradd -G root,tom user5 #将user5同时加入到组root和tom组中练习2：tom10，uid 3000 ，gid devops，shell环境为/bin/false,描述 student，家目录/tom10dir,附加组 root。答案：useradd -u 3000 -g devops -s /bin/false -c student -d /tom10dir -G root tom10 usermod-修改用户123456789101112131415161718192021222324252627282930语法：usermod 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录（通常不更改，且如设置需要是未存在的目录）-a：额外指定附加组练习1:[root@servera /]# usermod -u 3000 user1[root@servera /]# usermod -g group1 user1[root@servera /]# usermod -G root user1[root@servera /]# grep user1 /etc/group[root@servera /]# usermod -G root,wheel user1[root@servera /]# grep user1 /etc/group[root@servera /]# groupadd group2[root@servera /]# usermod -a -G group2 user1[root@servera /]# grep user1 /etc/group[root@servera /]# usermod -s /bin/false user1 #shell环境为/bin/false的用户和系统无任何交互[root@servera /]# su - user1[root@servera /]# usermod -c heihei user1练习2：tom11的附加组，root。想额外添加一个附加组为devops。答案：[root@servera opt]# usermod -a -G root tom11[root@servera opt]# usermod -G root,devops tom11 userdel-删除用户12345678910语法：userdel 选项 选项参数 用户名option：-r：删除用户同时删除邮箱和家目录练习:[root@servera /]# useradd user5[root@servera /]# find / -user user5[root@servera /]# userdel -r user5[root@servera /]# find / -user user5 5.2 PASSWORD-密码passwd12345678语法:passwd 用户名方法1：[root@foundation0 /]# useradd zhangsan #创建用户[root@foundation0 /]# echo 123456 | passwd --stdin zhangsan 非交互式Changing password for user zhangsan.passwd: all authentication tokens updated successfully.方法2：[root@foundation0 /]# passwd zhangsan 交互式 密码配置文件12345678910111213141516171819202122232425路径:/etc/shadowuser2:$6$9R47OYVVaxga34EJ$Y3pGf5EnHpn6vfiBk5ZU1U89d7UiySOsnAs/fkFMuPRyhCZAvv0a6UXRVLGXqRUKwP34Sg0W/CYb1VQp7H08L0:20015:0:99999:7:::说明:第一列: 用户名第二列: 密码(有密码状态,无密码状态,!!帐号锁定,* 该帐号永久不能登陆系统)第三列: 密码的最后一次修改时间（从1970年1月1日至今的天数）18834=今天第四列: 密码的最小时间(和第三列比较，密码修改相隔时间，或理解为密码自最后一次修改后多少天内不能再重复修改)第五列: 密码的最大时间(密码有效期) 99999表示永久不过期(和第3列比，相当于自最后一次修改多久后必须变更密码，否则过期)第六列: 密码过期前警告时间（和第5列比，在过n天你的密码就过期了，需要重设密码。）第七列: 密码过期后帐号（宽限时间，第五列密码的最大时间到期后，还可以使用系统的宽限时间，该期间中可以继续使用系统，但是再次登入系统时强制修改密码，否则无法进入）第八列: 帐号有效期（账号失效后，无论密码是否过期都不能使用。）第九列: 保留列练习:设置密码：1.交互式语法：passwd 用户名[root@servera /]# passwd user12.非交互式语法：echo xxx | passwd --stdin username [root@servera /]# echo 123456 | passwd --stdin user1Changing password for user user1.passwd: all authentication tokens updated successfully. 5.3 GROUP-用户组groupadd123456语法：groupadd 选项 选项参数 组名-g：指定组ID例：[root@servera /]# groupadd group10[root@servera /]# groupadd -g 3000 group11 groupmod123456语法：groupmod 选项 选项参数 组名-n：更改组名 groupmod -n 新组名 旧组名例：[root@servera /]# groupmod -n group100 group10[root@servera /]# groupdel1234# 删除组信息groupdel groupname[root@foundation0 ~]# groupdel haha1[root@foundation0 ~]# grep haha1 /etc/group gpasswd加入群组与清除群组成员 12345678910gpasswd-a：添加用户到群组-d：从组中清除用户[root@foundation0 ~]# useradd -G upup user5 添加用户时指定附加组（次要群组）[root@foundation0 ~]# usermod -G upup user1 修改用户时指定附加组（次要群组） [root@foundation0 ~]# gpasswd -a user2 rootAdding user user2 to group root[root@foundation0 ~]# gpasswd -d user2 rootRemoving user user2 from group root 用户组配置文件1234567路径:/etc/group[root@localhost ~]# vim /etc/groupupup:x:2006:第一段: 组名第二段: 组密码占位符号第三段: gid第四段: 用户列表 su-切换用户123su -su - rootsu - user1 su - user2 需要密码 模拟练习1234567891011121314151617181920groupadd sysmgrsuseradd -G sysmgrs natashauseradd -G sysmgrs harryuseradd -s /bin/false sarahecho flectrag | passwd --stdin natahsaecho flectrag | passwd --stdin harryecho flectrag | passwd --stdin sarah验证方式：通过切换用户，id username，vim /etc/passwd修改密码重设默认天数：[root@servera ~]# useradd user10[root@servera ~]# chage -l user10Maximum number of days between password change : 99999[root@servera ~]# vim /etc/login.defs PASS_MAX_DAYS 20[root@servera ~]# useradd user20[root@servera ~]# chage -l user20Maximum number of days between password change : 20 5.4 重点总结12345678910useradd usermod userdel ，id 用户名，cat /etc/passwd，groupadd groupmod groupdel gpasswd -a , -d passwd 用户名 echo xxx | passwd --stdin username 用户 /etc/passwd, 用户组，/etc/group 密码 /etc/shadow创建用户时的一些默认设置，/etc/default/useradd /etc/login.defs 6 控制对文件的访问6.1 关于系统安全的技术点对比12345Linux操作系统涉及的安全部分: 防火墙 semanage port ， selinux semanage ... 软件app semanage boolean 文件系统权限 特殊权限 facl 隐藏权限 semanage fcontext 6.2 Linux文件权限1234权限分类： r read(读) w write(写) x execute(执行) 6.3 Linux系统的权限表示12345# ls -l test-rw-r--r--. 1 stu1 class1 35 May 21 14:09 testrw-r--r-- #中间9位是权限，逻辑分三组，所有者 所属组 其他人权限stu1 所有者class1 所属组 6.4 Linux系统权限的作用1234权限 对文件的影响 对目录的影响 r cat ls w vim touch，rm，mkdir x ./script cd 6.5 使用符号方式修改文件权限123456对象 设置方式 权限u(user) \\+ (添加) rg(group) \\- (减去） wo(other) = (设置） xa(all) s(SUID、SGID) t(Sbit) 6.6 使用数字方式修改文件权限12345rwx 8进制表示 数字表示----- ----------- ----------r-- 100 4-w- 010 2--x 001 1 6.7 文件权限设置-chmod123456789101112语法：chmod 权限 文件名u g o a + - = r w x s t例：[root@node1 /]# cd /opt/[root@node1 opt]# ls[root@node1 opt]# touch test[root@node1 opt]# ll test -rw-r--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# chmod u+x test [root@node1 opt]# ll test -rwxr--r--. 1 root root 0 Nov 24 04:55 test 练习1：文件权限修改12345678910111213141516文件权限修改[root@node1 opt]# touch aa.txt[root@node1 opt]# ll aa.txt #每次修改权限去自己检验查询[root@node1 opt]# chmod u+x aa.txt[root@node1 opt]# chmod u-rw aa.txt[root@node1 opt]# chmod u+r,g+w,o+x aa.txt[root@node1 opt]# chmod ug+rw aa.txt[root@node1 opt]# chmod ugo+rwx aa.txt # chmod a+rwx , chmod a=rwx, ugo+rwx[root@node1 opt]# chmod a-rwx aa.txt[root@node1 opt]# chmod o=--- aa.txt # o=-[root@node1 opt]# chmod u=r aa.txt[root@node1 opt]# chmod u=rw aa.txt[root@node1 opt]# chmod u=r,g=rw,o=x aa.txt[root@node1 opt]# chmod ugo=rwx aa.txt[root@node1 opt]# chmod a=r aa.txt 练习2：数字修改方法12345678910r 4w 2x 1[root@node1 opt]# mkdir dir1[root@node1 opt]# ll -d dir1drwx r-x r-x. 2 root root 6 Nov 24 05:04 dir1[root@node1 opt]# chmod 775 dir1[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 root root 6 Nov 24 05:04 dir1 6.8 设置文件属主和属组-chown123456789101112131415161718192021222324252627282930313233343536373839语法：chown 所有者:所属组 文件名 chown 该命令可以作用于文件、目录，修改时保证所有者的用户及组都是存在的。例:chown user2:user2 newfile# 练习:[root@node1 opt]# ll test-rwxr--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# id studentuid=1000(student) gid=1000(student) groups=1000(student),10(wheel)[root@node1 opt]# useradd harry[root@node1 opt]# chown student test;ll test-rwxr--r--. 1 student root 0 Nov 24 04:55 test[root@node1 opt]# chown :harry test;ll test-rwxr--r--. 1 student harry 0 Nov 24 04:55 test[root@node1 opt]# useradd sally[root@node1 opt]# chown sally:sally test;ll test-rwxr--r--. 1 sally sally 0 Nov 24 04:55 test-R[root@node1 opt]# lsdir1 test[root@node1 opt]# touch dir1/test2[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 root root 19 Nov 24 05:15 dir1[root@node1 opt]# ll dir1total 0-rw-r--r--. 1 root root 0 Nov 24 05:15 test2[root@node1 opt]# chown -R sally:sally dir1[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 sally sally 19 Nov 24 05:15 dir1[root@node1 opt]# ll dir1/test2 -rw-r--r--. 1 sally sally 0 Nov 24 05:16 dir1/test2 6.9 文件默认权限-umask12345678910111213系统默认定义权限对于文件是666、对于目录是777查看umask值方法[root@servera /]# umask0022修改方法umask[root@servera /]# umask 0002修改完后，可以去文件和目录查看权限，看是否和之前不一样，看完改回来永久生效[root@servera /]# echo 'umask 0002' &gt;&gt; ~/.bash_profile[root@servera /]# source ~/.bash_profile #source 将后面文件中的值加载到当前shell中。系统登录会读取~/.bash_profile文件自动加载 umask的练习12345678910111213141516171819202122232425262728293031323334#示例1：文件默认权限666umask后三位022快捷方法：变成权限后相减rw-rw-rw- = 666 文件系统默认权限----w--w- = 022 umask值------------------------------rw-r--r-- = 644 创建文件时的默认权限目录默认权限777rwxrwxrwx = 777 目录系统默认权限----w--w- = 022 umask值------------------------------rwxr-xr-x = 755 创建目录时的默认权限故系统中应设置为:0022#示例2:文件权限是r-- --- ---， 400 文件夹是dr-x --- --- 500umask?目录rwxrwxrwx = 777r-x------ = 500--------------------w-rwxrwx = 277文件rw-rw-rw- = 666-w-rwxrwx = umask ------------------r------- = 400参考umask计算方法：https://www.cnblogs.com/wyllearning/p/16482006.html如果减法时目录和文件权限不一致时，以目录的为准计算umask值 6.10 特殊权限​ 文件系统权限可以完成一些基本权限功能设置，但有些特殊要求是达不到的，可能需要特殊权限来完成 ​ Linux系统中特殊权限有三个：SUID 4 、SGID 2 、SBIT 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SUID 4 通常设置在二进制可执行文件（命令）上，并具有执行权限的情况下 作用：设置了该权限的命令，被其他用户执行时，会临时获取文件所有者权限[student@clear ~]$ su - studnet[student@clear ~]$ cat /etc/shadow #普通用户无法查看/etc/shadow[student@clear ~]$ su - root #切换root身份[root@clear ~]# chmod u+s /usr/bin/cat #数字修改方式：chmod 4755 /usr/bin/cart[root@clear ~]# ll /usr/bin/cat-rwsr-xr-x. 1 root root 34512 Aug 13 2018 /usr/bin/cat[student@clear ~]$ su - studnet[student@clear ~]$ cat /etc/shadow #能够看见内容，临时获取拥有者权限chmod 4755 /usr/bin/catSGID 2该权限通常设置在`目录`上，设置了该权限的目录，在该目录中创建`子文件及目录`时会`继承`父目录所属组。[root@clear ~]# cd /opt/[root@clear opt]# ls[root@clear opt]# mkdir dir1[root@clear opt]# chown student:student dir1[root@clear opt]# ll -d dir1drwxr-xr-x. 2 student student 6 Nov 19 04:50 dir1[root@clear opt]# touch dir1/root.txt[root@clear opt]# ll dir1/root.txt-rw-r--r--. 1 root root 0 Nov 19 04:51 dir1/root.txt[root@clear opt]# [root@clear opt]# chmod g+s dir1[root@clear opt]# ll -d dir1drwxr-sr-x. 2 student student 22 Nov 19 04:51 dir1[root@clear opt]# touch dir1/root1.txt[root@clear opt]# ll dir1/root1.txt-rw-r--r--. 1 root student 0 Nov 19 04:52 dir1/root1.txt数字修改法： chmod 2755 dir1SBIT（粘滞位） 1该权限通常设置在目录上，设置了该权限的目录，其他用户在该目录中只能删除所有者是自己的文件。[root@clear opt]# rm -rf *[root@clear opt]# ls[root@clear opt]# mkdir share[root@clear opt]# chmod 777 share/[root@clear opt]# id studentuid=1000(student) gid=1000(student) groups=1000(student),10(wheel)[root@clear opt]# useradd tom[root@clear opt]# id tomuid=1005(tom) gid=1005(tom) groups=1005(tom)[root@clear opt]# su - studentLast login: Sat Nov 19 04:46:47 EST 2022 on pts/0[student@clear ~]$ touch /opt/share/student.txt[student@clear ~]$ logout[root@clear opt]# su - tom[tom@clear ~]$ rm -f /opt/share/student.txt[tom@clear ~]$ logout[root@clear opt]# chmod 1777 /opt/share/[root@clear opt]# ll -d /opt/share/drwxrwxrwt. 2 root root 6 Nov 19 04:56 /opt/share/[root@clear opt]# su - studentLast login: Sat Nov 19 04:55:24 EST 2022 on pts/0[student@clear ~]$ touch /opt/share/student.txt.haha[student@clear ~]$ logout[root@clear opt]# su - tomLast login: Sat Nov 19 04:55:38 EST 2022 on pts/0[tom@clear ~]$ rm -f /opt/share/student.txt.haharm: cannot remove '/opt/share/student.txt.haha': Operation not permittedcheck：创建两个不同用户登录操作系统，进入dirt目录分别创建文件，尝试互相删除对方文件，结果应不能互相删除文件。大S和小s区别，执行权限位大S是，没有x执行权限位小s是该位，有x 7 进程监控及管理1234yum install -y psmiscpstree -p一程序被开启会产生一个或多个进程，他们都有对应父进程与子进程，每个进程都有进程号PIDsystemd 1 不能被杀死，除非重启，关机。 7.1 ps12345678910111213141516171819以静态的方式查看系统进程ps -lps aux ps aux | grep http[root@servera ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 27392 27367 0 80 0 - 85532 - pts/0 00:00:00 su4 S 0 27396 27392 0 80 0 - 59008 - pts/0 00:00:00 bash4 T 0 27822 27396 1 80 0 - 63962 - pts/0 00:00:00 vim0 R 0 27823 27396 0 80 0 - 63625 - pts/0 00:00:00 ps# 练习：查看httpd进程1、【node1】：yum install -y httpd2、systemctl start httpd3、ps aux |grep httpd4、【foundation】firefox 172.25.250.10 7.2 top1234567以同态的形式查看进程topMPhk pid 9/15 q 退出 7.3 终止进程kill命令12345678910111213141516171819202122232425262728293031语法：kill -s 信号名称 或-n 信号编号Options:-s sig SIG is a signal name-n sig SIG is a signal number例子:kill -s SIGKILL httpdkill -n 9 httpd # 或 kill -9 httpd练习：[root@node1 /]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1[root@node1 /]# vim 1 &amp;[1] 1372[root@node1 /]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 0 1313 1312 0 80 0 - 59084 - pts/1 00:00:00 bash0 T 0 1372 1313 4 80 0 - 60816 - pts/1 00:00:00 vim0 R 0 1373 1313 0 80 0 - 63799 - pts/1 00:00:00 ps[1]+ Stopped vim 1[root@node1 /]# kill -n 9 1372[root@node1 /]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 0 1313 1312 0 80 0 - 59084 - pts/1 00:00:00 bash0 R 0 1374 1313 0 80 0 - 63799 - pts/1 00:00:00 ps[1]+ Killed vim 1 killall命令1234567891011语法：killall 守护进程名称#yum install -y httpdsystemctl start httpdps aux | grep httpdkillall httpdyum provides killallyum install -y psmisc-23.1-3.el8.x86_64killall httpdps aux | grep httpd 7.4 作业控制jobs1234567891011121314151617181920212223242526272829[root@servera ~]# vim file2 （ctrl+z）[1]- Stopped vim file1[2]+ Stopped vim file2[root@servera ~]# jobs[1]- Stopped vim file1[2]+ Stopped vim file2[root@servera ~]# dd if=/dev/zero of=./bigfile bs=1M count=1000ctrl + z [root@servera ~]# jobs[1]+ Stopped dd if=/dev/zero of=./bigfile bs=1M count=1000[root@servera ~]# bg ％1[1]+ dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# jobs[1]+ Running dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# fg %1[root@servera ~]# 1000+0 records in1000+0 records out1048576000 bytes (1.0 GB, 1000 MiB) copied, 65.0049 s, 16.1 MB/s[root@servera ~]# kill -9 %2[2]- Stopped vim file2[root@servera ~]# jobs[2]- Killed vim file2[3]+ Stopped nice -n -10 vim file4 7.5 进程优先级调整1234567891011121314151617nice值超级用户root 可以修改nice值范围 -20~19普通用户user 可以修改nice值范围 0-19进程优先级数字越小，优先级越高。优先级不能直接改，可以通过nice值来影响优先级。旧优先级 + nice值 = 新优先级80 -10 = 70两种方法：一、产生新进程时，设置nice值nice -n -5 vim file2 &amp;二、修改现有进程nice值renice -n 10 PIDps -l 查看需要更改的进程号renice -n 10 28183 8 控制服务与守护进程8.1 服务状态关键字段123456# 字段 描述---------- -------------------------------- Loaded 服务单元是否加载到内存 Active 服务单元是否在运行，运行了多久 Main PID 服务的主进程ID，包括命令名称 Status 有关该服务的其他信息 8.2 systemctl管理服务123456789101112131415161718192021222324252627282930313233343536373839systemctl -t help列入.service扩展名，代表服务，如web服务systemctl list-units --type service 列出当前服务器加载的服务单元systemctl status httpd.service 查看某个服务# yum install -y httpd 安装apache服务服务运行状态[root@servera system]# systemctl status httpd● httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor pr&gt; Active: inactive (dead) Docs: man:httpd.service(8) [root@servera system]# systemctl start httpd [root@servera system]# systemctl status httpd● httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor pr&gt; Active: active (running) since Sat 2020-02-29 04:34:47 CST; 1s ago查看服务是否启动[root@servera system]# systemctl is-active httpdactive查看服务是否开机启动[root@servera system]# systemctl enable httpd[root@servera system]# systemctl is-enabled httpdenabled[root@servera system]# systemctl disable httpdRemoved /etc/systemd/system/multi-user.target.wants/httpd.service.[root@servera system]# systemctl is-enabled httpddisabled常见特征（了解）：1、安装 yum install -y httpd2、启动 systemctl start httpd.service （单元文件）/usr/lib/systemd/system/3、查进程 ps aux | grep httpd , 每个服务有自己的守护进程/usr/sbin/httpd4、查端口 netstat -ntlp ，找到80端口，对应Listen监听状态 对应httpd服务vim /etc/service 改文件记录了系统服务的端口和协议的对应关系 8.3 服务状态分类12345678910# 关键字 描述------------------- ------------------------------------------ loaded 单元配置文件已处理 active（running） 正在通过一个或多个持续进程与运行 active（exited） 已成功完成一次性配置 active（waiting） 运行中，但正在等待事件 inactive 不在运行 enabled 在系统引导时启动 disabled 未设为在系统引导时启动 static 无法启动，但可以由某一启动的单元自动启动 8.4 管理系统服务​ 语法：systemctl 管理命令 unitname 12345678910111213管理命令 描述status 查看状态start 开启stop 关闭restart 重启reload 加载配置文件enable 开机启动disable 关闭开机启动is-active 查看服务状态是否启动is-enabled 查看服务是否开机自启动list-dependencies 【unitname】 查看单元依赖mask 禁止服务，无法启动或开机 启动unmask 解除ma 12345678910111213141516171819202122232425262728293031323334353637383940练习时，重启服务前，先关闭以下两个应用setenforce 0 关闭seliunxsystemctl stop firewalld 关闭防火墙 yum install -y httpdsystemctl start httpd.servicesystemctl status httpdps aux |grep httpdnetstat -ntlpsystemctl is-active httpdsystemctl is-enabled httpdsystemctl status httpdsystemctl --helpsystemctl --help | grep \\\\--systemsystemctl start httpdsystemctl --system start httpdsystemctl --help| grep \\\\--usersystemctl enable httpdsystemctl status httpdsystemctl disable httpdsystemctl status httpdsystemctl mask httpd 注销服务systemctl unmask httpd 取消注销systemctl enable --now httpd 开启服务并且开机自启动 可以用做练习的服务httpd，sshd，autofs，samba。ftp服务器服务开机自启1、安装 vsftpd2、启动 vsftpd.service3、设置开机自启 寻找service文件的方法：[root@servera ~]# rpm -qa | grep autofslibsss_autofs-2.4.0-9.el8.x86_64autofs-5.1.4-48.el8.x86_64[root@servera ~]# rpm -ql autofs | grep service[root@servera ~]# rpm -ql autofs | grep service/usr/lib/systemd/system/autofs.service 9 OPENSSH服务9.1 ssh的常用功能12345678910111213141516[root@servera ~]# ssh serverbroot@serverb's password: [root@servera ~]# vim /etc/hosts 或者系统是否做了dns,ip和域名及主机名的映射[root@servera ~]# ssh 172.25.250.11[root@servera ~]# ssh root@172.25.250.11[root@servera opt]# scp rhcetext root@172.25.250.11:/root@172.25.250.11's password: rhcetext 100% 0 0.0KB/s 00:00[root@serverb /]# scp root@172.25.250.10:/opt/newfile .root@172.25.250.10's password: newfile 100% 0 0.0KB/s 00:00 [root@servera opt]# ssh root@172.25.250.11 'yum install -y httpd'ssh root@172.25.250.11 'yum install -y httpd' 9.2 ssh免密登录12345678910111213【servera】[root@servera ssh]# ssh-keygen 后面三个回车[root@servera ssh]# ssh-copy-id root@serverb【serverb】[root@serverb /]# cd /root/.ssh/[root@serverb .ssh]# lsauthorized_keys known_hosts【servera】[root@servera ssh]# ssh root@serverba免密远程b，如果想b远程a免密，需要相同的配置课上练习：b远程免密登录a 9.3 ssh服务控制123456# 拒绝root登录[root@serverb ~]# vim /etc/ssh/sshd_configPermitRootLogin no[root@serverb ~]# systemctl reload sshd（或restart）[root@servera ~]# ssh root@serverb 9.4 sudo命令1234567891011121314151617181920212223242526272829一、将用户设置为特权用户1、[student@servera ~]$ yum remove -y httpdError: This command has to be run under the root user.2、[root@servera /]# vim /etc/sudoers 或者 visudo## Allow root to run any commands anywhere root ALL=(ALL) ALLstudent ALL=(ALL) ALL3、[student@servera ~]$ sudo yum remove -y httpd[sudo] password for student: student二、将账号添加到特权用户组中，培训环境默认特权用户组是wheel组，在/etc/sudoers文件中用%wheel来表示usermod -G wheel tom三、练习：添加一个特权组admin，而且组内有一个成员是harry。最终harry账号应当为特权账号。[root@serverb ~]# groupadd admin[root@serverb ~]# visudo[root@serverb ~]# useradd -G admin harry[root@serverb ~]# su - harry[harry@serverb ~]$ sudo -i[sudo] password for harry: 四、设置特权组中用户切换时不需要密码%admin ALL=(ALL) NOPASSWD: ALL 10 日志分析与存储10.1 系统中的日志文件1234567# 日志文件 存储的消息类型------------------- ---------------------------------------- /var/log/messages 大多数系统日志消息处存放处 /var/log/secure 与安全性和身份验证时间相关的syslog消息 /var/log/maillog 与邮件服务器相关的syslog消息 /var/log/cron 与计划任务执行相关的syslog消息 /var/log/boot.log 与系统启动相关的消息。 rsyslog服务管理的日志配置文件123456[root@haha log]# yum provides /etc/rsyslog.conf #查看文件是哪个软件包提供的[root@clear log]# rpm -qc rsyslog-8.1911.0-3.el8.x86_64 /etc/logrotate.d/syslog/etc/rsyslog.conf #一般服务文件以.conf结尾，改文件是日志服务的配置文件/etc/sysconfig/rsyslog[root@clear log]# vim /etc/rsyslog.conf 记录日志的规则12345678日志文件配置格式:mail.info /var/log/vsftpd.log #.点代表包含后面级别及以上级别AAAA.BBBB CCCCAAAA 产生日志的设备（类别） #如何产生的日志BBBB 日志的级别 #日志有不同安全级别，类似轻重缓急的严重程度，发出警告CCCC 保存日志的位置 #在系统中保存日志文件的路径 rsyslog配置文件类别(产生日志的设备)1234567891011类别(facility) ---------------- --------------------- Kern 内核 authpriv 授权和安全 cron 计划任务 mail 邮件 daemon 系统守护进程 user 普通用户级别的 syslog 由rsyslog生成的信息 local0\\~local7 自定义本地策略 \\* 所有类别 日志级别1234567891011121314151617181920man 3 syslog# 等级 解释----------------- ---------------------------- EMERG（紧急） 会导致主机系统不可用的情况 ALERT（警告） 必须马上采取措施解决的问题 CRIT（严重） 比较严重的情况 ERR（错误） 运行出现错误 WARNING（提醒） 可能会影响系统功能的事件 NOTICE（注意） 不会影响系统但值得注意 INFO（信息） 一般信息 DEBUG（调试） 程序或系统调试信息等 \\* 所有等级 none 不记录日志 解释：*.info;mail.none;authpriv.none;cron.none /var/log/messages*.info *所有设别 .点代表后面的等级及以上等级，也就是info以上的等级全记录；分号是不同设备等级的分隔符号mail.* -/var/log/maillog- 代表先记录缓存，再记录硬盘，减轻硬盘i/o读写压力。 使用logger发送测试日志信息1234567891011121314151617181920211 查看rsyslog服务是否开启 (默认系统已开启)[root@servera ~]# systemctl status rsyslog2 编辑rsyslog配置文件[root@servera ~]# vim /etc/rsyslog.conf# Save boot messages also to boot.loglocal7.* /var/log/boot.log..*.debug /var/log/messages.debug3 重启rsyslog日志服务让配置生效[root@servera ~]# systemctl restart rsyslog4 开另一个窗口 ctrl+shift+t[root@servera ~]# tail -n 0 -f /var/log/messages.debug 5 使用logger命令生成一个user类别，debug级别的日志内容为“Debug test messages” #（考点）[root@servera ~]# logger -p user.debug &quot;Debug test messages&quot; 6 在第4步的窗口中查看新生成日志信息[root@servera ~]# tail -n 0 -f /var/log/messages.debugJun 18 14:45:31 servera root[29174]: messages haha 10.2 journalctl12345678910111213141516传统的日志服务是rsyslog新添加的日志服务是systemd-journal，它也是一个日志管理服务，可以收集来自内核、系统早期启动阶段的日志，以及系统进程在启动和运行中的一些标准输出与错误输出。此日志一旦重启既消失，因为保存在了/run/log/journal/*/*.journal结尾，该文件是一个二进制日志文件，需要用journalctl命令查看。tail -n 5journalctl 查看系统日志journalctl -n 通过q或ctrl接触观看 ，此命令显示方式类似与tail -njournalctl -n 5 journalctl -p err 日志等级journalctl -f journalctl -p err journalctl -p info （deubg、info、notice、warning、err、crit、alert、emerg）journalctl --since &quot;2020-02-28 22:53:35&quot; --until &quot;2020-02-28 22:53:40&quot; journalctl常用字段1234567891011常用字段 含义--------------- ------------------------- \\_COMM 命令名称 \\_EXE 进程的可执行文件的路径 \\_PID 进程的PID \\_UID UID \\_SYSTEM_UNIT 启动该进程的systemd单元 journalctl -o verbose journalctl _HOSTNAME=localhostjournalctl _HOSTNAME=localhost _PID=1 永久保存journal服务文件的方式12345678910111213mandbman -k journalman 5 journald.conf ， Storage=[root@clear journal]# ll -d /run/log/journal[root@clear journal]# cp -a /run/log/journal/ /var/log/journal[root@clear journal]# ll -d /var/log/journaldrwxr-sr-x. 4 root systemd-journal 86 Nov 19 04:30 /var/log/journal[root@clear journal]# systemctl restart systemd-journald[root@clear journal]# ll /var/log/journal/3a2b4da8dabb4729935c193e58ad052d/ #字符串目录名字每个人的可能不一样。不要复制我的笔记。total 8192-rw-r-----. 1 root root 8388608 Nov 19 04:30 system.journal[root@clear journal]# journalctl 10.3 保持准确的系统时间1234567891011121314RHEL6 ntp服务RHEL8 chrony服务还是使用同样的协议标准ntp（network time protocol）UTC：通用协调时 （UTC时间0点是北京时间8点,因为中国、新加坡、马来西亚、菲律宾等国的时间与UTC的时差均为+8,也就是UTC+8,所以当UTC时间0点,北京时间即为0+8=8点）GMT：格林威治标准时间CST：中国标准时间 (China Standard Time） （中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为＋8，也就是UTC+8。）RTC：(Real-Time Clock)也称为硬件时间：RTC是芯片内置的硬件时钟，只要芯片不断电，即使操作系统关机的时候，RTC时钟也是正常在走的，所以当操作系统关机重启后，可通过读取RTC时间来更新系统时间。 （可通过hwclock命令来获取具体的时间 -r 查看硬件时间 -s 硬件时间设置到系统 -w 系统设置到硬件 ） timedatectl命令1234567891011121314151617181920212223242526[root@servera log]# timedatectl Local time: Sat 2020-02-29 08:51:49 CST Universal time: Sat 2020-02-29 00:51:49 UTC RTC time: Sat 2020-02-29 08:11:07 Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no [root@servera log]# timedatectl list-timezones [root@servera log]# timedatectl set-timezone Asia/Hong_Kong [root@servera log]# timedatectl Local time: Sat 2020-02-29 08:55:48 HKT Universal time: Sat 2020-02-29 00:55:48 UTC RTC time: Sat 2020-02-29 08:15:06 Time zone: Asia/Hong_Kong (HKT, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no修改时间方法timedatectl set-time &quot;2020-02-30 10:00:00&quot;Failed to set time: NTP unit is activetimedatectl set-ntp false timedatectl set-time &quot;2020-02-30 10:00:00&quot;timedatectl set-ntp true chrony命令server ===server选项格式=== server host [ key n ] [ version n ] [ prefer ] [ mode n ] [ minpoll n ] [ maxpoll n ] [ iburst ] 其中host是上层NTP服务器的IP地址或域名，随后所跟的参数解释如下所示： ◆ key： 表示所有发往服务器的报文包含有秘钥加密的认证信息，n是32位的整数，表示秘钥号。 ◆ version： 表示发往上层服务器的报文使用的版本号，n默认是3，可以是1或者2。 ◆ prefer： 如果有多个server选项，具有该参数的服务器有限使用。 ◆ mode： 指定数据报文mode字段的值。 ◆ minpoll： 指定与查询该服务器的最小时间间隔为2的n次方秒，n默认为6，范围为4-14。 ◆ maxpoll： 指定与查询该服务器的最大时间间隔为2的n次方秒，n默认为10，范围为4-14。 ◆ iburst： 当初始同步请求时，采用突发方式接连发送8个报文，时间间隔为2秒。 1234567891011121314151617181920212223242526272829[root@servera ~]# systemctl enable --now chronyd #--now启动服务 enable 开机自动[root@servera ~]# systemctl status chronyd[root@servera ~]# vim /etc/chrony.conf #大概第7行 server 后面添加服务器'地址'或'域名'。server classroom.exmaple.com iburst[root@servera ~]# systemctl restart chronyd.service[root@servera ~]# chronyc sources -v210 Number of sources = 1 .-- Source mode '^' = server, '=' = peer, '#' = local clock. / .- Source state '*' = current synced, '+' = combined , '-' = not combined,| / '?' = unreachable, 'x' = time may be in error, '~' = time too variable.|| .- xxxx [ yyyy ] +/- zzzz|| Reachability register (octal) -. | xxxx = adjusted offset,|| Log2(Polling interval) --. | | yyyy = measured offset,|| \\ | | zzzz = estimated error.|| | | \\MS Name/IP address Stratum Poll Reach LastRx Last sample ===============================================================================^* classroom.example.com 8 6 377 25 -3837ns[ +21us] +/- 627us[root@node1 ~]# timedatectl Local time: Sat 2022-11-19 05:03:30 EST Universal time: Sat 2022-11-19 10:03:30 UTC RTC time: Sat 2022-11-26 06:07:04 Time zone: America/New_York (EST, -0500)System clock synchronized: yes #表示时间服务同步 NTP service: active RTC in local TZ: no 11 RHEL网络管理11.1 认识IPv4地址1234567891011121314IP/(NETMASK\\|PREFIX) 172.25.0.9/255.255.0.0 \\| 172.25.0.9/16--- ---------------------- --------------------------------------------GATEWAY 172.25.x.xDNS 正向解析 \\# host servera， 反向解析 \\# host私有地址：A １－１２７B １２８－１９１C １９２－２２３IP地址分类默认对应的子网掩码掩码：Ａ：２５５．０．０．０ 11111111.00000000.00000000.00000000 /8Ｂ：２５５．２５５．０．０ 11111111.11111111.00000000.00000000 /16Ｃ：２５５．２５５．２５５．０ 11111111.11111111.11111111.00000000 /24 网段:IP与掩码二进制与运算123网络地址 172.25.0.0 主机位全0---------- ---------------- -----------广播地址 172.25.255.255 主机位全1 查看ip4与ip61234567查看ip地址方法1：[root@servera ~]#ifconfig [root@servera ~]#ifconfig eth0查看ip地址方法2：[root@servera ~]# ip addr show eth0[root@servera ~]# ip a s eth0[root@servera ~]# ip -s link show enp1s0 ipv4 ipv6 mac12345ipv4 ipv6 mac二进制（位） 32 128 48符号（分） . : :进制 十进制 十六进制 十六进制组 4 8 6 端口与服务123456789101112131415查看服务端口是否被占用lsof -i:80或netstat-n：显示接口和端口编号-t：tcp信息-u：udp信息-l：监听状态信息-a：显示所有信息-p：显示协议名称而不是端口netstat -ntlp | grep 22netstat -ntlp | grep 80参考ss和netstat区别：https://blog.csdn.net/qq_37863891/article/details/107283415 标准服务端口1/etc/services 11.2 网络管理工具nmcli概念123456789101112使用nmcli管理网络服务NetworkManagernmcli工具功能：查看网络设备、创建网络连接、修改网络配置特点及概念：nmcli工具可以对网卡或网卡配置文件操作device ---- 网卡设备connection --- 连接 指的就是网卡配置文件一个device可以拥有多个connection，同一时间只能启用一个connection，且一个connection只能属于一个device举例：device-----eth0connection1 ---- dhcp 自动获取IP connection2 ---- static 静态IP 使用nmcli管理网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mandbman -k nmclinmcli (1) nmcli-examples (7)man nmcli | grep -A 2 'nmcli connection add'-basic[root@servera ~]# nmcli connection show [root@servera ~]# nmcli connection show --active [root@servera ~]# nmcli device status -add---添加 dhcp方式: #创建一个名为default的手动链接，绑定至eth0网卡[root@servera ~]# nmcli connection add con-name 'default' type ethernet ifname eth0 autoconnect yes [root@servera ~]# nmcli con show static方式：#创建一个名为static的静态链接，绑定至eth1网卡[root@servera ~]# nmcli connection add con-name static type ethernet ifname eth0 autoconnect yes ipv4.addresses 192.168.0.1/24 ipv4.gateway 192.168.0.254 ipv4.dns 8.8.8.8 ipv4.method manual [root@servera ~]# nmcli connection showNAME UUID TYPE DEVICE Wired connection 1 1f5ad5ae-e926-3f54-9805-33174e63af47 ethernet eth0 static 980f6712-86b7-4d92-bc84-62e677ccabfc ethernet eth1 #此处dhcp 82c4a93f-1ca2-432b-94da-59a6c4f5aaca ethernet -- Wired connection 2 e801f880-78a6-3344-857f-588f7495bb26 ethernet -- [root@servera /]# nmcli connection up static 启动static网卡[root@servera /]# ip a s eth1 | grep -w inet-modify---修改#将链接static网络信息更改： IP：192.168.0.2 mask：/24 gw：192.168.0.200 dns：114.114.114.114[root@servera ~]# nmcli connection modify static ipv4.addresses 192.168.0.2/24 ipv4.gateway 192.168.0.200 ipv4.dns 114.114.114.114 autoconnect yes ipv4.method manual[root@servera ~]# nmcli connection up static[root@servera ~]# ip a s eth0 inet 192.168.0.2/24 brd 192.168.0.255 scope global noprefixroute eth1 [root@servera ~]# route -nDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 100 0 0 eth00.0.0.0 192.168.0.200 0.0.0.0 UG 101 0 0 eth1[root@servera ~]# cat /etc/resolv.conf # Generated by NetworkManagersearch lab.example.com example.comnameserver 172.25.250.254nameserver 114.114.114.114 [root@serverb ~]# nmcli connection delete static #删除一个链接Connection 'static' (b85e6a57-b8f7-421f-8d15-9ff5e27cbb85) successfully deleted.-up_down---启动与关闭网卡[root@servera /]# nmcli connection down static 关闭static网卡-off---关闭网络服务[root@servera /]# nmcli networking off 关闭网络服务，慎重使 图形化管理工具nmtui12345nmtui-edit图形化管理配置通过点击设置--network--网卡设置，ipv4address netmask dns gatewaynmtui-edit[root@servera /]# nmcli connection up static 网卡配置文件12345678910111213141516171819202122-RHEL8 版本# grep -r IPADDR /usr/share/ #找到下面手册的指令vim /usr/share/doc/initscripts/sysconfig.txt 帮助手册修改配置文件方式修改IP[root@servera ~]# vim /etc/sysconfig/network-scripts/ifcfg-Wired_connection_1BOOTPROTO=none #获取IP的方式 static--静态 none--不设置 dhcp--自动获取 ，手动配IP选前两个中任意一个ONBOOT=yes #开机自动连接IPADDR=172.25.250.100 #ip地址PREFIX=24 #子网掩码 PREFIX=24(等效于255.255.255.0)，mask=255.255.255.0 netmask=255.255.255.0GATEWAY=172.25.250.254 #网关DNS1=xxxx #dns，dns可以有三个 DNS1= DNS2= DNS3=加载网卡配置文件方法一：[root@serverb network-scripts]# nmcli connection reload ifcfg-Wired_connection_1 或 nmcli connection reload[root@serverb network-scripts]# nmcli connection up staticsystemctl restart NetworkManager-RHEL9版本 网卡配置文件位置[root@node1 system-connections]# vim /etc/NetworkManager/system-connections/System\\ eth0.nmconnection 11.3 更改网络信息主机名12345[root@servera ~]# hostnameservera.lab.example.com[root@servera ~]# hostnmae www.example.com 临时[root@servera ~]# vim /etc/hostname 永久（重启系统:reboot、init 6)[root@servera ~]# hostnamectl set-hostname hostname 永久 配置网关(gateway)12345678一、使用nmclinmcli con add con-name xxx ipv4.gateway xxx.xxx.xxx.xxx 配置网关nmcli con mod xxx ipv4.gateway xxx.xxx.xxx.xxx 修改网关以上两种改完之后，需要nmcli con up xxx二、修改配置文件vim /etc/sysconfig/network-scripts/ifcfg-xxxxGATEWAY=xxx.xxx.xxx.xxx 修改完后要nmcli con reload ，再nmcli con up xxxx 查看路由及网关信息123456789101112131415161718[root@servera ~]# ip route default via 172.25.250.254 dev enp1s0 proto static metric 100 172.25.250.0/24 dev enp1s0 proto kernel scope link src 172.25.250.10 metric 100[root@servera ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 100 0 0 enp1s0172.25.250.0 0.0.0.0 255.255.255.0 U 100 0 0 enp1s0[root@servera ~]# nmcli connection show Wired\\ connection\\ 1 | grep ipv4.gaipv4.gateway: 172.25.250.254[root@servera ~]# netstat -nrKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 172.25.250.254 0.0.0.0 UG 0 0 0 enp1s0172.25.250.0 0.0.0.0 255.255.255.0 U 0 0 0 enp1s0 指定DNS12vim /etc/resolv.conf #该文件指定dns和域名的 /etc/sysconfig/network-scripts/ifcfg-xxx中的DNS字段会同步到/etc/resolv.conf，后者优先。nameserver 172.25.250.254 测DNS域名解析是否正常12345678910[root@servera ~]# host classroom.example.com （至少掌握1个）classroom.example.com has address 172.25.254.254[root@servera ~]# nslookup classroom.example.comServer: 172.25.250.254Address: 172.25.250.254#53Name: classroom.example.comAddress: 172.25.254.254[root@servera ~]# dig classroom.example.com 12 归档与系统间复制文件12.1 归档及压缩123456789101112语法：tar 选项 归档文件名 源文件 源文件2 源文件N-c 创建-t 查看-f 指定文件名-v 显示详细信息-x 解包-C 指定解包路径例：man tartar -cvf /root/etc.tar /etc/ 文件及目录打包、解包1234567891011121314151617181920212223242526272829303132333435363738将文件打包归档[root@servera opt]# touch file{1..3}[root@servera opt]#etc.tar file1 file2 file3[root@servera opt]# tar -cvf file.tar file1 file2 file3file1file2file3[root@servera opt]# tar -tf file.tarfile1file2file3[root@servera opt]# lsetc.tar file1 file2 file3 file.tar为文件解包[root@servera opt]# tar -xvf file.tar -C /tmp/file1file2file3[root@servera opt]# ls /tmp/file1 rclocal.logfile2 rht-bastionfile3 rht-defaultNIC1 rht-vm-hostsNIC2 systemd-private-ef2feb022cd2465c9dd920878a1d962b-chronyd.service-kRKFp0[root@servera opt]# 将目录打包归档[root@servera opt]# tar -cvf etc.tar /etc[root@servera opt]# lsetc.tar file1 file2 file3 file.tar[root@servera opt]# cp etc.tar /home[root@servera opt]# cd /home 为目录解包[root@servera opt]# tar -xvf etc.tar 文件压缩1234567891011121314只压缩文件：[root@servera opt]# gzip file1[root@servera opt]# lsetc.tar file1.gz file2 file3 file.tar[root@servera opt]# file file1.gz file1.gz: gzip compressed data, was &quot;file1&quot;, last modified: Sun Mar 1 05:54:06 2020, from Unix, original size 0[root@servera opt]# bzip2 file2[root@servera opt]# lsetc.tar file1.gz file2.bz2 file3 file.tar[root@servera opt]# file file2.bz2 file2.bz2: bzip2 compressed data, block size = 900k[root@servera opt]# xz file.tar [root@servera opt]# lsetc.tar file1.gz file2.bz2 file3 file.tar.xz tar打包并压缩123456789101112131415161718tar的压缩选项man tar | grep gzip-z gzip-j bzip2-J xz打包并压缩 tar -zcvf /root/etc.tar.gz /etc/ 47 cd /root/ 48 ls 49 file etc.tar.gz 50 tar -jcvf /opt.tar.bz2 /opt/ 51 ls / tar -Jcvf /root/etc.tar.gz /etc/解包解压缩并指定路径tar -zxvf etc.tar.g tar -zxvf etc.tar.gz -C /opt/tar xf etc.tar.gz -C /opt/ 12.2 远程传输scp实现远程文件传输1234# scp servra.txt root@bastion:/opt/# ls# scp root@bastion:/opt/bastion.txt .# ls sftp实现远程文件传输1234567891011121314151617181920212223242526272829303132ID app roles---- ------- ----------------1 ftp client2 sftp ssh SubService3 vsftp servicesftp instructor@classroom.example.cominstructor@classroom.example.com's password: Asimovsftp&gt; cd /tmpsftp&gt; lsNIC1 NIC1.old NIC2 NIC2.old sftp&gt; get testfile.txt Fetching /tmp/testfile.txt to testfile.txtsftp&gt; exit[root@servera opt]# [root@servera opt]# lsetc testfile.txt[root@servera opt]# touch put.txt[root@servera opt]# sftp instructor@classroom.example.cominstructor@classroom.example.com's password: Connected to instructor@classroom.example.com.sftp&gt; cd /tmp/sftp&gt; put /opt/put.txt Uploading /opt/put.txt to /tmp/put.txt/opt/put.txt 100% 0 0.0KB/s 00:00 sftp&gt; lsNIC1 NIC1.old NIC2NIC2.oldput.txt rsync实现同步文件内容123456789101112-v 显示详细信息-a 相当于存档模式 本地同步[root@servera tmp]# rsync -av /var/log/* /tmp远程同步[root@servera tmp]# rsync -av /var/log/* serverb:/tmp[root@servera tmp]# ssh root@serverb ls /tmp问题：将serverb上的/var/log/同步到，servera当前目录下[root@servera tmp]# rsync -av serverb:/var/log/ . 13 安装和升级软件包13.1 RPM包管理rpm包语法12345678910111213141516171819软件的获取方式：1、互联网(下载光盘镜像.iso)、直接使用网络yum源2、光盘rpm包语法:rpm 选项 包名选项：-i 安装-v 显示过程-h 以易读方式显示进度条-e 卸载例:rpm -ivh xxx.rpm练习:1. 在f0中进入软件包的存储位置[root@foundation0 /]# cd /content/rhel8.0/x86_64/dvd/AppStream/Packages/[root@foundation0 Packages]# pwd/content/rhel8.0/x86_64/dvd/AppStream/Packages2.安装软件[root@foundation0 Packages]# rpm -ivh lftp-4.8.4-1.el8.x86_64.rpm rpm包查询命令12345678910111213141516171819202122232425262728293031323334353637383940语法:rpm -q 软件包名称选项：-q: query 查询，和其他参数配合-l：list 列出软件包安装后给系统带来的所有文件-a：all 查看所有已安装的软件包-c: configure 查看软件包提供的配置文件练习:【f0】[root@foundation0 dvd]# pwd/content/rhel8.4/x86_64/dvd【servera】[root@servera yum.repos.d]# vim /etc/yum.repos.d/rhel_dvd.repo http://content.example.com/rhel8.4/x86_64/dvd/BaseOS http://content.example.com/rhel8.4/x86_64/dvd/AppStream通过浏览器打开以上地址，可以查询到lftp或telnet相关软件，网页中ctrl+f搜索，输入lftp找到对应的软件，右键copy Link location，再到命令行中粘贴即可rpm -ivh http://foundation0.ilt.example.com/dvd/AppStream/Packages/telnet-0.17-73.el8.x86_64.rpmerpm -q telnetrpm -q sshrpm -q opensshrpm -qarpm -qa | grep telnetrpm -qa | grep sshrpm -ql telnetrpm -qc telnetrpm -qc opensshrpm -qc openssh-serverrpm -qa | grep sshrpm -qc openssh-server-8.0p1-4.el8_1.x86_64vim /etc/ssh/sshd_configrpm -qf /etc/ssh/sshd_configrpm -qi openssh-server-8.0p1-4.el8_1.x86_64卸载RPM包[root@node1 /]# rpm -q telnettelnet-0.17-73.el8.x86_64[root@node1 /]# rpm -e telnet-0.17-73.el8.x86_64[root@node1 /]# rpm -q telnetpackage telnet is not installed 13.2 YUM工具管理yum源文件12345678910111213141516171819202122yum源软件配置方式:[root@servera /]# cd /etc/yum.repos.d/[root@servera yum.repos.d]# mkdir old[root@servera yum.repos.d]# mv * old #将系统默认的yum源文件移动到old中，可以在该文件中查看原来的yum源路径[root@servera yum.repos.d]# man 5 yum.conf[root@servera yum.repos.d]# vim rhel.repo[AppStream] #id名称自定义name=AppStream #描述自定义，和id不必一样baseurl=http://content.example.com/rhel8.4/x86_64/dvd/AppStream #file:///中://是url格式，第三个/是根目录gpgcheck=0 #gpgchek=1 要进行公钥验证，需要再添加选项gpgkey=http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-releaseenabled=1[BaseOS]name=BaseOSbaseurl=http://content.example.com/rhel8.4/x86_64/dvd/BaseOSgpgcheck=0enabled=1[root@servera yum.repos.d]# yum clean all #清除缓存，避免沿用之前缓存的软件[root@servera yum.repos.d]# yum makecache #和当前yum源建立缓存关联[root@servera yum.repos.d]# yum repolist all #查看当前yum源状态[root@servera yum.repos.d]# yum install -y telnet #测试安装软件telnet[root@servera yum.repos.d]# rpm -q telnet #使用rpm方式查询测试 yum源的命令配置方法123456789101112131415161718192021222324252627282930313233343536371 找到提供yum-config-manager命令的软件包名称[foundation0][kiosk@foundation0 ~]$ yum provides yum-config-managerdnf-utils-4.0.2.2-3.el8.noarch #发现提供yum-config-manager命令的包叫dnf-utils(8.0版本里的名字)，如果8.4版本名称为yum-utils2 安装yum-utils软件打开浏览器输入yum源仓库地址，找到yum-utils的软件包，并且通过rpm命令安装网络上的yum-utils软件包，来提通yum-config-manager命令[root@servera ]# rpm -ivh http://content.example.com/rhel8.4/x86_64/dvd/BaseOS/Packages/yum-utils-4.0.18-4.el8.noarch.rpm3 通过yum-config-manager命令部署yum源[root@servera ]# yum-config-manager --help[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/AppStream[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/BaseOS4 命令制作的yum源中没有gpgcheck选项，如何配置？可以通过以下三种方法： 1、此处可以在/etc/yum.repos.d/xx.repo文件里添加 gpgcheck=0 （推荐方案） 2、或者配置/etc/yum.conf,配置gpgcheck=1，改为0 （只在练习考试时使用） 3、或者rpm --import ‘公钥地址’ 导入公钥` （推荐方案）[root@servera yum.repos.d]# rpm --import http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG- KEY-redhat-release 培训环境里/etc/pki/rpm-gpg/保存了公钥[root@servera ]# find / -name *KEY*[root@servera ]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release[root@servera ]# yum clean all[root@servera ]# yum repolist all对称非对称加密公钥（解密） 私钥（加密）红帽发布软件包到互联网开启或关闭[root@servera /]# yum-config-manager --disable rhel-8.0-for-x86_64-appstream-rpms（yum 池ID）[root@servera /]# yum repolist all[root@servera /]# yum-config-manager --enable rhel-8.0-for-x86_64-appstream-rpms[root@servera /]# yum repolist all YUM命令的练习12345678910111213141516171819202122232425yum常见命令yum list httpdyum list http*yum search httpdyum search sshyum info httpd-manual[root@servera /]# yum provides /var/www/htmlyum updateyum install 包名yum remove 包名yum install -y httpd[root@servera /]# yum install -y autofs[root@servera /]# yum remove -y autofs[root@servera /]# yum historyyum clean all 清除缓存yum listyum repolist yum repolist allservera:yum group listyum groupinfo 'Server with GUI'yum groupinstall -y 'Server with GUI'startx 切图形 13.3 第三方YUM源12345678910【基础环境foundation】1.虚拟机联网虚拟机设置里面NAT选择已连接nmcli connection up ens1922.百度搜索（阿里源、华为源...），将.repo文件下载到系统curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo3.验证cd /etc/yum.repos.d/;lsyum repolist allyum install -y vsftpd 14 访问Linux文件系统14.1 存储管理概念文件系统、存储和块设备123456块设备命名-------------------------------- --------------------------------- --/dev/sda、/dev/sdb STAT/SAS（新SCSI技术）/USB 附加存储 /dev/vda、/dev/vdb virtio-blk 超虚拟化存储（部分虚拟机） /dev/nvme0，/dev/nvme1 附加存储 （SSD） /dev/mmcblk0、/dev/mmcblk1 SD卡 磁盘分区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121分区（可选）--格式化--挂载--使用mount命令挂载是临时的，意味着重启系统后将取消挂载。需要手动重新挂载。永久挂载需要将挂载项记入/etc/fstab中（下次基本存储课讲）1 分区，gpt方案 ，分2个区，每个1G[root@servera ~]# fdisk /dev/vdbCommand (m for help): m d delete a partition #删除分区 n add a new partition #创建分区 p print the partition table #打印分区表 w write table to disk and exit #保存并退出 Create a new label g create a new empty GPT partition table #指定分区方案gpt，分区前指定一次即可 o create a new empty DOS partition table #指定分区方位mbrCommand (m for help): g #指定分区方案gptCreated a new GPT disklabel (GUID: D29B3E19-BA51-1042-BFE6-0FD975D1B7DB).Command (m for help): nPartition number (1-128, default 1): #回车First sector (2048-10485726, default 2048): #回车Last sector, +sectors or +size{K,M,G,T,P} (2048-10485726, default 10485726): +1G #指定分区大小1GCreated a new partition 1 of type 'Linux filesystem' and of size 1 GiB.Command (m for help): pDisklabel type: gpt #查看分区方案Device Start End Sectors Size Type #分区表/dev/vdb1 2048 2099199 2097152 1G Linux filesystem #/dev/vdb 分区为1GCommand (m for help): n #创建第二个分区Partition number (2-128, default 2): First sector (2099200-10485726, default 2099200): Last sector, +sectors or +size{K,M,G,T,P} (2099200-10485726, default 10485726): +1GCommand (m for help): pDevice Start End Sectors Size Type/dev/vdb1 2048 2099199 2097152 1G Linux filesystem/dev/vdb2 2099200 4196351 2097152 1G Linux filesystemCommand (m for help): w #保存退出[root@servera ~]# fdisk -l /dev/vdb #查看/dev/vdb分区表Device Start End Sectors Size Type/dev/vdb1 2048 2099199 2097152 1G Linux filesystem/dev/vdb2 2099200 4196351 2097152 1G Linux filesystem[root@servera ~]# lsblk /dev/vdb #lsblk查看块设备NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvdb 252:16 0 5G 0 disk ├─vdb1 252:17 0 1G 0 part └─vdb2 252:18 0 1G 0 part [root@servera ~]# 2 格式化，将两个分区分别格式化为ext4和xfs文件系统语法：mkfs 选项 设备名-t 指定文件系统类型例子：mkfs -t ext4 /dev/vdb1 #方法1mkfs.ext4 /dev/vdb1 #方法2[root@servera /]# mkfs -t ext4 /dev/vdb1 #mkfs格式化 ext4是文件系统类型 /dev/vdb1是要格式化的磁盘分区[root@servera /]# echo $? # $?是看上一条命令返回值，0为正确，非0为错误0[root@servera /]# mkfs.xfs /dev/vdb2[root@servera /]# echo $?0[root@servera ~]# lsblk -f[root@servera ~]# lsblk -f /dev/vdb #查看文件系统类型，NAME FSTYPE LABEL UUID MOUNTPOINTvdb ├─vdb1 ext4 ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs b538bf38-2b33-4d53-a785-372627587c52 3 挂载创建挂载点mkdir /mnt/disk1文件系统：格式化后的设备或分区挂载点：linux中的空目录语法：挂载mount 文件系统 挂载点mount /dev/vdb1 /mnt/disk1卸载umount 文件系统/挂载点umount /dev/vdb1 or umount /mnt/disk1#挂载[root@servera ~]# lsblk -f /dev/vdbNAME FSTYPE LABEL UUID MOUNTPOINTvdb ├─vdb1 ext4 ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs b538bf38-2b33-4d53-a785-372627587c52 [root@servera ~]# mkdir /mnt/{disk1,disk2} # 创建挂载点[root@servera ~]# ls /mntdisk1 disk2[root@servera ~]# mount /dev/vdb1 /mnt/disk1 #将/dev/vdb1 挂载到/mnt/disk1目录上[root@servera ~]# df [root@servera ~]# df -Th #-T 显示文件系统，-h以易读单位显示Filesystem Type Size Used Avail Use% Mounted on/dev/vdb1 ext4 976M 2.6M 907M 1% /mnt/disk1/dev/vdb2 xfs 1014M 40M 975M 4% /mnt/disk2[root@servera ~]# tree /mnt//mnt/├── disk1│ ├── haha.txt│ └── lost+found└── disk2 └── heihei.txt 卸载 [root@servera ~]# cd /mnt/disk2[root@servera disk2]# umount /dev/vdb2 #使用时不能卸载umount: /mnt/disk2: target is busy.[root@servera disk2]# cd / #需要退出挂载点[root@servera /]# umount /dev/vdb2 #卸载[root@servera /]# df -h | tail -2tmpfs 183M 0 183M 0% /run/user/0/dev/vdb1 976M 2.6M 907M 1% /mnt/disk1 检查文件系统12345678910111213141516df 查看系统挂载状态-T 查看文件系统类型-h 以易读方式列出容量单位du 查看文件大小[root@servera /]# du /etc/[root@servera /]# du -h /etc/[root@servera /]# du -sh /etc/24M /etc/[root@servera /]# du /etc/man_db.conf 8 /etc/man_db.conf[root@servera /]# du /etc/man_db.conf -h #占用了的块大小，linux默认一个块4k8.0K /etc/man_db.conf[root@servera /]# ll /etc/man_db.conf -rw-r--r--. 1 root root 5165 Nov 7 2018 /etc/man_db.conf 14.2 文件查找-locate和findlocate12345locateupdatedb #收集所有文件元数据locate passwdlocate -i imagelocate -n 5 image #显示前5行 find12345678910111213141516语法：find 查找范围 查找条件 动作(可选)例：find / -name passwd选项：-name： 以文件名的形式查找-size： 根据文件大小 -size 1k ：大小为1k的文件，+1k大于1k的文件，-1k小于1k的文件-user / -uid： 文件所有者 -user studnet ：student是用户名，查找student拥有的文件-group / -gid-perm： 权限查找 -perm 700 ：搜索权限为700的文件-type： 按文件类型 -type f ： f表示文件，d表示目录动作：-exec： 选项后接Linux指令，操作查找到的文件 command {} ; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152find / -name sshd_configfind /etc -name sshd_configfind /etc -name '*pass*'find / -iname '*pass*' -iname 不区分大小写find / -user studentfind / -group studentfind /home -uid 1000find /home/ -gid 1000find / -user student | xargs ls -lfind / -perm 700 | xargs ls -lll -d /usr/share/selinux/targeted/default/active/modules/disabledfind / -perm 700 -type fll /boot/efi/EFI/redhat/shimx64.efifind / -perm 700 -type d -user studentfind / -perm 700 -type d -user student | xargs ls -ldfind / -type f -size +10kcd /homefind /home/ -perm 700find /etc/ -size 10Mfind /etc/ -size +10Mfind /etc/ -size -10M查找一个‘文件’，大于3k小于10kfind /etc -type f -size +3k -and -size -10kll -acd /etc/ll -hfind ./ -size +1k 如果是小于1k 用-1kdu -sh man_db.conf find /etc -size +1k -and -size -10k &gt; /root/test2.txtfind / -size +1k -and -size -100k -type f | xargs du -shfind / -perm -g=s | xargs ls -ld find / -perm -4000 | xargs ls -ldSUID 4 SGID 2SBIT 1chmod 2700 dirrwxr-sr-- 2754将系统中student用户的文件复制到/root/studentdir目录中，并且保留权限[root@servera ~]# find / -user student -exec cp -a {} /root/studentdir/ \\;将系统中student用户的文件列表保存到/root/studentdir文件中find / -user student &gt; /root/studentdir 14.3 ln 软链接与硬链接123456789软链接：使用范围广，方便访问源文件硬链接：节省系统空间文件链接创建方式：软链接（符号链接）ln -s 源文件 链接文件硬链接：ln 源文件 链接文件 软链接123456ln -s 源文件 链接文件cd /opttouch file1mkdir dirln -s file1 linkfile1ln -s dir1 linkdir1 硬链接1234567891011cd /[root@servera opt]# echo 123 &gt; /opt/sou_file.txt[root@servera opt]# cat /opt/sou_file.txt ln /opt/sou_file.txt /opt/link_file.txt取消链接[root@servera opt]# unlink /opt/link_file.txt[root@servera opt]# lssou_file.txt 软链接和硬链接区别12345678910111.命令相同 参数不同2.硬链接的权限和源文件完全一致 软链接的链接文件权限永远是777 和源文件权限不同3.硬链接可以删除，移动源文件软链接不可以删除，移动源文件4.软链接inode和源文件不同硬链接的inode的源文件相同5.软链接可以对目录及文件生效硬链接只可以对文件操作6.软链接可以跨文件系统硬链接不可以跨文件系统 15 分析服务器获取支持15.1 cockpit123456789101112131415161718192021222324252627282930313233343536[root@servera /]# yum install -y cockpit[root@servera /]# systemctl start cockpit[root@servera /]# systemctl status cockpit添加开机自启动方式：vim /usr/lib/systemd/system/cockpit.service[Install]WantedBy=multi-user.targetsystemctl enable cockpit[root@serveraaa /]# firewall-cmd --permanent --add-service=cockpitsuccess[root@serveraaa /]# firewall-cmd --reloadsuccess[root@serveraaa /]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: enp1s0 sources: services: cockpit dhcpv6-client ssh ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: netstat -ntlp | grep 9090连接cockpitfoundation 连接servera浏览器 http：//172.25.250.10:9090添加信任输入用户名密码 root redhat","link":"/2025/04/15/Linux%E5%9F%BA%E7%A1%80/"},{"title":"podman容器","text":"1 容器概念容器技术介绍​ 软件应用通常依赖于运行时环境(runtimeenvironment)提供的系统库、配置文件或服务。传统上，软件应用的运行时环境安装在物理主机或虚拟机上运行的操作系统中。然后，管理员在操作系统上安装应用依赖项 ​ 在红帽企业Linux中，诸如RPM等打包系统可协助管理员管理应用依赖项。安装httpd软件包时，RPM系统会确保同时安装该软件包的正确库和其他依赖项 ​ 传统方式部署软件应用的主要弊端是这些依赖项会受到运行时环境的束缚，应用需要的支持软件的版本可能比操作系统提供的软件更旧或更新。同一系统上的两个应用可能需要同一软件互不兼容的不同版本 ​ 解决这些冲突的方式之一是将应用打包并作为容器进行部署​ 容器是由一个或多个与系统其余部分隔离的进程组成的集合，软件容器是打包应用以简化其部署和管理的一种方式​ 以实体集装箱为例。集装箱是打包和装运货物的标准方式。它作为一个箱子进行标记、装载、卸载，以及从一个位置运输到另一个位置。集装箱中的内容与其他集装箱的内容隔离，因此互不影响。这些基本原则也适用于软件容器 容器的核心技术 红帽企业Linux通过运用以下核心技术来支持容器: 1.用于资源管理的控制组(cgroups) 2.用于进程隔离的命名空间 3.加强安全边界的SELinux和Seccomp安全计算模式 容器和虚拟机的差异1.容器提供许多与虚拟机相同的益处，如安全、存储和网络隔离等2.这两种技术都将其应用库和运行时资源与主机操作系统或虚拟机监控程序隔离开，反之亦 3.容器和虚拟机以不同的方式与硬件和底层操作系统交互 ** 4.虚拟机具有以下特征: ** 使多个操作系统能够同时在一个硬件平台上运行 ** 使用虚拟机监控程序将硬件分为多个虚拟硬件系统 ** 需要一个完整的操作系统环境来支持该应用 ** 5.容器具有以下特征: ** 直接在操作系统上运行，从而跨系统上的所有容器共享资源 ** 共享主机的内核，但它将应用进程与系统其余部分隔离开来 ** 与虚拟机相比，它需要的硬件资源要少得多，因此容器的启动速度也更快 ** 包括所有依赖项，如系统和编程依赖项，以及配置设置 Rootless和Rootful容器在容器主机上，由特权用户运行的容器称为Rootful容器、由非特权用户运行的容器称为Rootless容器 **Rootless容器不允许使用通常为特权用户保留的系统资源，例如访问受限目录，或在受限端口(1024以下的端口)上发布网络服务。此功能可防止潜在攻击者获取容器主机上的root特权 **如有必要，可使用root用户身份直接运行容器，但如果有漏洞允许攻击者破坏容器，这样做会削弱系统的安全性 设计基于容器的架构 容器是重复利用托管应用并使其可以移植的有效方式 **容器可以轻松地从一个环境迁移到另一个环境，如从开发环境迁移到生产环境 ** 可以保存一个容器的多个版本，并根据需要快速访问每个版本 **容器通常是临时的，可以将运行中容器所生成的数据永久保存到持久存储中，但容器本身通常会在需要时运行，然后停止并被删除，下次需要该特定容器时，将启动新的容器进程 **可以在单个容器中安装含有多个服务的复杂软件应用。例如，Web服务器可能需要使用数据库和消息传递系统。不过，将一个容器用于多个服务会难以管理 **更好的设计是在单独的容器中运行每个组件、Web服务器、数据库和消息传递系统。这样，更新和维护单个应用组件不会影响其他组件或应用堆栈 容器镜像和注册表 运行容器必须使用容器镜像: **容器镜像是包含编码步骤的静态文件，它充当创建容器的蓝图。容器镜像打包应用及其所有依赖项，如系统库、编程语言运行时和库以及其他配置设置** **容器镜像根据规范构建，如开放容器项目(OCI)镜像格式规范。这些规范定义容器镜像的格式，以及镜像支持的容器主机操作系统和硬件架构的元数据 **容器注册表是用于存储和检索容器镜像的存储库。开发人员将容器镜像推送或上传到容器注册表中。可以从注册表中将这些容器镜像拉取或下载到本地系统，以用于运行容器 ** 可使用包含第三方镜像的公共注册表，也可使用贵组织控制的私有注册表 容器镜像来源很重要。和任何其他软件包一样，必须知道是否可以信任容器镜像中的代码。对于是否及如何提供、评估和测试提交给它们的容器镜像，不同的注册表具有不同的策略 **红帽通过两个主容器注册表分发认证容器镜像，可以使用红帽登录凭据来访问这两个注册表: ** 1.utility.redhat.io: 适用于基于官方红帽产品的容器 ** 2.utilityconnect.redhat,com:适用于基于第三方产品的容器 **3.红帽容器目录(https://access.redhat.com/containers)提供了一个基于Web的界面，通过它可以搜索这些注册表中的认证内容。 **4.培训环境中添加了红帽Quay,官方为收费版，培训环境中为免费版utility.lab.example.com 1234567891011121314151617181920# 环境中使用的镜像仓库浏览器访问为:https://utility 账号是:admin 密码:redhat321# 镜像对应的地址为:utility.lab.example.com[kiosk@foundation0 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6### rht-vm-hosts file listing the entries to be appended to /etc/hosts172.25.250.254 bastion.lab.example.com bastion172.25.250.10 servera.lab.example.com servera172.25.250.11 serverb.lab.example.com serverb172.25.250.220 utility.lab.example.com utility172.25.250.9 workstation.lab.example.com workstation# 登录servera请使用ssh方式，不要使用su切换。# 安装容器:[root@foundation0 ~]# ssh root@servera[root@servera ~]# ssh student@localhost[student@servera ~]$ sudo dnf -y install container-tools # 安装podman容器 [student@servera ~]$ podman --version 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 登录容器:# 需要红帽开发人员账户才能从红帽注册表下载镜像。可以使用podman login命令对注册表进行身份验证。如果不向podman login命令提供注册表URL，它会向默认配置的注册表进行身份验证$ podman login --help# 登录方法一(交互)：$ podman login utility.lab.example.com Username: adminPassword: redhat321Login Succeeded!# 登录方法二(非交互)： # 推荐$ podman login utility.lab.example.com -u admin -p redhat321 # 生产环境中是有https验证的Login Succeeded![student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comError: authenticating creds for &quot;utility.lab.example.com&quot;: pinging container registry utility.lab.example.com: Get &quot;https://utility.lab.example.com/v2/&quot;: tls: failed to verify certificate: x509: certificate is not valid for any names, but wanted to match utility.lab.example.com# 如果出现以上报错，是要求https验证，需要通过选项--tls-verify进行手动关闭# podman login utility.lab.example.com -u admin -p redhat321 --tls-verify=false[student@servera ~]$ podman login --helpDescription: Log in to a container registry on a specified server.Usage: podman login [options] [REGISTRY]Examples: podman login quay.io podman login --username ... --password ... quay.io podman login --authfile dir/auth.json quay.ioOptions: --authfile string path of the authentication file. Use REGISTRY_AUTH_FILE environment variable to override --cert-dir string use certificates at the specified path to access the registry --get-login Return the current login user for the registry -p, --password string Password for registry --password-stdin Take the password from stdin --tls-verify Require HTTPS and verify certificates when contacting registries -u, --username string Username for registry -v, --verbose Write more detailed information to stdout[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.com --tls-verify=falseLogin Succeeded!# 登录方法三(非交互):# 使用podman login命令的--username和--password-sdtin选项，指定用于登录注册表的用户和密码# --password-stdin选项从stdin读取密码# 红帽建议不要使用--password选项直接提供密码，因为此选项会将密码存储在日志文件中$ echo redhat321 | podman login -u admin --password-stdin utility.lab.example.com Login Succeeded! 要验证您是否已登录到某一注册表，请使用 podman login命令–get-login选项。及退出登录podman logout 12345678$ podman login --get-login # 查看登录的用户admin[student@servera ~]$ podman login utility.lab.example.com --get-login # 指定仓库地址，查看登录用户admin[student@servera ~]$ podman logout utility.lab.example.com # 登出Removed login credentials for utility.lab.example.com 配置容器注册表容器注册表的默认配置文件是 /etc/containers/registries.conf 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[student@servera ~]$ sudo vim /etc/containers/registries.conf[sudo] password for student: student#第22行 指定可搜索的镜像仓库地址，如果使用完全合格域名，此处可以留空unqualified-search-registries = [&quot;utility.lab.example.com&quot;,&quot;registry.access.redhat.com&quot;,&quot;registry.redhat.io&quot;,&quot;docker.io&quot;]#第24行[[utility]] 解除注释开启以下功能#第37行insecure = true #false/true 开启https安全验证/关闭安全验证#第40行blocked = false #需要过滤掉的镜像仓库地址#第56行location = &quot;utility.lab.example.com&quot; 指定容器注册表位置$注意~/.config/containers/registries.conf目录设置会覆盖/etc/containers/registries.conf推荐：【student】$ mkdir -p ~/.config/containers$ cp /etc/containers/registries.conf ~/.config/containers/registries.conf$ vim ~/.config/containers/registries.confunqualified-search-registries = [&quot;utility.lab.example.com&quot;] [[utility]] insecure = true blocked = false location = &quot;utility.lab.example.com&quot; # 登录容器注册表[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded!# 根据仓库地址搜索镜像[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 注意：如果只访问本地仓库，unqualified-search-registries = [&quot;utility.lab.example.com&quot;]默认即可，但要需要访问外网，需要用root用户修改vim /etc/resolv.conf文件内容添加nameserver 8.8.8.8 优先解析。阿里容器i2kldsde.mirror.aliyuncs.com 使用容器文件构建容器镜像 容器文件是一种文本文件，内含用于构建容器镜像的指令。 **容器文件通常具有定义其文件和目录所在路径或URL的上下文。生成的容器镜像由只读层组成，每一层代表容器文件中的一条指令。** **以下输出是一个容器文件示例，它使用utility.access.redhat.com注册表中的UBI镜像,安装python3 软件包，并将 hello 字符串打印到控制台。** 1234$ cat ContainerfileFROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python3CMD[&quot;/bin/bash&quot;，&quot;-c&quot;，&quot;echo hello&quot;] 创建容器文件及其使用说明超出了本课程的范畴。有关容器文件的更多信息，请参阅DO180课程。 规模化容器管理 新应用越来越多地使用容器来实施功能组件。这些容器提供应用的其他部分使用的服务。组织管理越来越多的容器，可能很快就会不堪重负。 在生产中大规模部署容器需要一个能够应对以下挑战的环境: 平台必须确保提供必要服务的容器的可用性。 环境必须通过增加或减少运行中的容器实例，并对流量进行负载平衡，从而应对应用的使用高峰。 平台必须检测容器或主机的故障，并相应地作出反应。 开发人员可能需要自动工作流，以便透明、安全地向客户交付新的应用版本。 Kubernetes是一项编排服务，可以使在容器主机集群中部署、管理和扩展基于容器的应用变得更加轻而易举。Kubernetes通过负载平衡器将流量重定向到容器，以便您可以扩展提供服务的容器数量。Kubernetes还支持用户定义的健康检查，以便监控您的容器，并在容器出现故障时将其重新启动。 红帽提供了一个名为红帽OpenShift 的kubernetes发行版。红帽OpenShift是基于Kubernetes基础架构构建的一组模块化组件和服务。它为开发人员提供的额外功能包括基于Web的远程管理、多租户、监控与审计、高级安全功能、应用生命周期管理和自助服务实例等。 红帽OpenShift不在本课程讨论范围之内，但您可以通过https://www.openshift.com了解更多相关信息。 34.2 部署容器Podman实用程序 **Podman是来自container-tools元数据包的全功能容器引警，用于管理开放容器计划(0C)容器和镜像 **podman实用程序的运作不使用守护进程，因此开发人员无需系统上的特权用户帐户来启动或停止容器 **Podman提供多个子命令来与容器和镜像交互。以下列表显示了本节中使用的子命令: ** Podman的命令: 命令 描述 podman build 使用容器文件构建容器镜像 podman run 在新容器中运行命令 podman images 列出本地存储中的镜像 podman ps 打印有关容器的信息 podman inspect 显示容器、镜像、卷、网络或容器集的配置 podman pull 从注册表下载镜像 podman cp 在容器和本地文件系统之间复制文件或目录 podman exec 在运行中的容器内执行命令 podman rm 删除一个或多个容器 podman rmi 删除一个或多个本地存储的镜像 podman search 在注册表中搜索镜像 有关各个子命令使用帮助手册的更多信息，请将子命令附加到podman命令，并用连字符将两者分隔。例如，podman-build帮助手册介绍了podmanbuild子命令的用法。 ** 为阐述本课中的主题，请想象以下情景:** ** 作为系统管理员，您被委任了一项任务，使用python-38软件包运行基于名为python38的RHEL8UBI容器镜像的容器。您还有一项任务，从容器文件创建容器镜像，并从该容器镜像运行名为python36的容器。使用容器文件创建的容器镜像必须具有python36:1.0标签。识别两个容器之间的差异。另外，请确保容器中安装的python软件包与本地计算机中安装的Python版本不相冲突。** 安装容器实用工具 container-tools 软件包包含与容器和容器镜像交互所需的实用程序 ** 若要在系统上下载、运行和比较容器，请使用dnfinstall命令来安装container-tools 元软件包** ** 使用dnf info命令查看 container-tools 软件包的版本和内容** 123[student@servera ~]$ sudo dnf -y install container-tools # 安装podman容器 [student@servera ~]$ podman --version[student@servera ~]$ dnf info container-tools container-tools元数据包提供所需的podman和skope实用程序，用于完成分配的任务 从注册表下载容器镜像文件 1.确保podman实用程序已配置为从utility.lab.example.com注册表搜索和下载容器 ** 2.podmaninfo命令显示podman实用程序的配置信息，包括其配置的注册表** 1[student@servera ~]$ podman info podmansearch命令使用registries.conf文件中指定的注册表列表搜索匹配的名称镜像。默认情况下，Podman在所有非限定搜索注册表中执行搜索 让servera联网方法 1231、f0宿主机上ens192是第二块网卡，vmware上选择nat模式-选择‘已连接’，再获取IP，保证可以上网2、在f0宿主机上执行ssh root@172.25.254.254 rht-config-nat3、servera上ping www.baidu.com测试 使用podmansearch命令，显示包含python-38软件包的已配置注册表的镜像列表 1234567891011121314151617181920212223242526272829# 在注册表中搜索镜像[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 # 从注册表中下载镜像[student@servera ~]$ podman pull utility.lab.example.com/ubi7/ubi[student@servera ~]$ podman pull utility.lab.example.com/rhel8/mariadb-103# 列出本地存储中的镜像[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB# 镜像信息注解:REPOSITORY :仓库地址TAG ：标记，latest最近版本IMAGE ID ：镜像ID，ID号唯一，保证镜像唯一性CREATED ：创建时间；SIZE ：镜像大小 12345678910111213141516171819202122232425262728293031323334353637383940练习：以普通用户身份远程登录系统ssh student@localhost 1.登录容器镜像仓库服务器utility.lab.example.com$ sudo vim /etc/containers/registries.conf $ podman login -u admin -p redhat321 utility.lab.example.com 2.搜索镜像服务器仓库utility.lab.example.com所有镜像$ podman search utility.lab.example.com/3.下载rhel7、8、9的ubi系统到本地$ podman pull utility.lab.example.com/ubi7/ubi$ podman pull utility.lab.example.com/ubi8/ubi$ podman pull utility.lab.example.com/ubi9/ubi4.查看本地镜像$ podman images5.通过rhel7的ubi运行一个交互式容器,然后退出$ podman run -ti utility.lab.example.com/ubi7/ubi$ exit #或者按ctrl+d6.通过rhel8的ubi运行一个长期挂载到后台的容器$ podman run -di utility.lab.example.com/ubi8/ubi7.通过rhel9的ubi运行一个长期挂载到后台的容器，并且指定容器名称为rhel9[student@servera ~]$ podman run -di --name rhel9 utility.lab.example.com/ubi9/ubib4b889bb5964acae14a6e7c2d138e8cc56e9ebf94edf9653f5341522ffc9ec768.进入rhel9容器进行交互[student@servera ~]$ podman exec -ti rhel9 /bin/bash[root@b4b889bb5964 /]# cat /etc/redhat-releaseRed Hat Enterprise Linux release 9.3 (Plow)9.使用httpd-24镜像运行一个web服务。并且访问测试#本地测试，如果在其他主机上访问servera容器web服务，需要在servera防火墙允许主机端口809010.使用nginx镜像运行一个web服务。并且访问测试，nginx容器内端口为8011.尝试运行一个mariadb-105的容器 从容器文件创建容器镜像 ** 您获得了以下容器文件，用于在 python36-app目录中创建容器镜像** 12345$ cat Containerfile FROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python36CMD[&quot;/bin/bash&quot;，&quot;-c&quot;，&quot;sleep infinity&quot;]# 此容器文件是教材中例子默认报错，可以使用下面的容器文件 12345[student@servera ~]$ vim ContainerfileFROM utility.lab.example.com/ubi9/ubi:latestRUN echo -e '[rhel-9.3-for-x86_64-baseos-rpms]\\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/BaseOS\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.3 BaseOS (dvd)\\n[rhel-9.3-for-x86_64-appstream-rpms]\\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/AppStream\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.3 Appstream (dvd)'&gt;/etc/yum.repos.d/rhel_dvd.repoRUN yum install --disablerepo=* --enablerepo=rhel-9.3-for-x86_64-baseos-rpms --enablerepo=rhel-9.3-for-x86_64-appstream-rpms -y python3CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;sleep infinity&quot;] 以上容器文件使用utility.lab.example.com/ubi9/ubi:latest镜像作为基础镜像。容器文件而后将安装python36软件包，并运行sleep infinity bash命令来防止容器退出 通常，容器运行一个进程，然后在该进程完成后退出。sleepnfinity命令可防止容器退出因为该进程永远不会完成。然后可以在容器内进行测试、开发和调试 在检查容器文件后，可以使用podman build命令来构建镜像。podmanbuild命令的语法如下所示: 1234567891011121314$ podman build -t NAME:TAG DIR[student@servera ~]$ podman build -t rhel7:2.0 .[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZElocalhost/rhel7 2.0 98d0b6385a00 40 seconds ago 238 MButility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB# 以上输出的最后一行显示了容器镜像ID。大多数Podman命令使用容器镜像ID的前12个字符来指代容器镜像，可以将此短ID或者容器或容器镜像的名称，作为大多数Podman命令的参数# 注解:-t,--tag name 生成镜像的名称NAME:新镜像的名称标签:新镜像的标签。如果未指定标签，则镜像自动标记为latestDIR:工作目录路径。容器文件必须位于工作目录中。如果工作目录是当前目录，则可以用点(.)来指定它。使用-f标志指定与当前目录不同的目录 使用podmaninspect命令来查看容器镜像的低级别信息，并验证其内容是否符合容器要求: 12(podman pull 先下载后再使用inspect)[student@servera ~]$ podman inspect localhost/rhel7:2.0 ** podmaninspect命令的输出显示reqistry.access.redhat.com/ubi8/ubi:latest基础镜像、用于安装python36 软件包的 dnf命令，以及在运行时执行以防止容器退出的sleepinfinity bash命令** 运行容器 现在，您已拥有所需的容器镜像，可以使用它们来运行容器。容器可以处于以下状态之一!Created 已创建好但尚未启动的容器。 运行中 与其进程一起运行的容器。已停止 其进程已停止的容器。 Paused 其进程已暂停的容器。不支持 Rootless容器。 Deleted 其进程处于已死状态的容器。 **podman ps命令列出系统上正在运行的容器。使用podman ps-a来命令查看计算机中的所有容器 (已创建、已停止、已暂停或正在运行)。 ** ** 可使用podmancreate命令来创建容器，以便稍后运行。若要创建容器，请使用容器localhost/rhel7:2.0镜像的ID。也可以使用–name选项设置名称来标识容器。此命令的输出是容器的长ID,如果不指定–name选项，会自动生成一个容器名称。** 1$ podman create --name python36 dd6ca291f097 然后，可使用podman ps和podman ps-a命令来验证容器是否已创建但尚未启动。您可以查看有关 python36容器的信息，如容器的短ID、名称和状态，容器在启动时运行的命令，以及用于创建容器的镜像 12$ podman ps $ podman ps -a 现在已验证容器已正确创建，决定启动容器，所以要运行 podmanstart命令。可以使用名称或容器ID来启动容器。此命令的输出是容器的名称。 12$ podman start python36$ podman ps 从远程存储库运行容器 您可使用podman run命令，在一个步骤中创建并运行容器。podman run命令在容器内运行进程，此进程将启动新容器。 您可以使用podman run命令-d选项以分离模式运行容器，这将在后台运行容器，而不是在会话的前台运行 在python36容器的示例中，您不需要提供容器运行所提的命令，原因是为该容器创建镜像的容器文件中已提供了sleepinfinity 命令 1234567891011121314151617181920212223242526272829podman run -t 终端-i 交互-d 放在后台--name 指定容器的名称，如果不指定，会自从产生名称[student@servera ~]$ podman run -it utility.lab.example.com/ubi7/ubi[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES537b1f1fbb6d utility.lab.example.com/ubi7/ubi:latest /bin/bash About a minute ago Up About a minute objective_antonelli#实验前可以提前下载镜像至本地 #podman search utility.lab.example.com/#podman pull utility.lab.example.com/ubi8/ubi#podman images[student@servera ~]$ podman run -it --name rhel9 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman run -di --name rhel9-1 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES537b1f1fbb6d utility.lab.example.com/ubi7/ubi:latest /bin/bash 5 minutes ago Up 5 minutes objective_antonellifb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 56 seconds ago Up 57 seconds rhel9-1# ctrl+d退出后再查看容器的状态[student@servera ~]$ podman exec -ti rhel9-1 /bin/bash[student@servera ~]$ podman run -d --name rhel9-2 utility.lab.example.com/ubi9/ubi sleep infinity[student@servera ~]$ podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 5 minutes ago Up 5 minutes rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 34 seconds ago Up 34 seconds rhel9-2 容器中的环境隔离 容器隔离应用的环境 **每个容器都有自己的文件系统、网络和进程。查看ps命令的输出，并在主机和运行中容器之间进行比较，就会注意到隔离功能** ** 在本地计算机上运行ps-ax命令，该命令将返回具有许多进程的预期结果** 123456789101112131415[student@servera ~]$ ps -ax[student@servera ~]$ podman run -di --name python36-db utility.lab.example.com/rhel8/mariadb-103f4c3d26df7bd3614e6b4954ae6ed485046128afc89a95cba20c834b2ba0327ff[student@servera ~]$ podman run -di --name python38 utility.lab.example.com/ubi9/ubi8e7870d50daa32c768c4301911364285a659a5383b4cdadc96b8d3b7ff411c2d[student@servera ~]$ podman run -id --name rhel7 utility.lab.example.com/ubi7/ubi2d4b030f4141656f8b4b74d419c2b8de52669927a261953c92409bc995b35922[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 9 hours ago Exited (0) 9 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 9 hours ago Up 9 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 9 hours ago Up 9 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 22 minutes ago Exited (1) 22 minutes ago python36-db8e7870d50daa utility.lab.example.com/ubi9/ubi:latest /bin/bash 16 minutes ago Up 16 minutes python382d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 12 seconds ago Up 13 seconds rhel7 podman exec命令可在运行中的容器内执行命令 **该命令取容器的名称或ID作为第一个参数，并将下列参数作为要在容器内运行的命令** ** 使用podman exec命令查看rhel7容器中正在运行的进程。psaux命令的输出看起来有所不同，因为它运行与本地计算机不同的进程** ** 使用sh -c命令来封装要在容器中执行的命令** ** ps ax &gt;/tmp/process-data.log命令被解释为要在容器中执行的命令。如果不封装命令，则Podman可能会将大于号字符(&gt;)解释为podman命令的一部分，而不是podmanexec选项的参数** 1234567891011121314151617#使用练习环境中的utility.lab.example.com/ubi7/ubi镜像，执行一些其他命令，比如ls /等[student@servera ~]$ podman exec rhel7 ps -ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 /bin/bash 2 ? R 0:00 ps -ax[student@servera ~]$ podman exec rhel7 sh -c 'ps -a &gt; /tmp/process_data.log'[student@servera ~]$ podman exec rhel7 sh -c 'echo China &gt; /test.txt'[student@servera ~]$ podman exec -ti rhel7 /bin/bash[root@2d4b030f4141 /]# ls /bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys test.txt tmp usr var[root@2d4b030f4141 /]# cat test.txtChina[root@2d4b030f4141 /]# cat /tmp/process_data.log PID TTY TIME CMD[root@2d4b030f4141 /]# exitexit[student@servera ~]$ ** 将主机系统上安装的python版本与容器上安装的python版本进行比较:** 123456[student@servera ~]$ podman exec rhel9-1 python3 --versionPython 3.9.18[student@servera ~]$ python3 --versionPython 3.9.18[student@servera ~]$ podman exec python38 python3 --versionPython 3.9.18 容器中的文件系统隔离 开发人员可以使用文件系统隔离功能，为不同版本的编程语言编写和测试应用，无需使用多个物理机或虚拟机。 您将在终端上的/tmp目录中创建一个显示hello world的简单bash 脚本。 12345678[student@servera ~]$ echo &quot;echo Hello China!&quot; &gt; /tmp/hello.sh[student@servera tmp]$ cd /tmp;lltotal 8-rw-r--r--. 1 student student 18 Mar 3 21:24 hello.sh-rw-r--r--. 1 student student 30 Mar 3 21:01 process_data.logdrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-chronyd.service-c0Zzhidrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-dbus-broker.service-QaiP7Ndrwx------. 3 root root 17 Mar 3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-systemd-logind.service-iM6Zeq /tmp/hello.sh文件位于主机计算机上，而不存在于容器内的文件系统上。如果尝试使用podmanexec来执行脚本，则会出现错误，因为容器中不存在/tmp/hello.sh脚本 123456789101112[student@servera tmp]$ stat /tmp/hello.sh File: /tmp/hello.sh Size: 18 Blocks: 8 IO Block: 4096 regular fileDevice: fc04h/64516d Inode: 18159864 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/ student) Gid: ( 1000/ student)Context: unconfined_u:object_r:user_tmp_t:s0Access: 2025-03-03 21:24:33.865950531 -0500Modify: 2025-03-03 21:24:33.865950531 -0500Change: 2025-03-03 21:24:33.865950531 -0500 Birth: 2025-03-03 21:24:33.865950531 -0500[student@servera tmp]$ podman exec rhel7 stat /tmp/hello.shstat: cannot stat '/tmp/hello.sh': No such file or directory podman cp命令在主机和容器文件系统之间复制文件和文件夹。您可以使用podman cp 命令将/tmp/hello.sh文件复制到python38容器: 12345678910[student@servera ~]$ podman cp /tmp/hello.sh rhel7:/tmp/hello.sh[student@servera ~]$ podman exec rhel7 stat /tmp/hello.sh File: '/tmp/hello.sh' Size: 18 Blocks: 8 IO Block: 4096 regular fileDevice: 58h/88d Inode: 10261231 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2025-03-04 02:24:34.000000000 +0000Modify: 2025-03-04 02:24:34.000000000 +0000Change: 2025-03-04 02:28:24.720471184 +0000 Birth: - 脚本复制到容器文件系统后，即可从容器内执行: 12[student@servera ~]$ podman exec rhel7 bash /tmp/hello.shHello China! 删除容器和镜像 ** 使用podman rm和podman rmi命令删除容器和镜像** ** 删除容器镜像之前，必须先从该镜像移除任何现有的运行中容器** ** 删除python38容器及其相关镜像:** 12345678910[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Exited (0) 10 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Up 10 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 10 hours ago Up 10 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld About an hour ago Exited (1) About an hour ago python36-db8e7870d50daa utility.lab.example.com/ubi9/ubi:latest /bin/bash 55 minutes ago Up 55 minutes python382d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 39 minutes ago Up 39 minutes rhel7student@servera ~]$ podman rmi utility.lab.example.com/ubi9/ubi:latestError: image used by 8e7870d50daa32c768c4301911364285a659a5383b4cdadc96b8d3b7ff411c2d: image is in use by a container: consider listing external containers and force-removing image 必须先停止容器，然后才能删除它。若要停止容器，请使用podmanstop命令 12[student@servera ~]$ podman stop python38python38 停止容器后，使用 podman rm 命令来删除容器 12345678910[student@servera ~]$ podman rm --help[student@servera ~]$ podman rm python38python38[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES850618efbece utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Exited (0) 10 hours ago rhel9fb45a06e2271 utility.lab.example.com/ubi9/ubi:latest /bin/bash 10 hours ago Up 10 hours rhel9-1c4f7f4d72747 utility.lab.example.com/ubi9/ubi:latest sleep infinity 10 hours ago Up 10 hours rhel9-2f4c3d26df7bd utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld About an hour ago Exited (1) About an hour ago python36-db2d4b030f4141 utility.lab.example.com/ubi7/ubi:latest /bin/bash 45 minutes ago Up 45 minutes rhel7 ** 当容器不再存在时，可以使用podman rmi命令删除对应的镜像:** 12345678910111213[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZElocalhost/rhel7 2.0 98d0b6385a00 11 hours ago 238 MButility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman rmi 8d2a8803cfcaError: image used by c4f7f4d727471d590f6241cccf0be0b1ef2256cc43a710594642611fe6d0be47: image is in use by a container: consider listing external containers and force-removing image[student@servera ~]$ podman rmi 98d0b6385a00Untagged: localhost/rhel7:2.0Deleted: 98d0b6385a005e09cfcee59a393cfce2fc46b56f09af6c4f87bd874f00966ed2Deleted: 53c739e51f226903b6568038c9cf563de2007f756e0a0e86e5c00604cf474f3dDeleted: 92b83aa1157f23b209f53480c6bbdf780c39490b37337bc4f4fcb1061b7c978 34.3 管理容器存储和网络资源管理容器资源 可以使用容器来运行简单的进程，然后退出。 还可以配置容器以连续运行某一服务，如数据库服务器。如果您持续运行服务，您最终可能需要向容器添加更多资源，如持久存储或对其他网络的访问权限。 可以使用不同的策略为容器配置持久存储: ** 1.对于红帽OpenShift等企业容器平台上的大型部署，您可以使用复杂的存储解决方案为容器提供存储，而无需了解底层基础架构** **2.对于单个容器主机上且无需扩展的小型部署，您可以通过在运行中的容器上创建要挂载的目录，从容器主机创建持久存储** 当Web服务器或数据库服务器等容器为容器主机外部的客户端提供内容时，必须为这些客户端设置通信通道，以访问容器的内容。 可以配置端口映射，以启用与容器的通信。通过端口映射，目的地为容器主机上端口的请求将被转发到容器内的端口。 设想必须执行以下任务: 基于MariaDB，创建名为db01的容器化数据库。 配置容器端口映射和主机防火墙，以允许端口3306/tcp 上的流量。 配置db01容器，以使用具有适当SELinux 上下文的持久存储。 添加适当的网络配置，以便client01容器可以使用DNS与db01容器通信。 容器的环境变量 容器镜像允许在创建时传递环境变量以自定义容器 可以使用环境变量为容器设置参数，以根据您的环境进行定制，无需创建自己的自定义镜像。通常，您不会修改容器镜像，因为这会向镜像添加层，或许更加难以维护。 使用podman run -d –name db01utility.lab.example.com/rhel8/mariadb-103命令运行容器化数据库，但发现容器无法启动。 1234567891011121314151617181920212223242526[student@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103 utility.lab.example.com/rhel9/mariadb-105 utility.lab.example.com/rhel9/httpd-24 utility.lab.example.com/library/nginx utility.lab.example.com/ubi7/ubi utility.lab.example.com/ubi9/ubi utility.lab.example.com/ubi8/ubi utility.lab.example.com/ubi9/python-312 utility.lab.example.com/rhel9/php-82 [student@servera ~]$ podman pull utility.lab.example.com/rhel8/mariadb-103[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman run -d --name db01 utility.lab.example.com/rhel8/mariadb-10329decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f# 发现容器无法启动[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES29decc6e48d6 utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 2 minutes ago Exited (1) 2 minutes ago db01 使用podman container logs命令调查容器状态的原因。 123456789101112131415[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...You must either specify the following environment variables: MYSQL_USER (regex: '^[a-zA-Z0-9_]+$') MYSQL_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$') MYSQL_DATABASE (regex: '^[a-zA-Z0-9_]+$')Or the following environment variable: MYSQL_ROOT_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$')Or both.Optional Settings:...... 12345678910111213# 输出中的usage 标签提供了如何运行镜像的示例。url标签指向红帽容器目录中的一个Web页面，其中记录了环境变量以及有关如何使用容器镜像的其他信息。# 此镜像的文档显示容器将3306端口用于数据库服务。文档中还显示了以下环境变量可用于配置数据库服务:[student@servera ~]$ podman imagesREPOSITORY TAG IMAGE ID CREATED SIZEutility.lab.example.com/ubi9/ubi latest 8d2a8803cfca 12 months ago 219 MButility.lab.example.com/ubi7/ubi latest 87dd8ec61bbc 4 years ago 215 MButility.lab.example.com/rhel8/mariadb-103 latest 11a47e0fbed0 4 years ago 572 MB[student@servera ~]$ podman inspect utility.lab.example.com/rhel8/mariadb-103 | grep usage &quot;usage&quot;: &quot;podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103&quot;, &quot;usage&quot;: &quot;podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103&quot;,$ skopeo inspect docker://utility.lab.example.com/rhel8/mariadb-105 | grep -B 1 Usage#练习过程中可以将usage中提示的示例指令作为参考。 mariadb镜像的环境变量: 变量 描述 MYSQL_USER 要创建的MySQL帐户的用户名 MYSQL_PASSWORD 用户帐户的密码 MYSQL_DATABASE 数据库名称 MYSQL_ROOT_PASSWORD root用户的密码 (可选) 在检查了镜像的可用环境变量后，使用podmanrun命令-e选项将环境变量传递给容器，并使用podmanps命令来验证它是否正在运行。 12345678910111213[student@servera ~]$ podman rm -af29decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db utility.lab.example.com/rhel8/mariadb-10341a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896# 容器启动成功[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES41a62ff2efd7 utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 8 seconds ago Up 8 seconds db01 容器持久存储 ** 默认情况下运行容器时，所有内容都使用基于容器的镜像** **鉴于容器镜像的寿命短，用户或应用写入的所有新数据在移除容器后都会丢失** ** 若要持久保留数据，可以将容器中的主机文件系统内容与–volume(-v)选项搭配使用。在容器中使用此卷类型时，必须考虑文件系统级别的权限** **MariaDB容器镜像中，mysql用户必须拥有/var/lib/mysql目录，就如同MariaDB在主机上运行时一样** **打算挂载到容器中的目录必须具有mysql作为用户和组所有者(或mysql用户的UID/GID，如果主机上没有安装MariaDB)** ** 如果以root 用户身份运行容器，则主机上的UID和GID与容器内的UID和GID匹配** ** 可以使用podmanunshare命令在用户命名空间内运行命令。要获取用户命名空间的UID映射，请使用podmanunshare cat命令** 123456[student@servera ~]$ podman unshare cat /proc/self/uid_map 0 1000 1 1 100000 65536[student@servera ~]$ podman unshare cat /proc/self/gid_map 0 1000 1 1 100000 65536 以上输出显示： 容器中的root用户 (UID和GID为0)映射到主机计算机上的用户(UID和GID为1000) 容器中的UID和GID1映射到主机计算机上的UID和GID 100000 1后的每个UID和GID以1增量递增。例如，容器内的UID和GID30映射到主机计算机上的UID和GID100029 可以使用podmanexec命令查看使用临时存储运行的容器内的mysql用户UID和GID: 12[student@servera ~]$ podman exec -it db01 grep mysql /etc/passwdmysql:x:27:27:MySQL Server:/var/lib/mysql:/sbin/nologin 将/home/user/db_data目录挂载到db01容器中，以在容器的/var/lib/mysql目录中提供持久存储 创建/home/user/db_data目录，并使用podmanunshare命令将27的用户命名空间UID和GID设置为该目录的所有者 12345678910[student@servera ~]$ mkdir /home/student/db_data[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 student student 6 Mar 4 00:43 /home/student/db_data[student@servera ~]$ ll -d -n /home/student/db_datadrwxr-xr-x. 2 1000 1000 6 Mar 4 00:43 /home/student/db_data[student@servera ~]$ podman unshare chown 27:27 /home/student/db_data/[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 100026 100026 6 Mar 4 00:43 /home/student/db_data 容器中的UID和GID 27映射到主机计算机上的UID和GID100026。可以使用ll-d命令查看/home/student/db_data目录的所有权来验证映射。 现在已设置了正确的文件系统级权限，可使用podman run 命令-v选项来挂载目录: 123456789101112131415161718[student@servera ~]$ podman rm -af41a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql utility.lab.example.com/rhel8/mariadb-10354279d1fff7f3b679dd9d4efb7bfa28a626f41f7d07bea50a445ec2392c8cb02# db01容器未在运行[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES54279d1fff7f utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 6 minutes ago Exited (1) 6 minutes ago db01$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data/:/var/lib/mysql \\utility.lab.example.com/rhel8/mariadb-103 podman container logs命令显示/var/lib/mysql/data目录的权限错误： 12345678910111213141516171819[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...=&gt; sourcing 25-validate-replication-variables.sh ...=&gt; sourcing 30-base-config.sh ...---&gt; 05:58:29 Processing basic MySQL configuration files ...=&gt; sourcing 60-replication-config.sh ...=&gt; sourcing 70-s2i-config.sh ...---&gt; 05:58:29 Processing additional arbitrary MySQL configuration provided by s2i ...=&gt; sourcing 40-paas.cnf ...=&gt; sourcing 50-my-tuning.cnf ...---&gt; 05:58:29 Initializing database ...---&gt; 05:58:29 Running mysql_install_db ...mkdir: cannot create directory '/var/lib/mysql/data': Permission deniedFatal error Can't create database directory '/var/lib/mysql/data'# 发生此错误的原因是，主机上/home/user/db\\_data目录中设置的SELinux上下文不正确 容器存储的SELinux上下文 必须先设置container_file_t SELinux上下文类型，然后才能将该目录作为持久存储挂载到容器 如果目录没有container_file_t SELinux 上下文，则容器无法访问该目录 可以将Z选项附加到podmanrun命令-v选项的参数，以自动设置目录的SELinux上下文 当将/home/student/db_data目录挂载为/var/lib/mysql目录的持久存储时，可以使用podman run -v/home/student/db_data:/var/lib/mysql:Z 命令设置该目录的SELinux上下文 12345678910111213141516171819202122[student@servera ~]$ podman rm -af54279d1fff7f3b679dd9d4efb7bfa28a626f41f7d07bea50a445ec2392c8cb02[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z utility.lab.example.com/rhel8/mariadb-1036195fc399b1f6ae8f5b9d3f436c02bb5d6b093b597949dc968b2a64f6e7d023c[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6195fc399b1f utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 23 seconds ago Up 24 seconds db01[student@servera ~]$ ll -dZ /home/student/db_data/drwxr-xr-x. 3 100026 100026 system_u:object_r:container_file_t:s0:c428,c988 36 Mar 4 01:26 /home/student/db_data/$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data:/var/lib/mysql:Z \\utility.lab.example.com/rhel8/mariadb-103 分配端口映射到容器 要提供对容器的网络访问权限，客户端必须连接到容器主机上的端口，这些端口将网络流量传递到容器中的端口 将容器主机上的网络端口映射到容器中的端口时，容器将接收发送到主机网络端口的网络流量。 例如，可以将容器主机上的13306端口映射到容器上的3306端口，以便与MariaDB容器通信。因此，发送到容器主机端口13306的流量将由容器中运行的MariaDB接收。 可以使用 podman run命令 -p选项设置从容器主机上13306端口到db01容器上3306端口的端口映射 1234567891011121314151617181920[student@servera ~]$ podman rm -af6195fc399b1f6ae8f5b9d3f436c02bb5d6b093b597949dc968b2a64f6e7d023c[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z -p 13306:3306 utility.lab.example.com/rhel8/mariadb-10328202973f22d60ea4ccd096b8a321b30c7d57156a2c41d2502c1a0456c794ced[student@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES28202973f22d utility.lab.example.com/rhel8/mariadb-103:latest run-mysqld 20 seconds ago Up 20 seconds 0.0.0.0:13306-&gt;3306/tcp db01$ podman run -d --name db01 \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-p 13306:3306 \\-v /home/student/db_data:/var/lib/mysql:Z \\utility.lab.example.com/rhel8/mariadb-103 使用podmanport命令-a选项可显示正在使用的所有容器端口映射。还可以使用podmanportdb01命令显示 db01容器的映射端口。 1234[student@servera ~]$ podman port -a28202973f22d 3306/tcp -&gt; 0.0.0.0:13306[student@servera ~]$ podman port db013306/tcp -&gt; 0.0.0.0:13306 可以使用firewall-cmd命令允许端口13306流量传入容器主机，以便它可以重定向到容器: 1234567891011121314151617181920212223# Rootless(特权)容器无法打开主机上特权端口1024有 以下的端口。比如-p 80:8000 ，比必须使用root才可以对其进行调整[student@servera ~]$ sudo firewall-cmd --permanent --add-port=13306/tcp[sudo] password for student: success[student@servera ~]$ sudo firewall-cmd --reloadsuccess[student@servera ~]$ sudo firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: eth0 sources: services: cockpit dhcpv6-client ssh ports: 13306/tcp protocols: forward: yes masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: # firewall-cmd --add-port=13306/tcp --permanent# firewall-cmd --reload 附加测试通过主机mariadb数据库客户端软件访问容器数据库服务，需要安装mariadb软件后指定-u账号，-p密码(无空格)，-h数据库服务器所在主机名或IP(不是容器名)及-P(大写)主机映射端口 123456789101112131415161718192021222324252627[kiosk@foundation0 ~]$ sudo dnf -y install mariadb[kiosk@foundation0 ~]$ mysql -u user -ppass -h servera -P 13306 # -h 后面填写您当前实验的主机名或IPWelcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.3.17-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| db || information_schema || test |+--------------------+3 rows in set (0.012 sec)MariaDB [(none)]&gt; USE db;Database changedMariaDB [db]&gt; SHOW TABLES;Empty set (0.001 sec)MariaDB [db]&gt; exitBye 容器中的DNS配置Podmanv4.0支持两种容器网络后端，即Netavark和CNI 自RHEL9起，系统默认使用Netavark。若要验证所用的网络后端，请运行以下podmaninfo命令。 将网络堆栈从 CNI 切换到 Netavark | Red Hat ProductDocumentation 12$ podman info --format {{.Host.NetworkBackend}}netavark 主机上使用默认Podman网络的现有容器无法解析彼此的主机名，因为默认网络上未启用DNS。 使用podman network create命令创建一个支持DNS的网络。您可使用podmannetwork create命令创建名为db_net的网络，并将子网指定为10.87.0.0/16，网关指定为10.87.0.1。 123$ podman network create --gateway 10.87.0.1 --subnet 10.87.0.0/16 db_net$ podman network ls #列出容器网络 如果不指定–gateway 或–subnet 选项，则会使用默认值创建它们。 podman network inspect 命令显示关于特定网络的信息。您可以使用podmannetwork inspect 命令验证网关和子网的设置是否正确，以及新的dbnet网络是否启用了DNS。 1$ podman network inspect db_net 您可以使用podman run命令–network选项将启用DNS的db_net网络添加到新容器。您可以使用podman run命令–network选项创建连接到db_net网络的db01和client01容器 123456789101112131415161718$ podman run -d --name db01 \\--network db_net \\-e MYSQL_USER=user \\-e MYSQL_PASSWORD=pass \\-e MYSQL_DATABASE=db \\-e MYSQL_ROOT_PASSWORD=redhat \\-v /home/student/db_data:/var/lib/mysql:Z \\-p 13306:3306 \\utility.lab.example.com/rhel8/mariadb-105$ podman run -d --name client01 \\--network db_net \\-v /etc/yum.repos.d:/etc/yum.repos.d/ \\utility.lab.example.com/ubi9-beta/ubi \\sleep infinity$ podman ps -a 由于容器设计为仅具有所需的最少软件包，因此容器可能不具有测试通信所需的实用程序，如ping和ip命令。您可以使用podman exec 命令在容器中安装这些实用程序。 12$ podman exec client01 dnf install -y iputils iproute..output omitted.. 容器现在可以通过容器名称互相 ping。您可以使用podman exec命令来测试DNS解析。名称解析到为db_net网络手动设置的子网内的IP。 123456$ podman exec client01 ping -c4 db01PING db01.dns.podman (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=1 ttl=64 time=1.08 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=2 ttl=64 time=0.082 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=3 ttl=64 time=0.063 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=4 ttl=64 time=0.070 ms 您可以使用 podman exec命令验证每个容器中的IP地址是否与DNS解析匹配。 12$ podman exec client01 ip a | grep 10.8 inet 10.87.0.3/16 brd 10.87.255.255 scope global eth0 多个网络连接到单个容器多个网络可以同时连接到一个容器，以帮助分隔不同类型的流量。 您可以使用podman network create命令创建backend 网络 1$ podman network create backend 然后，使用podman network ls 命令查看所有 Podman 网络。 12345$ podman network lsNETWORK ID NAME DRIVER a7fea510a6d1 backend bridgefe680efc5276 db01 bridge2f259bab93aa podman bridge 没有通过podman network create 命令的–gateway和–subnet选项指定子网和网关。 使用podman network inspect 命令来获取backend网络的IP信息。 1$ podman network inspect backend 在容器运行时，您可以使用podman network connect命令将其他网络连接到容器。您可以使用podman networkconnect命令，将backend网络连接到db01和client01容器。 12$ podman network connect backend db01$ podman network connect backend client01 您可以使用podman inspect命令验证两个网络是否都已连接到各个容器并显示IP信息。 1234$ podman inspect db01$ podman inspect db01 | grep -A 34 Networks &gt; db01$ cat db01 #查看db01的两个网络IP为10.89.0.2 ， 10.87.0.2 client01容器现在可以与两个网络上的db01容器通信。您可以使用podman exec命令从cliento1容器pingdb01容器上的两个网络。 123456$ podman exec -ti client01 ping -c4 10.89.0.2PING 10.89.0.2 (10.89.0.2) 56(84) bytes of data.64 bytes from 10.89.0.2: icmp_seq=1 ttl=64 time=0.352 ms$ podman exec -ti client01 ping -c4 10.87.0.2PING 10.87.0.2 (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2: icmp_seq=1 ttl=64 time=0.594 ms 容器内安装mariadb客户端访问容器数据库 123$ podman exec client01 dnf -y install mariadbpodman$ podman exec -ti client01 mysql -u user -ppass -h db01 34.4 作为系统服务来管理容器使用systemd单元管理小型容器环境可以运行容器来完成系统任务，或获取一系列命令的输出 可能还希望运行无限期运行服务的容器，如Web 服务器或数据库 在传统环境中，特权用户通常将这些服务配置为在系统启动时运行，并使用systemctl 命令进行管理 作为普通用户，可以创建systemd单元来配置您的Rootless容器。利用此配置，可以通过systemctl命令将容器作为常规系统服务进行管理 基于systemd单元管理容器主要用于不需要扩展的基本和小型部署 对于许多基于容器的应用和服务的更复杂扩展和编排，可以使用基于Kubernetes的企业编排平台，如红帽OpenShift容器平台 为探讨本课中的主题，使用以下场景测试作为系统管理员，您被委任了一项任务，将基于nginx镜像的nginx容器配置为在系统启动时启动 必须为Web服务器内容挂载/home/appdev-adm/nginx_web目录，在目录中制作内容为“nginx_web_page”的索引页面，挂载至容器的nginx发布目录/usr/share/nginx/html，并将8080端口从本地计算机映射到容器80 将容器配置为通过systemctl命令来启动和停止 systemd用户服务要求作为普通用户，可以使用systemctl命令来启用服务 该服务在打开会话(图形界面、文本控制台或SSH)时启动，并在关闭最后一个会话时停止。此行为与系统服务有所不同，系统服务是在系统启动时启动并在系统关机时停止。 默认情况下，当使用useradd命令创建用户帐户时，系统将使用普通用户ID范围中的下一个可用ID 系统还在/etc/subuid文件中为用户的容器保留一系列ID 如果使用useradd命令–system选项创建用户帐户，则系统不会为用户容器保留范围。因此，无法使用系统帐户启动Rootless容器。 决定创建一个专门的用户帐户来管理容器。使用useradd命令创建appdev-adm用户，并将redhat用作密码。 12345678[student@servera ~]$ sudo useradd appdev-adm[sudo] password for student:student[student@servera ~]$ sudo passwd appdev-admChanging password for user appdev-adm.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully. 然后，使用 su命令切换到appdev-adm用户，并使用podman命令来启动。 1234567[student@servera ~]$ su appdev-admPassword:redhat[appdev-adm@servera student]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory &quot;/run/user/1000&quot; is not owned by the current user[root@servera ~]# su appdev-adm[appdev-adm@servera root]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory &quot;/run/user/0&quot; is not owned by the current user Podman是一款无状态实用程序，需要完整的登录会话 Podman 必须在SSH会话中使用，不能在sudo或su shell中使用。因此，您将退出sushell，并通过SSH登录计算机。 无状态应用:Stateless Application是指并不会在会话中保存下次会话中去要的客户端数据。每一个会话都像首次执行一样,不会依赖之前的数据进行响应。 123456789101112131415161718192021[appdev-adm@servera root]$ exitexit[root@servera ~]# ssh appdev-adm@localhostappdev-adm@localhost's password:Register this system with Red Hat Insights: insights-client --registerCreate an account or view all your systems at https://red.ht/insights-dashboardLast login: Tue Mar 4 09:06:27 2025[appdev-adm@servera ~]$ podman info[appdev-adm@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded![appdev-adm@servera ~]$ podman search utility.lab.example.com/NAME DESCRIPTIONutility.lab.example.com/rhel8/mariadb-103utility.lab.example.com/rhel9/mariadb-105utility.lab.example.com/rhel9/httpd-24utility.lab.example.com/library/nginxutility.lab.example.com/ubi7/ubiutility.lab.example.com/ubi9/ubiutility.lab.example.com/ubi8/ubiutility.lab.example.com/ubi9/python-312utility.lab.example.com/rhel9/php-82 然后，配置容器注册表并使用您的凭据进行身份验证。您可以使用以下命令运行http 容器。 12345678910[appdev-adm@servera ~]$ mkdir /home/appdev-adm/nginx_web/[appdev-adm@servera ~]$ echo nginx_web_page &gt; /home/appdev-adm/nginx_web/index.html[appdev-adm@servera ~]$ cat /home/appdev-adm/nginx_web/index.htmlnginx_web_page[appdev-adm@servera ~]$ podman run -d --name nginx -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z -p 8080:80 utility.lab.example.com/library/nginx[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 2 minutes ago Up 2 minutes 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera ~]$ curl localhost:8080nginx_web_page 为容器创建systemd用户文件在~/.confiq/svstemd/user/目录中手动定义systemd服务 用户服务的文件语法与系统服务文件的相同。有关更多详细信息，请查看systemd.unit(5)和systemd.service(5)man手册 使用podman generate systemd 命令为现有容器生成systemd 服务文件podmangenerate systemd 命令使用容器作为模型来创建配置文件 podman generate systemd命令–new选项指示podman实用程序对systemd服务进行配置，以便在该服务启动时创建容器并在该服务停止时删除容器 可以使用podman generatesystemd命令和–name选项来显示为nginx容器建模的systemd服务文件 1234567891011121314151617181920212223242526272829303132[appdev-adm@servera ~]$ man systemd.unit | grep config.*user ~/.config/systemd/user.control/* ~/.config/systemd/user/* │~/.config/systemd/user.control │ using the dbus API ($XDG_CONFIG_HOME is used if │ │$HOME/.config/systemd/user │ set, ~/.config otherwise) │[appdev-adm@servera ~]$ man systemd.unit[appdev-adm@servera ~]$ mkdir -p ~/.config/systemd/user/[appdev-adm@servera ~]$ cd ~/.config/systemd/user/[appdev-adm@servera ~]$ podman stop nginx # 生成单元文件之前先停止容器nginx[appdev-adm@servera user]$ podman generate systemd -n nginx -f/home/appdev-adm/.config/systemd/user/container-nginx.service[appdev-adm@servera user]$ lscontainer-nginx.service[appdev-adm@servera user]$ systemctl --user enable --now container-nginx.serviceCreated symlink /home/appdev-adm/.config/systemd/user/default.target.wants/container-nginx.service → /home/appdev-adm/.config/systemd/user/container-nginx.service.[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 26 minutes ago Up About a minute 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera user]$ systemctl --user stop container-nginx.service[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 27 minutes ago Exited (0) 16 seconds ago 0.0.0.0:8080-&gt;80/tcp nginx[appdev-adm@servera user]$ systemctl --user restart container-nginx.service$ podman generate systemd -n nginxExecStart=/usr/bin/podman start nginxExecStop=/usr/bin/podman stop -t 10 nginx*$ podman generate systemd -n nginx -f$ lscontainer-nginx.service 启动时，systemd守护进程执行podman start命令来启动现有容器 停止时，systemd守护进程执行podmanstop命令来停止容器。请注意，systemd守护进程不会删除该容器。 然后，使用上一命令并加上–new选项来比较systemd配置。 1234567891011$ podman generate systemd -n nginx --newExecStartPre=/bin/rm -f %t/%n.ctr-idExecStart=/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon --rm --sdnotify=conmon --replace -d --name nginx -p 8080:80 -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z utility.lab.example.com/library/nginxExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-idExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id#通过--new选项创建用户单元文件的方法，仅供参考$ cd ~/.config/systemd/user/$ podman generate systemd -n nginx --new -f/home/appdev-adm/.config/systemd/user/container-nginx.service 启动时，systemd守护进程执行 podman run命令以创建并启动新容器。此操作使用podman run命令–rm选项，它将在停止时删除容器。 停止时，systemd 执行 podman stop 命令以停止容器。 在systemd停止容器后，systemd 将使用podman rm -f命令将其移除。 验证 podman generate systemd 命令的输出，并使用–files选项运行上一命令，以在当前目录中创建systemd用户文件。由于nginx容器使用持久存储，因此您选择使用带有–new选项的podmangeneratesystemd命令。然后，创建~/config/systemd/user/目录并将文件移到此位置上 为容器管理systemd用户文件现在，您已创建了 systemd 用户文件，可以使用 systemctl命令 –user选项来管理nginx容器。首先，重新加载systemd守护进程，使systemctl命令知道新的用户文件。使用systemctl–userstart命令启动nginx容器。使用为容器生成的 systemd用户文件的名称。 123456$ systemctl --user enable --now container-nginx.service#其他的管理方法，仅供参考$ systemctl --user status container-nginx.service$ systemctl --user stop container-nginx.service#建议重启验证容器是否可以 开机自启动 下表总结了 systemd 系统和用户服务之间使用的不同目录和命令。 比较系统和用户服务 存储自定义单元文件 系统服务 /etc/systemd/system/unit.service 用户服务 \\~/.config/systemd/user/unit.service 重新加载单元文件 系统服务 # systemctl daemon-reload 用户服务 \\$ systemctl --user daemon-reload 启动和停止服务 系统服务 # systemctl start UNIT \\# systemctl stop UNIT 用户服务 \\$ systemctl --user start UNIT \\$ systemctl --user stop UNIT 在计算机启动时启动服务 系统服务 # systemctl enable UNIT 用户服务 \\$ loginctl enable-linger \\$ systemctl --user enable UNIT 将容器配置为在系统引导时启动此时，systemd服务配置已就绪，可以为给定的用户运行容器。但是，如果用户从系统注销，systemd服务会在特定时间后停止容器。出现此行为的原因是，systemd服务单元是使用.user选项创建的，它在用户登录时启动服务，并在用户注销时停止服务。 ​不过，您可以通过运行loginctl enable-linger命令来更改此默认行为，并强制已启用的服务在服务器启动时启动，并在服务器关闭期间停止。​可以使用loginctl命令将systemd用户服务配置为在所配置服务的最后一个用户会话关闭后保留 使用 loginctl show-user 命令验证配置是否成功。 123456789101112[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=no[appdev-adm@servera ~]$ loginctl enable-linger[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=yes# 重启后进行测试[kiosk@foundation0 ~]$ ssh root@servera[root@servera ~]# ssh appdev-adm@localhost[appdev-adm@servera ~]$ podman ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6f72fe3fc6d7 utility.lab.example.com/library/nginx:latest nginx -g daemon o... 40 minutes ago Up About a minute 0.0.0.0:8080-&gt;80/tcp nginx 以Root 用户身份使用Systemd 管理容器将容器配置为以root身份运行，并使用systemd服务文件进行管理。这种方法的一个优势是，您可以将这些服务文件配置为像常见systemd单元文件那样工作，而不是以特定用户身份来运行。 将服务文件设置为 root的过程与前面概述的Rootless容器过程类似，但以下例外: ​ 不要创建专门的用户来管理容器。 ​服务文件必须在/etc/systemd/system目录中，而不是在~/config/systemd/user目录中 ​使用systemctl命令管理容器，但不使用 –user 选项 ​ 不要以root用户身份运行loginctl enable-linger命令 有关演示，请参见本节末尾参考资料中所列红帽视频频道中的YouTube视频 练习：P358 34.5 容器模考练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-RH134-foundation0$ for i in classroom utility bastion workstation servera;do rht-vmctl start $i;done$ ssh workstation-workstation$ lab start containers-deploy$ ssh servera#第一题-servera$ podman login utility.lab.example.com -u admin -p redhat321 #应提示登录成功$ sudo vim ~/Containerfile FROM utility.lab.example.com/ubi9-beta/ubi:latestRUN mkdir /dir{1,2}RUN echo -e '[rhel-9.0-for-x86_64-baseos-rpms]\\nbaseurl = http://content.example.com/rhel9.0/x86_64/dvd/BaseOS\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.0 BaseOS (dvd)\\n[rhel-9.0-for-x86_64-appstream-rpms]\\nbaseurl = http://content.example.com/rhel9.0/x86_64/dvd/AppStream\\nenabled = true\\ngpgcheck = false\\nname = Red Hat Enterprise Linux 9.0 Appstream (dvd)'&gt;/etc/yum.repos.d/rhel_dvd.repoRUN yum install --disablerepo=* --enablerepo=rhel-9.0-for-x86_64-baseos-rpms --enablerepo=rhel-9.0-for-x86_64-appstream-rpms -y python3CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;sleep infinity&quot;]*$ podman build -t pdf .$ podman images#继续做第二题$ sudo -istudent# mkdir /opt/{file,progress}# chown -R student /opt # ll /opt# exit$ podman run \\ -d \\ --name ascii2pdf \\ -v /opt/file:/dir1:Z \\ -v /opt/progress:/dir2:Z \\ pdf$ podman stop ascii2pdf$ loginctl enable-linger$ loginctl show-user wallah$ MANWIDTH=160; man systemd.unit | grep config.*user... `│$HOME/.config/systemd/user` │...*$ mkdir -p ~/.config/systemd/user/*$ cd ~/.config/systemd/user/*$ podman generate systemd -n ascii2pdf -f*$ systemctl --user enable --now container-ascii2pdf$ systemctl --user status container-logserver 1234$ &lt;Ctrl-D&gt;# cp /etc/fstab /opt/file# ls /opt/progress# file /opt/progress/fstab","link":"/2025/04/15/podman%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"podman容器","slug":"podman容器","link":"/tags/podman%E5%AE%B9%E5%99%A8/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"容器技术","slug":"容器技术","link":"/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://luovip.github.io/img/avatar.png 网站名称：罗宇 网站地址：https://luovip.github.io/ 网站简介：Linux运维技术交流 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}]}